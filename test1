import os
import sys
import sqlite3
import subprocess
import time
import shutil
import urllib.request
from colorama import Fore, Style, init

# Khởi tạo màu sắc
init(autoreset=True)

# Cấu hình
TEMP_DIR = os.path.join(os.getcwd(), "RobloxInjector_Temp") 
COOKIE_FILENAME = "Cookies"
COOKIE_URL = "https://raw.githubusercontent.com/AinsworthNecco/Lychkin/refs/heads/main/cookie"

# [USER CONFIG] Hãy đổi tên package ở đây nếu dùng bản clone (ví dụ: com.roblox.client2)
# Hoặc script sẽ tự động quét nếu bạn để trống
TARGET_PACKAGE = "com.roblox.client2" 

def log(msg, type="INFO"):
    if type == "INFO":
        print(f"{Fore.GREEN}[INFO] {msg}{Style.RESET_ALL}")
    elif type == "WARN":
        print(f"{Fore.YELLOW}[WARN] {msg}{Style.RESET_ALL}")
    elif type == "ERROR":
        print(f"{Fore.RED}[ERROR] {msg}{Style.RESET_ALL}")
    elif type == "DEBUG":
        print(f"{Fore.CYAN}[DEBUG] {msg}{Style.RESET_ALL}")

def run_root_cmd(command):
    """Chạy lệnh shell với quyền root (su) và log chi tiết"""
    try:
        log(f"Exec: {command}", "DEBUG")
        full_cmd = f"su -c '{command}'"
        result = subprocess.run(full_cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        
        stdout = result.stdout.strip()
        stderr = result.stderr.strip()
        code = result.returncode

        if code != 0:
            # log(f"Command Failed (Code {code}): {stderr}", "DEBUG") # Giảm xuống Debug để đỡ rối khi check path
            pass
        return stdout, stderr, code
    except Exception as e:
        log(f"Exception executing command: {e}", "ERROR")
        return None, str(e), -1

def check_root():
    log("Đang yêu cầu quyền Root...", "WARN")
    stdout, stderr, code = run_root_cmd("id")
    if code == 0 and "uid=0" in stdout:
        log("Quyền Root: OK", "INFO")
        return True
    else:
        log("KHÔNG CÓ QUYỀN ROOT!", "ERROR")
        return False

def get_remote_cookie():
    log(f"Đang kết nối tới Github...", "INFO")
    try:
        req = urllib.request.Request(COOKIE_URL, headers={'User-Agent': 'Mozilla/5.0'})
        with urllib.request.urlopen(req) as response:
            if response.status != 200:
                log(f"Lỗi HTTP: {response.status}", "ERROR")
                return None
            data = response.read().decode('utf-8').strip()
            if "_|WARNING:-DO-NOT-SHARE" in data:
                start_index = data.find("_|WARNING:-DO-NOT-SHARE")
                cookie = data[start_index:].strip()
                return cookie.splitlines()[0]
            return None
    except Exception as e:
        log(f"Lỗi tải cookie: {e}", "ERROR")
        return None

def kill_app(package_name):
    run_root_cmd(f"am force-stop {package_name}")
    time.sleep(1)

def prepare_db(cookie_value):
    db_path = os.path.join(TEMP_DIR, COOKIE_FILENAME)
    if not os.path.exists(db_path):
        log(f"File không tồn tại: {db_path}", "ERROR")
        return False

    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        # Check bảng
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='cookies';")
        if not cursor.fetchone():
            log("DB lỗi (thiếu bảng cookies).", "ERROR")
            return False

        host_key = ".roblox.com"
        name = ".ROBLOSECURITY"
        
        cursor.execute("DELETE FROM cookies WHERE host_key = ? AND name = ?", (host_key, name))
        
        now = int(time.time() * 1000000)
        expires = 99999999999999999
        
        query_full = """
        INSERT INTO cookies (creation_utc, host_key, name, value, path, expires_utc, is_secure, is_httponly, last_access_utc, has_expires, is_persistent, priority, samesite, source_scheme)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """
        query_fallback = """
        INSERT INTO cookies (creation_utc, host_key, name, value, path, expires_utc, is_secure, is_httponly, last_access_utc)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """
        
        try:
            cursor.execute(query_full, (now, host_key, name, cookie_value, "/", expires, 1, 1, now, 1, 1, 1, 0, 1))
        except sqlite3.OperationalError:
            cursor.execute(query_fallback, (now, host_key, name, cookie_value, "/", expires, 1, 1, now))

        conn.commit()
        conn.close()
        return True
    except Exception as e:
        log(f"Lỗi SQLite: {e}", "ERROR")
        return False

# [NEW] Hàm tìm đường dẫn thực sự của file Cookies
def find_real_cookie_path(package_name):
    base_path = f"/data/data/{package_name}/app_webview"
    
    # Danh sách các vị trí có thể chứa file Cookies
    possible_paths = [
        f"{base_path}/Default/Cookies",  # Android/WebView mới
        f"{base_path}/Cookies"           # Android cũ hoặc bản Clone
    ]
    
    log(f"Đang quét tìm file Cookies cho {package_name}...", "DEBUG")
    
    for path in possible_paths:
        # Dùng lệnh test -f của linux để kiểm tra file tồn tại với quyền root
        _, _, code = run_root_cmd(f"[ -f '{path}' ]")
        if code == 0:
            log(f"Đã tìm thấy file Cookies tại: {path}", "INFO")
            return path
            
    log("Không tìm thấy file Cookies ở bất kỳ đâu!", "ERROR")
    return None

def inject_cookie(package_name, cookie_value):
    # Kiểm tra gói cài đặt
    check_pkg, _, _ = run_root_cmd(f"pm path {package_name}")
    if not check_pkg:
        log(f"Gói {package_name} chưa cài đặt!", "ERROR")
        return

    # [FIX] Tự động tìm đường dẫn đúng
    target_path = find_real_cookie_path(package_name)
    if not target_path:
        log("Hãy mở game lên, đăng nhập một nick rác để game tạo file Cookies rồi thử lại.", "WARN")
        return

    log("=== BẮT ĐẦU QUY TRÌNH TIÊM ===", "INFO")
    kill_app(package_name)
    
    if os.path.exists(TEMP_DIR):
        shutil.rmtree(TEMP_DIR)
    os.makedirs(TEMP_DIR)
    
    # Copy DB ra
    cmd_cp_out = f"cp {target_path} {TEMP_DIR}/{COOKIE_FILENAME}"
    _, err, code = run_root_cmd(cmd_cp_out)
    
    if code != 0:
        log(f"Lỗi copy: {err}", "ERROR")
        return

    run_root_cmd(f"chmod 777 {TEMP_DIR}/{COOKIE_FILENAME}")
    
    if not prepare_db(cookie_value):
        return

    # Copy DB vào
    cmd_cp_in = f"cp {TEMP_DIR}/{COOKIE_FILENAME} {target_path}"
    run_root_cmd(cmd_cp_in)
    
    # Fix quyền (Lấy owner của thư mục cha chứa file cookies)
    parent_dir = os.path.dirname(target_path)
    owner_raw, _, _ = run_root_cmd(f"stat -c '%U:%G' {parent_dir}")
    owner = owner_raw.strip()
    
    if owner:
        run_root_cmd(f"chown {owner} {target_path}")
        run_root_cmd(f"chmod 600 {target_path}")
    
    if os.path.exists(TEMP_DIR):
        shutil.rmtree(TEMP_DIR)
    
    log(f"THÀNH CÔNG! Đã nạp cookie vào {target_path}", "INFO")

def main():
    print(f"{Fore.CYAN}=== ROBLOX AUTO INJECTOR (SMART PATH DETECT) ==={Style.RESET_ALL}")
    
    if not check_root():
        sys.exit(1)
        
    # Cho phép người dùng nhập tên package khi chạy, hoặc dùng mặc định
    # Nếu chạy curl | python thì nó sẽ dùng mặc định, nhưng ta có thể check args
    target = TARGET_PACKAGE
    
    # Kiểm tra xem người dùng có muốn override target không (để hỗ trợ client2)
    # Logic đơn giản: Check xem com.roblox.client có tồn tại không, nếu không thử client2
    check_main, _, _ = run_root_cmd(f"pm path {target}")
    if not check_main:
        log(f"{target} không thấy, thử tìm com.roblox.client2...", "WARN")
        target = "com.roblox.client2"
    
    log(f"Mục tiêu: {target}", "INFO")

    cookie = get_remote_cookie()
    if not cookie:
        log("Lỗi lấy cookie.", "ERROR")
        sys.exit(1)
        
    inject_cookie(target, cookie)

if __name__ == "__main__":
    main()
