# -*- coding: utf-8 -*-
# Script Bot Discord VMOS Cloud - PhiÃªn báº£n Hybrid (Code cÅ© + Shared Pool)
# KhÃ´i phá»¥c logic check Proxy báº±ng socket vÃ  cÆ¡ cháº¿ request thÃ´ng minh tá»« báº£n cÅ©.

import discord
from discord.ext import commands
import requests
import json
import asyncio
import re
import random
import time
import os
import sys
import socket
from datetime import datetime

# ==============================================================
# ==>> Cáº¤U HÃŒNH TÃ™Y CHá»ˆNH <<==
# ==============================================================

# [CÃ”NG Táº®C LOG] True = Báº­t hiá»‡n log chi tiáº¿t lá»—i/thÃ nh cÃ´ng | False = Táº¯t sáº¡ch log worker
CONSOLE_LOGS = True

# Sá»‘ luá»“ng cá»‘ Ä‘á»‹nh sáº½ khá»Ÿi Ä‘á»™ng khi cÃ³ ngÆ°á»i dÃ¹ng lá»‡nh
MAX_TOTAL_THREADS = 400 

# Timeout kiá»ƒm tra proxy sá»‘ng (giÃ¢y) - Tá»« script cÅ©
CHECK_TIMEOUT = 3

TOKEN_FILE_NAME = "token.txt"
THUMBNAIL_URL = "https://media.tenor.com/uKqSgjwq-jcAAAAM/hatsune-miku-oshi-no-ko.gif"

EMOTES = {
    "loading": "â³",
    "check": "âœ…",
    "error": "âŒ",
    "rocket": "ğŸš€",
    "user": "ğŸ‘¤",
    "time": "â³",
    "chart": "ğŸ“Š",
    "gear": "âš™ï¸",
    "lightning": "âš¡",
    "group": "ğŸ‘¥"
}

PROXY_SOURCES = [
    "https://raw.githubusercontent.com/TheSpeedX/PROXY-List/master/http.txt",
    "https://raw.githubusercontent.com/monosans/proxy-list/main/proxies/http.txt",
    "https://raw.githubusercontent.com/ShiftyTR/Proxy-List/master/http.txt",
    "https://raw.githubusercontent.com/clarketm/proxy-list/master/proxy-list-raw.txt",
    "https://api.proxyscrape.com/v2/?request=getproxies&protocol=http",
    "https://www.proxy-list.download/api/v1/get?type=http"
]

# ==============================================================
# ==== QUáº¢N LÃ TRáº NG THÃI JOB & WORKER ====
# ==============================================================

class BuffJob:
    def __init__(self, user_id, user_name, invite_code, target_amount, ctx, message):
        self.user_id = user_id
        self.user_name = user_name
        self.invite_code = invite_code
        self.target_amount = target_amount
        self.current_success = 0
        self.start_time = time.time()
        self.is_active = True
        self.ctx = ctx
        self.status_message = message 
        self.lock = asyncio.Lock()

    async def increment(self):
        async with self.lock:
            self.current_success += 1
            if self.current_success >= self.target_amount:
                self.is_active = False
            return self.current_success

active_jobs_list = [] 
active_worker_tasks = []
RAW_PROXIES = []

# ==============================================================
# ==== KHÃ”I PHá»¤C LOGIC CÅ¨ (ROBUST REQUESTS) ====
# ==============================================================

def fetch_raw_proxies():
    global RAW_PROXIES
    proxies = set()
    print(f"[System] Äang quÃ©t Proxy tá»« nguá»“n (Code cÅ©)...")
    for url in PROXY_SOURCES:
        try:
            r = requests.get(url, timeout=10)
            if r.status_code == 200:
                for line in r.text.splitlines():
                    line = line.strip()
                    if ":" in line and " " not in line:
                        proxies.add(line)
        except: pass
    
    if len(proxies) > 0:
        RAW_PROXIES = list(proxies)
        print(f"[System] Kho Proxy Ä‘Ã£ cáº­p nháº­t: {len(RAW_PROXIES)} IPs.")
    return len(RAW_PROXIES)

# === KHÃ”I PHá»¤C: HÃ m check socket tá»« script cÅ© ===
def get_live_proxy_from_pool():
    """Láº¥y ngáº«u nhiÃªn 1 proxy tá»« kho, check sá»‘ng má»›i tráº£ vá»."""
    if not RAW_PROXIES: return None
    # Thá»­ tá»‘i Ä‘a 20 láº§n Ä‘á»ƒ tÃ¬m 1 con proxy sá»‘ng
    for _ in range(20):
        try:
            proxy = random.choice(RAW_PROXIES)
            if not proxy: continue
            ip, port = proxy.split(":")
            port = int(port)
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(CHECK_TIMEOUT)
            sock.connect((ip, port))
            sock.close()
            return f"http://{proxy}"
        except:
            continue
    return None

def format_proxy(proxy_str):
    if not proxy_str: return None
    return {'http': proxy_str, 'https': proxy_str}

def get_proxy_ip(proxy_str):
    try:
        if "@" in proxy_str: return proxy_str.split("@")[1].split(":")[0]
        else: return proxy_str.split("//")[1].split(":")[0]
    except: return "Unknown"

# === KHÃ”I PHá»¤C: HÃ m Request thÃ´ng minh tá»« script cÅ© ===
def make_vmos_request_smart(url, headers, payload_dict, proxy_str):
    try:
        is_get_request = not payload_dict
        payload_str = json.dumps(payload_dict) if not is_get_request else None
        request_method = requests.get if is_get_request else requests.post
        
        request_args = { 'url': url, 'headers': headers, 'timeout': 20 }
        if proxy_str: request_args['proxies'] = format_proxy(proxy_str)
        if payload_str: request_args['data'] = payload_str

        response = request_method(**request_args)
        
        # Check cÃ¡c lá»—i cháº·n IP phá»• biáº¿n
        ip_block_msg = "certain foreign ip addresses have been restricted"
        if response.status_code in [403, 407, 429, 502, 503] or ip_block_msg in response.text.lower():
            return None, True 

        try:
            if "application/json" in response.headers.get("Content-Type", ""):
                 response.json() # Check valid json
        except:
             return None, True 

        return response, False 

    except (requests.exceptions.ProxyError, requests.exceptions.ConnectTimeout, requests.exceptions.ConnectionError, requests.exceptions.ReadTimeout):
        return None, True 
    except Exception as e:
        return None, False

# === CÃC HÃ€M LOGIC CHÃNH (Restored) ===

def get_temp_email(proxy=None):
    url="https://api.internal.temp-mail.io/api/v3/email/new"
    ua="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36"
    headers={
        "Accept":"application/json, text/plain, */*",
        "Accept-Language":"en-US,en;q=0.9,vi;q=0.8",
        "Application-Name":"web",
        "Application-Version":"2.4.2",
        "Content-Type":"application/json;charset=UTF-8",
        "User-Agent":ua
    }
    try:
        request_kwargs = {'url': url, 'headers': headers, 'timeout': 15}
        if proxy: request_kwargs['proxies'] = format_proxy(proxy)
        response=requests.post(**request_kwargs)
        response.raise_for_status()
        data=response.json()
        return data.get("email")
    except: return None

async def get_email_messages(temp_email, proxy=None):
    url=f"https://api.internal.temp-mail.io/api/v3/email/{temp_email}/messages"
    for attempt in range(20): # Loop 20 láº§n nhÆ° cÅ©
        try:
            request_kwargs = {'url': url, 'timeout': 15}
            if proxy: request_kwargs['proxies'] = format_proxy(proxy)

            response=await asyncio.to_thread(requests.get, **request_kwargs)
            
            if response.status_code == 200:
                messages=response.json()
                if messages:
                    for msg in reversed(messages):
                        body_text=msg.get("body_text","")
                        subject=msg.get("subject","")
                        full_text = subject + " " + body_text
                        if full_text:
                            verification_code_match=re.search(r"\b(\d{6})\b", full_text)
                            if verification_code_match:
                                return verification_code_match.group(1)
            await asyncio.sleep(4)
        except: await asyncio.sleep(4)
    return None

def send_to_vmoscloud_smart(email, proxy):
    url="https://api.vsphone.com/vsphone/api/sms/smsSend"
    headers={"content-type":"application/json","origin":"https://cloud.vmoscloud.com","referer":"https://cloud.vmoscloud.com/","user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36"}
    payload={"smsType":2,"mobilePhone":email,"captchaVerifyParam": "{\"sceneId\":\"5jvar3wp\",\"certifyId\":\"Sz5A7mJjnc\",\"deviceToken\":\"U0dfV0VCIzM3OTVkMjgyNDJhMTE2MTliYzI1Zjc4NmY4NGU1M2Q0LWgtMTc1MTI0ODM0NzQ5OC1lOTBiNzJmZGZkZDg0YjUzYTdiZjU0YTRiNWQ3MDIzNiNkOGJCS21wMjdYVGc5bUdPVDVUaUN1N3lWeERuRkZXL2dXSmFOYnYrcjMzTmlWUkVFVUVGVVI2OE9IWnM5U2xyYnZXMnF6WXRsVHZwRGtlclNxUFJrcGlPcGRFaXI2TW5wZUpqTnhtNHB5N29kTUlldnllYXRGbWtXUFRUNm9ldFlUOXowcnB3emJYeGdRNTJ1UVNOSFI5NlVqdGV6YnBJSTh6RU1uN2I0OERZckY1SmZxR3RwbXM1aVUyY3RWTXE2UWVjaXhrZjIvZEZqOVcrc3RqS0NDbUFKUURUUTRZcTFObGR2bm80OG1UZEs2c3hBV29lTWpUZHBOZUI2MCtZYnp6WGI3ZVpjS2ZoMCtwRWN0UkFsWC9XV0EzaDRjb1pwT1dVZzZXejI2WkhtMVNTQll1WEtmYXpsQmhyNUMza3pRcy8zM1BlVW4xd2Q2VFk4dEduVUlxVURLclhUU3ZJS2xlSk9aOWRaYzBOZldEQmdBaXZ2NEkxa09pcHkwdmhpUnphc3ZkczAyOGtPbHlDTFlmUkdyaXYvTS9tUXVxTjl4TzN2VXFtTE9OM2ltZWQ1SGxKNHNVM294ZE5lZGJMN2JvcnNxUEV6ZEVIKy9vNWFGUnI3VnBEOURVWHozZUFyeE9zZU13RHRFdzRTaDR3R1hXNS9FWEVNcXpOM0xwbkFDeHhuRlZIemxLeGM4aHB6a2ZxM1U4NGl1K2hMdE11RVBaamNVdHlWbFVXL0tvazBXUkVpcWVsQUZLcTljQmJUcWJPdy9kZXgzanNLWVIvckNPY3MvcDV6N0lpalIvcDBWbnk5TWp1U2U0U2V0b3djdStFUm9GUzFudW90U1ROIzExOSNkOTYzNzA0ZDk1NTdiODhlMjJhYWJlYjNmMzJjZDA3Nw==\",\"data\":\"JRMmbUseGiM6eQ4LaxVYLx32sUc6EyJfYRA4MlBCDPQgclpB/24VVyx4AK1qL+ksP1FoEwpQJ229/9gCqZA8AoswNlp9L0UPC07tEHBWYVhZOy0lQs9LIuVqNH9xGWPVpShRCh8WNi4eeEoyZGY28h+zdokDk9hbE1BJTaLWjK1KpiBUFiVpTEhefg1bRjg71Flk+x9SfSU+cB15wB9UAVNydxoYuBgbK1lQewIicctfr3JTCci1Xv9rtSsoYJUiaS55ZDlBLnh2WRo9XG05JA57Ly8IT2UVqiBuT9dHcdcubW9BgDh+l2Jg4gNoU2WSAgHRZWUwNyB/PdZ9L1tRVHkeLQW1OT1RV3xJb784Z0JAY2ozCawXcgUGR3pfQAlVDKJQ0nw7ttA7/gT35RIEpd7jJ/kNP6314kJXxpC/U3eyV08JQjqMeQ1kv1IaICsVaW1BCg==\"}"}
    
    response, is_proxy_err = make_vmos_request_smart(url, headers, payload, proxy)
    if is_proxy_err: return False, True 
    if not response: return False, False 
    try:
        resp_json = response.json()
        if resp_json.get("code") == 200 and "success" in resp_json.get("msg", "").lower(): return True, False
    except: pass
    return False, False

def login_to_vmoscloud_smart(email, verify_code, channel_code, proxy):
    url = "https://api.vsphone.com/vsphone/api/user/login"
    headers = { "Content-Type": "application/json", "origin": "https://cloud.vmoscloud.com", "referer": "https://cloud.vmoscloud.com/", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36", "accept": "application/json, text/plain, */*", "accept-language": "vi", "appversion": "1008424", "clienttype": "web", "requestsource": "wechat-miniapp", "suppliertype": "0" }
    payload = { "mobilePhone": email, "loginType": 0, "verifyCode": verify_code, "password": "ba71fb4736613b59be75f9c404b945b1" }
    if channel_code: payload["channel"] = channel_code; headers["channel"] = channel_code

    response, is_proxy_err = make_vmos_request_smart(url, headers, payload, proxy)
    if is_proxy_err: return None, True
    if response:
        try:
            data = response.json()
            if data.get("code") == 200: return True, False
        except: pass
    return False, False

# ==============================================================
# ==== WORKER ON-DEMAND (LOGIC HYBRID) ====
# ==============================================================

async def global_worker(worker_id):
    """
    Worker nÃ y sá»­ dá»¥ng logic CHECK PROXY Sá»NG cá»§a script cÅ© trÆ°á»›c khi lÃ m viá»‡c.
    Äáº£m báº£o tá»· lá»‡ thÃ nh cÃ´ng cao hÆ¡n.
    """
    
    while True:
        if not active_jobs_list: break

        try:
            current_job = random.choice(active_jobs_list)
        except IndexError: break

        if not current_job.is_active:
            continue

        # ==>> KHÃC BIá»†T Lá»šN NHáº¤T: DÃ¹ng hÃ m get_live_proxy_from_pool cÃ³ check socket <<==
        # LÆ°u Ã½: HÃ m nÃ y hÆ¡i cháº­m vÃ¬ pháº£i check connect, nÃªn ta cháº¡y trong thread
        proxy = await asyncio.to_thread(get_live_proxy_from_pool)
        
        if not proxy:
            # KhÃ´ng tÃ¬m Ä‘Æ°á»£c proxy sá»‘ng nÃ o, ngá»§ 5s rá»“i thá»­ láº¡i
            await asyncio.sleep(5) 
            continue

        proxy_ip = get_proxy_ip(proxy)

        # Quy trÃ¬nh cÅ© (Robust)
        try:
            # 1. Get Mail
            email = await asyncio.to_thread(get_temp_email, proxy)
            if not email:
                if CONSOLE_LOGS: print(f"[{proxy_ip}] âŒ Fail: Cannot get email.")
                continue

            # 2. Send SMS (dÃ¹ng hÃ m smart cÅ©)
            sent_ok, is_proxy_err = await asyncio.to_thread(send_to_vmoscloud_smart, email, proxy)
            if is_proxy_err:
                 if CONSOLE_LOGS: print(f"[{proxy_ip}] âš ï¸ Proxy Error at SMS.")
                 continue
            if not sent_ok:
                 if CONSOLE_LOGS: print(f"[{proxy_ip}] âŒ Fail: SMS send failed.")
                 continue
            
            # 3. Wait OTP
            # if CONSOLE_LOGS: print(f"[{proxy_ip}] ğŸ“© Waiting OTP for {email}...")
            otp = await get_email_messages(email, proxy)
            if not otp:
                if CONSOLE_LOGS: print(f"[{proxy_ip}] âŒ Fail: OTP Timeout.")
                continue
            
            # 4. Login (dÃ¹ng hÃ m smart cÅ©)
            login_ok, is_proxy_err_login = await asyncio.to_thread(login_to_vmoscloud_smart, email, otp, current_job.invite_code, proxy)
            
            if login_ok:
                val = await current_job.increment()
                if CONSOLE_LOGS: print(f"[{proxy_ip}] âœ… SUCCESS | {current_job.invite_code} ({val}/{current_job.target_amount})")
            else:
                if CONSOLE_LOGS: print(f"[{proxy_ip}] âŒ Fail: Login failed.")

        except Exception as e:
             # print(e)
             pass
        
        # Nghá»‰ ngÆ¡i giá»¯a cÃ¡c láº§n cháº¡y thÃ nh cÃ´ng Ä‘á»ƒ trÃ¡nh spam quÃ¡ gáº¯t
        await asyncio.sleep(random.uniform(2, 5))

async def check_and_start_workers():
    global active_worker_tasks
    active_worker_tasks = [t for t in active_worker_tasks if not t.done()]
    
    current_workers = len(active_worker_tasks)
    if active_jobs_list and current_workers < MAX_TOTAL_THREADS:
        needed = MAX_TOTAL_THREADS - current_workers
        print(f"[System] ğŸš€ KÃ­ch hoáº¡t {needed} workers (Sá»­ dá»¥ng Logic Check Proxy CÅ©)...")
        
        if not RAW_PROXIES:
            await asyncio.to_thread(fetch_raw_proxies)

        for i in range(needed):
            task = asyncio.create_task(global_worker(f"W-{random.randint(1000,9999)}"))
            active_worker_tasks.append(task)

# ==============================================================
# ==== BOT & UI PANEL ====
# ==============================================================

intents = discord.Intents.default()
intents.message_content = True
bot = commands.Bot(command_prefix='!', intents=intents)

def load_token():
    try:
        with open(TOKEN_FILE_NAME, 'r') as f: return f.read().strip()
    except: return None

@bot.event
async def on_ready():
    print(f"âœ… Bot Online: {bot.user.name}")

def create_panel_embed(job: BuffJob):
    elapsed = int(time.time() - job.start_time)
    percent = int((job.current_success / job.target_amount) * 100) if job.target_amount > 0 else 0
    filled_blocks = int(percent / 10)
    bar = "ğŸŸ¦" * filled_blocks + "â¬œ" * (10 - filled_blocks)
    total_jobs = len(active_jobs_list)
    threads_per_user = int(MAX_TOTAL_THREADS / total_jobs) if total_jobs > 0 else 0

    embed = discord.Embed(color=0x00ffcc)
    embed.add_field(name=f"{EMOTES['rocket']} KÃ­ch hoáº¡t: {job.invite_code}", value=f"**Target:** {job.target_amount}", inline=False)
    col1_val = (f"{EMOTES['user']} **User:** <@{job.user_id}>\n"
                f"{EMOTES['time']} **Thá»i gian cháº¡y:** {elapsed}s")
    embed.add_field(name="ThÃ´ng tin", value=col1_val, inline=True)
    col2_val = (f"{EMOTES['lightning']} **{threads_per_user}** Luá»“ng/User\n"
                f"{EMOTES['group']} **{total_jobs}** NgÆ°á»i Ä‘ang cháº¡y")
    embed.add_field(name=f"{EMOTES['gear']} Há»‡ Thá»‘ng", value=col2_val, inline=True)
    embed.add_field(name=f"{EMOTES['chart']} Tiáº¿n Ä‘á»™", value=f"{bar} **{percent}%** ({job.current_success}/{job.target_amount})", inline=False)
    embed.set_footer(text="ğŸ”„ Panel tá»± lÃ m má»›i má»—i 1 phÃºt.")
    if THUMBNAIL_URL: embed.set_thumbnail(url=THUMBNAIL_URL)
    return embed

async def job_monitor(job: BuffJob):
    while job.is_active:
        current = job.current_success
        embed = create_panel_embed(job)
        try: await job.status_message.edit(embed=embed)
        except: pass
        if current >= job.target_amount:
            job.is_active = False
            break
        # Smart Wait 1 phÃºt
        for _ in range(30): 
            if not job.is_active or job.current_success >= job.target_amount: break
            await asyncio.sleep(2)

    if job in active_jobs_list: active_jobs_list.remove(job)
    embed = create_panel_embed(job)
    embed.color = discord.Color.green()
    embed.set_field_at(0, name=f"âœ… HoÃ n thÃ nh: {job.invite_code}", value=f"**ÄÃ£ buff:** {job.current_success}/{job.target_amount}", inline=False)
    try: await job.status_message.edit(content=f"âœ… <@{job.user_id}> ÄÃ£ xong Ä‘Æ¡n hÃ ng!", embed=embed)
    except: pass

@bot.command()
async def buff(ctx, code: str = None, amount: str = None):
    if not code or not amount: return await ctx.send(f"âŒ CÃº phÃ¡p: `!buff <mÃ£_má»i> <sá»‘_lÆ°á»£ng>`")
    try: target = int(amount)
    except: return await ctx.send("âŒ Sá»‘ lÆ°á»£ng pháº£i lÃ  sá»‘.")

    for job in active_jobs_list:
        if job.invite_code == code: return await ctx.send(f"âš ï¸ MÃ£ `{code}` Ä‘ang cháº¡y rá»“i!")

    loading_embed = discord.Embed(description=f"{EMOTES['loading']} **Khá»Ÿi Ä‘á»™ng Max {MAX_TOTAL_THREADS} luá»“ng (Robust Mode)...**", color=discord.Color.orange())
    msg = await ctx.send(embed=loading_embed)

    new_job = BuffJob(ctx.author.id, ctx.author.name, code, target, ctx, msg)
    active_jobs_list.append(new_job)
    await check_and_start_workers()
    asyncio.create_task(job_monitor(new_job))

@bot.command()
async def stop(ctx, code: str = None):
    stopped = False
    if not code:
        for job in list(active_jobs_list):
            if job.user_id == ctx.author.id:
                job.is_active = False
                active_jobs_list.remove(job)
                await ctx.send(f"ğŸ›‘ ÄÃ£ há»§y Ä‘Æ¡n `{job.invite_code}` cá»§a báº¡n.")
                stopped = True
    else:
        for job in list(active_jobs_list):
            if job.invite_code == code:
                job.is_active = False
                active_jobs_list.remove(job)
                await ctx.send(f"ğŸ›‘ ÄÃ£ há»§y Ä‘Æ¡n `{code}`.")
                stopped = True
                break
    if not stopped and not code: await ctx.send("âŒ Báº¡n khÃ´ng cÃ³ Ä‘Æ¡n nÃ o Ä‘ang cháº¡y.")

bot_token = load_token()
if bot_token: bot.run(bot_token)
else: print("âŒ Lá»—i: ChÆ°a cÃ³ file token.txt")
