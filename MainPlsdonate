--[[
    SCRIPT PLS DONATE AUTOFARM - CHUYỂN ĐỔI SANG RAYFIELD UI
    Người tạo script gốc: tzechco & CF-Trail (và các nguồn khác được ghi nhận)
    Chuyển đổi sang Rayfield: Bởi bạn (với sự hỗ trợ của AI)

    LƯU Ý: SCRIPT NÀY RẤT DÀI VÀ PHỨC TẠP. CẦN KIỂM TRA KỸ LƯỠNG VÀ DEBUG.
    CÁC HÀM EXECUTOR NHƯ isfile, writefile, getgenv PHẢI ĐƯỢC EXECUTOR CỦA BẠN HỖ TRỢ.
]]

local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
if not Rayfield then
    game:GetService("Players").LocalPlayer:Kick("Không thể tải Rayfield UI. Vui lòng kiểm tra link hoặc kết nối mạng.")
    return
end

-- ===== KHỞI TẠO BAN ĐẦU TỪ SCRIPT GỐC (GIỮ NGUYÊN PHẦN LỚN) =====
repeat
    task.wait()
until game:IsLoaded()

if game.PlaceId ~= 8737602449 and game.PlaceId ~= 8943844393 then
    Rayfield:Notify("Sai Game", "Script này chỉ dành cho PLS DONATE.", 10, Enum.RayfieldNotifyInfoType.Error)
    return
end

local identifyexecutor = identifyexecutor or function() return 'Unknown' end
local cloneref = (identifyexecutor() ~= "Synapse Z" and not identifyexecutor():find("Codex") and cloneref) or function(o) return o end
local CoreGui = cloneref(game:GetService("CoreGui"))
local Players = cloneref(game:GetService("Players"))
local HttpService = cloneref(game:GetService("HttpService"))
local TPService = cloneref(game:GetService("TeleportService"))
local PathfindingService = cloneref(game:GetService("PathfindingService"))
local ReplicatedStorage = cloneref(game:GetService("ReplicatedStorage"))
local RunService = cloneref(game:GetService("RunService")) -- Thêm RunService
local TweenService = cloneref(game:GetService("TweenService")) -- Thêm TweenService
local TextChatService = cloneref(game:GetService("TextChatService")) -- Thêm TextChatService
local VoiceChatService = cloneref(game:GetService("VoiceChatService")) -- Thêm VoiceChatService
local VirtualUser = cloneref(game:GetService("VirtualUser")) -- Thêm VirtualUser

if not workspace then
    workspace = cloneref(game:GetService('Workspace'))
end

local Remotes
-- Tìm Remotes (giữ nguyên logic gốc, có thể không tối ưu nhưng theo yêu cầu)
pcall(function() -- Bọc trong pcall để tránh lỗi nếu executor không cho phép require kiểu này ngay
    for i,v in next, ReplicatedStorage:GetChildren() do
        if v.Name:find('Remote') and v:IsA('ModuleScript') then
            local suc = pcall(function()
                return require(v).Event('PromotionBlimpGiftbux') -- Chỉ cần require và check hàm Event
            end)
            if suc and typeof(require(v).Event) == "function" then -- Kiểm tra xem Event có phải là function không
                Remotes = require(v)
                break
            end
        end
        task.wait()
    end
end)

if not Remotes then
    Rayfield:Notify("Lỗi Nghiêm Trọng", "Không tìm thấy Module 'Remotes'. Script không thể hoạt động.", 20, Enum.RayfieldNotifyInfoType.Error)
    warn("SCRIPT_ERROR: Không tìm thấy Remotes module.")
    -- return -- Có thể return ở đây nếu Remotes là thiết yếu
end

-- Các biến toàn cục từ script gốc (ngoại trừ 'library' UI)
local xspin = 0
local nx = 0
local fonts = {
	"AmaticSC","Antique","Arcade","Arial","ArialBold","Bangers","Bodoni","Cartoon","Code","Creepster","DenkOne","Fantasy","Fondamento","FredokaOne",
	"Garamond","Gotham","GothamBlack","GothamBold","GothamMedium","GrenzeGotisch","Highway","IndieFlower","JosefinSans","Jura","Kalam","Legacy",
	"LuckiestGuy","Merriweather","Michroma","Nunito","Oswald","PatrickHand","PermanentMarker","Roboto","RobotoCondensed","RobotoMono","Sarpanch",
	"SciFi","SourceSans","SourceSansBold","SourceSansItalic","SourceSansLight","SourceSansSemibold","SpecialElite","TitilliumWeb","Ubuntu"
} -- Rayfield có thể có danh sách font riêng hoặc bạn cần đảm bảo font này dùng được trong Rayfield

if getgenv().loadedRR_Rayfield then -- Đổi tên biến để tránh xung đột nếu script gốc còn sót lại
    Rayfield:Notify("Script Loaded", "PLS DONATE Autofarm (Rayfield) đã được tải.", 5)
    return
else
    getgenv().loadedRR_Rayfield = true
end

task.wait()

-- Anti-AFK (giữ nguyên)
local connections = getconnections or get_signal_cons or nil
task.spawn(function()
    if false then -- Giữ logic điều kiện gốc (luôn là false ở đây)
        -- for a, b in next, connections(Players.LocalPlayer.Idled) do
        --  b:Disable()
        -- end
    else
        if Players.LocalPlayer then
            Players.LocalPlayer.Idled:Connect(function()
                VirtualUser:CaptureController()
                VirtualUser:ClickButton2(Vector2.new())
            end)
        end
    end
end)

-- Các biến và bảng dữ liệu khác
local _CFRAMETABLE = {{166.584, 3.47699, 371.398},{228.765, 3.57067, 332.55},{225.878, 3.57066, 274.96},{169.654, 4.11481, 232.826},{102.625, 3.57066, 274.941},{109.353, 3.57066, 351.28}, {166.584, 3.47699, 371.399}}
local unclaimed = {}
local mainCheckPosition = Vector3.new(165.161,0,311.636)
local donation, boothText, spamming, hopTimer, vcEnabled
local errCount = 0
local uid = Players.LocalPlayer and Players.LocalPlayer.UserId or 0
local newRaisedFormat = Players.LocalPlayer and Players.LocalPlayer:WaitForChild('leaderstats', 10) and Players.LocalPlayer.leaderstats:WaitForChild('Raised', 10) or {Value = 0} -- Fallback

-- Các hàm executor-dependent
local queueonteleport = (syn and syn.queue_on_teleport) or queue_on_teleport or (fluxus and fluxus.queue_on_teleport) or nil
local httprequest = (syn and syn.request) or http and http.request or http_request or (fluxus and fluxus.request) or request
local isfile = isfile
local writefile = writefile
local readfile = readfile
local delfile = delfile
local setfpscap = setfpscap

if queueonteleport then
    pcall(function() -- Bọc pcall đề phòng lỗi
	    queueonteleport("loadstring(game:HttpGet('https://raw.githubusercontent.com/CF-Trail/tzechco-PlsDonateAutofarmBackup/main/old.lua'))()")
    end)
end

local _HIGHLIGHTLOADER
pcall(function()
     _HIGHLIGHTLOADER = loadstring(game:HttpGet('https://raw.githubusercontent.com/CF-Trail/tzechco-PlsDonateAutofarmBackup/main/hl.lib.lua'))()
end)


-- ===== HỆ THỐNG CÀI ĐẶT (GIỮ NGUYÊN TỪ SCRIPT GỐC) =====
local settingsLock = true -- Sẽ đặt thành false sau khi UI được tạo hoàn chỉnh
getgenv().settings = getgenv().settings or {} -- Khởi tạo nếu chưa có

local sNames = {
	"textUpdateToggle","textUpdateDelay","serverHopToggle","serverHopDelay","hexBox","goalBox","webhookToggle","webhookBox","danceChoice","thanksMessage",
	"signToggle","customBoothText","signUpdateToggle","signText","signHexBox","autoThanks","autoBeg","begMessage","begDelay","fpsLimit","render",
	"thanksDelay","vcServer","donationJump","AlternativeHop","autoNearReply","boothPosition","standingPosition","AnonymousMode","boothSwitcher",
	"serverHopAfterDonation","jumpsPerRobux","staffHopA","spinSet","boothTop","spinSpeedMultiplier","webhookAfterSH","minimumDonated","webhookType",
	"fpsBoost","fontFace","fontSize",'noFont','taggedBoothHop','rainbowText','helloResponce','botResponce',"donateResponce","otherResponce",
	"scamResponce","pingEveryone","pingAboveDono","removeHeadNametag","gravitySwitch","jumpBoost",'goalServerhopSwitch','goalServerhopGoal',
	'highlightSwitch','helicopterEnabled','friendHop','autoReplyNoRespond','antiBotServers','robuxLap'
}
local sValues = { -- Đảm bảo khớp với sNames
	true,30,true,15,"#32CD32",5,false,"","Disabled",{"Thank you","Thanks!","ty :)","tysm!"},false,"✅ 1R$ = +1 SPIN SPEED ✅",false,"your text here",
	"#ffffff",true,true,{"1R$ = +1 SPIN SPEED","Spinning for donations!"},300,60,false,3,false,false,false,false,3,'Front',false,false,false,1,true,
	true,false,1,false,0,'New',false,'SciFi',5,false,false,false,{'Hi','Sup','Hello'},{'no im not','im not a bot'},
	{"sorry im saving","i am saving for my dream item","sorry my robux is pending"}, {"..?", "what", "?"},
	{"im no scam","im not a scammer","this is not a scam"},false,1000,false,false,false,false,0,false,false,true,false,false,false
}

-- Hàm saveSettings (Giữ nguyên, nhưng có thể thêm thông báo Rayfield)
function saveSettings()
    if settingsLock then return end
    if not writefile then
        Rayfield:Notify("Lỗi Executor", "Hàm 'writefile' không tồn tại!", 5, Enum.RayfieldNotifyInfoType.Error)
        return
    end
    local suc, er = pcall(function()
        writefile('plsdonatesettings.txt', HttpService:JSONEncode(getgenv().settings))
    end)
    if not suc then
        Rayfield:Notify("Lỗi Lưu Cài Đặt", "Không thể lưu cài đặt: " .. tostring(er), 7, Enum.RayfieldNotifyInfoType.Error)
        warn('Lỗi khi lưu cài đặt:', er)
    else
        -- Rayfield:Notify("Thành Công", "Cài đặt đã được lưu!", 2, Enum.RayfieldNotifyInfoType.Success) -- Có thể hơi nhiều thông báo
    end
end

-- Load Settings (Giữ nguyên logic, thay thông báo lỗi bằng Rayfield)
if isfile and readfile and delfile then
    if isfile("plsdonatesettings.txt") then
        local sl, er = pcall(function()
            getgenv().settings = HttpService:JSONDecode(readfile('plsdonatesettings.txt'))
        end)
        if er ~= nil then
            Rayfield:Notify("Lỗi Load Cài Đặt", "JSON error, dùng cài đặt mặc định. Chi tiết: " .. tostring(er), 10, Enum.RayfieldNotifyInfoType.Error)
            pcall(delfile, "plsdonatesettings.txt")
            task.wait(0.1)
            -- Logic load backup từ script gốc có thể phức tạp, tạm thời reset về default
            getgenv().settings = {} -- Reset
            for i, v_name in ipairs(sNames) do
                getgenv().settings[v_name] = sValues[i]
            end
            saveSettings() -- Lưu lại cài đặt mặc định mới
        else
            pcall(function() writefile('plsdonatesettingsbackup.txt', HttpService:JSONEncode(getgenv().settings)) end)
        end
    end
    -- Kiểm tra và điền các settings còn thiếu
    local changed = false
    for i, v_name in ipairs(sNames) do
        if getgenv().settings[v_name] == nil then
            getgenv().settings[v_name] = sValues[i]
            changed = true
        end
    end
    if changed then
        saveSettings()
    end
else
    Rayfield:Notify("Lỗi Executor", "Thiếu hàm isfile/readfile/delfile. Dùng cài đặt mặc định.", 7, Enum.RayfieldNotifyInfoType.Warning)
    getgenv().settings = {} -- Reset
    for i, v_name in ipairs(sNames) do
        getgenv().settings[v_name] = sValues[i]
    end
end


-- ===== CÁC HÀM TIỆN ÍCH VÀ LOGIC GAME (COPY TỪ SCRIPT GỐC) =====
-- Chú ý: Thay thế các lệnh print/warn bằng Rayfield:Notify nếu cần thiết cho người dùng.
-- Các hàm như forceServerHop, serverHop, waitServerHop, hopSet, oldWebhook, rgb, v.v.

local positionX = (Players.LocalPlayer.Character and Players.LocalPlayer.Character:WaitForChild('HumanoidRootPart', 5) and Players.LocalPlayer.Character.HumanoidRootPart.Position) or Vector3.new(0,0,0)

function forceServerHop()
    if not httprequest or not TPService or not Remotes then warn("forceServerHop: Missing dependencies") return end
	local gameId = "8737602449"
	local servers = {}
	local success, req = pcall(httprequest, { Url = "https://games.roblox.com/v1/games/" .. gameId .. "/servers/Public?sortOrder=Desc&limit=100" })
	if not success or not req then Rayfield:Notify("Server Hop Error", "Failed to fetch server list: "..(req or "Network error"), 5); return end
	
    local body = HttpService:JSONDecode(req.Body)
	if body and body.data then
		for i, v_server in next, body.data do
			if type(v_server) == "table" and tonumber(v_server.playing) and tonumber(v_server.maxPlayers) and v_server.playing > 19 and v_server.playing < v_server.maxPlayers then
				table.insert(servers, 1, v_server.id)
			end
		end
	end
	if #servers > 0 then
        local targetServer = servers[math.random(1, #servers)]
        Rayfield:Notify("Server Hop", "Đang chuyển server...", 3)
		TPService:TeleportToPlaceInstance(gameId, targetServer, Players.LocalPlayer)
	else
        Rayfield:Notify("Server Hop Error", "Không tìm thấy server phù hợp.", 5)
    end
end


function serverHop() -- More robust version from original
    if not httprequest or not TPService or not Remotes then warn("serverHop: Missing dependencies") return end
    saveSettings()
    local serverst = {}
    local placeId = choosePlaceId() -- choosePlaceId needs to be defined based on original script
    local cursor = nil
    local attempts = 0
    Rayfield:Notify("Server Hop", "Đang tìm server mới...", 3)
    repeat
        attempts = attempts + 1
        local url = ("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Asc&limit=100%s")
            :format(placeId, cursor and "&cursor="..cursor or "")
        local s, response = pcall(httprequest, { Url = url, Method = "GET" })

        if not s or not response or response.StatusCode ~= 200 then
            warn("Failed to fetch server list:", response and response.StatusMessage or "No response")
            task.wait(2) -- Wait before retrying
            if attempts > 3 then Rayfield:Notify("Server Hop Error", "Lỗi API khi lấy danh sách server.", 5); return end
            goto continue_server_hop_loop
        end

        local data = HttpService:JSONDecode(response.Body)
        cursor = data.nextPageCursor 
        
        if data and data.data then
            for _, server_info in ipairs(data.data) do
                if #serverst > 15 then break end -- Limit number of potential servers
                -- Original condition: server.playing > 11. Let's try server.playing < server.maxPlayers and server.playing > (server.maxPlayers / 2)
                if server_info.playing < server_info.maxPlayers and server_info.playing > math.max(11, server_info.maxPlayers * 0.4) then -- Ensure server is not too empty or full
                    table.insert(serverst, server_info.id)
                end
            end
        end
        if #serverst > 0 then -- If we found any suitable server in this batch
            local targetServer = serverst[math.random(1,#serverst)]
            Rayfield:Notify("Server Hop", "Đang chuyển đến server: " .. string.sub(targetServer or "N/A", 1, 8) .. "...", 3)
            TPService:TeleportToPlaceInstance(placeId, targetServer, Players.LocalPlayer)
            return -- Exit after initiating teleport
        end
        ::continue_server_hop_loop::
        task.wait(0.5)
    until not cursor or attempts > 10 -- Max 10 pages or if no more cursors

    if #serverst > 0 then -- Final check if any servers were accumulated
        local targetServer = serverst[math.random(1,#serverst)]
        Rayfield:Notify("Server Hop", "Đang chuyển đến server cuối cùng tìm được...", 3)
        TPService:TeleportToPlaceInstance(placeId, targetServer, Players.LocalPlayer)
    else
        Rayfield:Notify("Server Hop Error", "Không tìm thấy server nào phù hợp sau khi quét.", 5)
    end
end

local function choosePlaceId() -- From original
    if vcEnabled and getgenv().settings.vcServer then return 8943844393
    elseif getgenv().settings.AlternativeHop then return (math.random() < 0.5) and 8943844393 or 8737602449
    else return 8737602449 end
end
if VoiceChatService then
    local s,e = pcall(function() return VoiceChatService:IsVoiceEnabledForUserIdAsync(uid) end)
    vcEnabled = (s and e)
end


function waitServerHop()
	task.wait(getgenv().settings.serverHopDelay * 60)
	serverHop()
end

function hopSet()
	if hopTimer then task.cancel(hopTimer); hopTimer = nil end
	if getgenv().settings.serverHopToggle then
		hopTimer = task.spawn(waitServerHop)
	end
end

function oldWebhook(msg)
    if not httprequest then return end
	if getgenv().settings.webhookBox:gsub(' ', '') == '' then return end
	pcall(httprequest, {
		Url = getgenv().settings.webhookBox:gsub(' ', ''),
		Body = HttpService:JSONEncode({["content"] = msg}),
		Method = "POST",
		Headers = {["content-type"] = "application/json"}
	})
end

function rgb(hex) -- For game elements, not Rayfield UI
	hex = hex:gsub("#", "")
	local r, g, b = tonumber("0x" .. hex:sub(1, 2)), tonumber("0x" .. hex:sub(3, 4)), tonumber("0x" .. hex:sub(5, 6))
	return Color3.new(r/255, g/255, b/255) -- Changed to 0-1 range
end
function true_rgb(hex) -- Original rgb for payload
	hex = hex:gsub("#", "")
	local r, g, b = tonumber("0x" .. hex:sub(1, 2)), tonumber("0x" .. hex:sub(3, 4)), tonumber("0x" .. hex:sub(5, 6))
	return Color3.new(r, g, b)
end


local _boothlocation
local function getBoothLocation() -- determine _boothlocation from original script
    local mapUIWorkspace = Workspace:WaitForChild('MapUI',3)
    local usePlayerGuiPath = false
    if not mapUIWorkspace then usePlayerGuiPath = true end

    if usePlayerGuiPath then
        local playerGui = Players.LocalPlayer and Players.LocalPlayer:WaitForChild('PlayerGui',5)
        if playerGui then
            local mapUIContainer = playerGui:WaitForChild('MapUIContainer',5)
            if mapUIContainer then
                _boothlocation = mapUIContainer:WaitForChild('MapUI',5)
            end
        end
    else
       _boothlocation = mapUIWorkspace
    end
    if not _boothlocation then
        Rayfield:Notify("Lỗi Booth", "Không tìm thấy đối tượng MapUI. Autofarm có thể không hoạt động.", 7, Enum.RayfieldNotifyInfoType.Error)
        if getgenv().settings.serverHopToggle then task.delay(5, serverHop) end -- Thử server hop nếu không thấy map
    end
    return _boothlocation
end
getBoothLocation() -- Call once at start, and maybe periodically or on character added

function formatNumber(n) -- from original
    if n == 420 or n == 425 then n = n + 10 end
    if n >= 10000 then return string.format("%.1fk", n / 1000)
    elseif n >= 1000 then return string.format("%.2fk", n / 1000)
    else return tostring(n) end
end

function updateBoothText() -- from original, ensure Remotes and _boothlocation are valid
    if not Remotes or not _boothlocation or not _boothlocation:FindFirstChild("BoothUI") then return end
    if not (getgenv().settings.textUpdateToggle and getgenv().settings.customBoothText) then return end

    local currentRaw = tonumber(newRaisedFormat.Value)
    local goalRaw    = currentRaw + tonumber(getgenv().settings.goalBox)
    local currentStr = formatNumber(currentRaw)
    local goalStr    = formatNumber(goalRaw)

    local text = getgenv().settings.customBoothText
        :gsub("%%$C", currentStr) -- Escaped %
        :gsub("%%$G", goalStr)    -- Escaped %
        :gsub("%%$JPR", tostring(getgenv().settings.jumpsPerRobux)) -- Escaped %

    if not unclaimed or not unclaimed[2] then return end -- Need a claimed booth to update
    local boothUIFrame = _boothlocation.BoothUI:FindFirstChild("BoothUI" .. unclaimed[2]) -- Assumes unclaimed[2] is the *claimed* booth
    if not boothUIFrame then return end
    local signLabel = boothUIFrame:FindFirstChild("Sign") and boothUIFrame.Sign:FindFirstChild("TextLabel")
    if not signLabel then return end

    if signLabel.Text == text then return end
    if signLabel.Text:find("##") and getgenv().settings.taggedBoothHop and nx >= 1 then
        if serverHop then serverHop() end
        return
    end
    local basePayload = {
        textFont = Enum.Font[getgenv().settings.fontFace] or Enum.Font.SourceSans, richText = true, strokeColor = Color3.new(0,0,0), strokeOpacity = 0,
        textColor = true_rgb(getgenv().settings.hexBox), buttonStrokeColor = Color3.new(0,0,0), buttonTextColor = Color3.new(1,1,1),
        buttonColor = Color3.new(98/255, 255/255, 0), buttonHoverColor = Color3.new(98/255, 255/255, 0), buttonLayout = ""
    }
    basePayload.text = text
    Remotes.Event("SetCustomization"):FireServer(basePayload, "booth")
end

local _TCHANNEL
if TextChatService then _TCHANNEL = TextChatService.TextChannels and TextChatService.TextChannels.RBXGeneral end
function chat(C_1) -- from original
    if _TCHANNEL then _TCHANNEL:SendAsync(C_1)
    else warn("Chat: _TCHANNEL not found") end
end

function begging() -- from original
	while getgenv().settings.autoBeg do
		chat(getgenv().settings.begMessage[math.random(#getgenv().settings.begMessage)])
		task.wait(getgenv().settings.begDelay)
	end
end
-- ... (Sao chép TẤT CẢ các hàm helper và logic cốt lõi khác vào đây: fetchNearPlr, webhook, checkForBots, findUnclaimed, boothclaim, walkToBooth, etc.)

local function findUnclaimed() -- from original, ensure _boothlocation is valid
    if not _boothlocation or not _boothlocation:FindFirstChild("BoothUI") then unclaimed = {}; return end
    unclaimed = {}
    local boothUI = _boothlocation.BoothUI
    local interactions = workspace:WaitForChild("BoothInteractions", 5)
    if not interactions then return end
    local mainPos2D = Vector3.new(mainCheckPosition.X, 0, mainCheckPosition.Z)

    for _, uiFrame in ipairs(boothUI:GetChildren()) do
        if uiFrame:IsA("Frame") and uiFrame:FindFirstChild("Details") and uiFrame.Details:FindFirstChild("Owner") and uiFrame.Details.Owner.Text == "unclaimed" then
            local boothNum = tonumber(uiFrame.Name:match("%d+"))
            if boothNum then
                for _, interact in ipairs(interactions:GetChildren()) do
                    if interact:GetAttribute("BoothSlot") == boothNum then
                        local pos2D = Vector3.new(interact.Position.X, 0, interact.Position.Z)
                        if (pos2D - mainPos2D).Magnitude < 92 then
                            table.insert(unclaimed, boothNum)
                            break
                        end
                    end
                end
            end
        end
    end
end
local bclaimed = false -- from original
local claimCount = 0 -- from original
local function boothclaim() -- from original, ensure Remotes and _boothlocation are valid
    if not Remotes or not _boothlocation or not _boothlocation:FindFirstChild("BoothUI") then error("boothclaim dependencies missing") return end
    if not unclaimed or not unclaimed[2] then error("No target booth (unclaimed[2])") return end
    
	Remotes.Event("ClaimBooth"):InvokeServer(unclaimed[2])
    task.wait(0.75) -- Increased wait
    local ownerLabel = _boothlocation.BoothUI:FindFirstChild("BoothUI" .. unclaimed[2])
    ownerLabel = ownerLabel and ownerLabel:FindFirstChild("Details") and ownerLabel.Details:FindFirstChild("Owner")

	if not ownerLabel or not string.find(ownerLabel.Text, Players.LocalPlayer.DisplayName) and not string.find(ownerLabel.Text, Players.LocalPlayer.Name) then
		task.wait(1)
        ownerLabel = _boothlocation.BoothUI:FindFirstChild("BoothUI" .. unclaimed[2]) -- Re-fetch
        ownerLabel = ownerLabel and ownerLabel:FindFirstChild("Details") and ownerLabel.Details:FindFirstChild("Owner")
		if not ownerLabel or not string.find(ownerLabel.Text, Players.LocalPlayer.DisplayName) and not string.find(ownerLabel.Text, Players.LocalPlayer.Name) then
			error("Failed to verify booth claim")
		end
	end
    bclaimed = true -- Set bclaimed to true on successful claim
end

getgenv().walkToBooth = function() -- from original, ensure workspace and Players.LocalPlayer.Character are valid
    if not Players.LocalPlayer.Character or not Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
	local humanoid = Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return end

    local theCframe
	if string.find(tostring(getgenv().settings.boothPosition), "6") then
		theCframe = CFrame.new(getgenv().settings.boothPosition, 0, 0)
	else
		theCframe = CFrame.new(0, 0, getgenv().settings.boothPosition)
	end
	local boothPos, mainBoothCFrame
    local interactions = workspace:FindFirstChild("BoothInteractions")
    if not interactions then return end

	for i, v_booth_interaction in ipairs(interactions:GetChildren()) do
		if v_booth_interaction:GetAttribute("BoothSlot") == unclaimed[2] then -- Assumes unclaimed[2] is the claimed booth
			mainBoothCFrame = v_booth_interaction.CFrame
			boothPos = v_booth_interaction.CFrame * theCframe
			Players.LocalPlayer.Character.HumanoidRootPart.CFrame = mainBoothCFrame -- Teleport to general area
			break
		end
	end
    if not boothPos then Rayfield:Notify("WalkToBooth", "Không tìm thấy vị trí booth đã claim.", 3); return end

	humanoid.WalkSpeed = 32
	if workspace.Map and workspace.Map:FindFirstChild("Decoration") and workspace.Map.Decoration:FindFirstChild('Benches') then
		pcall(function() workspace.Map.Decoration.Benches:Destroy() end)
	end
	humanoid:MoveTo(boothPos.Position)
	local atBoothSignal = Instance.new("BindableEvent")
    local moveToConn
    moveToConn = humanoid.MoveToFinished:Connect(function(reached)
        atBoothSignal:Fire(reached)
        if moveToConn then moveToConn:Disconnect(); moveToConn = nil end
	end)
	
    local success, reachedTarget = pcall(function() return atBoothSignal.Event:Wait() end)
    if moveToConn then moveToConn:Disconnect() end -- Ensure disconnect

    if not success or not reachedTarget then
        Rayfield:Notify("WalkToBooth", "Không thể di chuyển đến booth, đặt vị trí thủ công.", 3)
    end

	Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(boothPos.Position)
	Players.LocalPlayer.Character:SetPrimaryPartCFrame(CFrame.new(Players.LocalPlayer.Character.HumanoidRootPart.Position, Vector3.new(mainBoothCFrame.Position.X, Players.LocalPlayer.Character.HumanoidRootPart.Position.Y, mainBoothCFrame.Position.Z))) -- Face booth center
	task.wait(0.6)
	humanoid.WalkSpeed = 16
	if Players.LocalPlayer.Character and Remotes then -- Check character again
        local dance = getgenv().settings.danceChoice
        if dance ~= "Disabled" then
    		Players:Chat(("/e dance%s"):format(dance == "1" and "" or dance))
        else
            Players:Chat("/e wave")
        end
    end
	-- bclaimed = true -- Moved to boothclaim on success
end
local walkToBooth = getgenv().walkToBooth -- make it local for event connections if needed


-- ===== TẠO CỬA SỔ RAYFIELD VÀ CÁC THÀNH PHẦN UI =====
local Window = Rayfield:CreateWindow({
    Name = "PLS DONATE Autofarm vX (Rayfield by szze)",
    LoadingTitle = "Đang tải PLS DONATE Autofarm...",
    LoadingSubtitle = "Script by tzechco & CF-Trail",
    ConfigurationSaving = { Enabled = false },
    Discord = { Enabled = true, Invite = "yrQbdfhuqd", RememberJoins = true },
    KeySystem = false
})

-- Tạo các Tab (ID Icon là ví dụ, bạn có thể tìm hoặc để trống)
local BoothTab = Window:CreateTab("Booth", 4483362458)
local MainTab = Window:CreateTab("Main", 4483362458)
local ChatTab = Window:CreateTab("Chat", 4483362458)
local WebhookTab = Window:CreateTab("Webhook", 4483362458)
local ServerHopTab = Window:CreateTab("Server", 4483362458)
local ARTab = Window:CreateTab("Auto Reply", 4483362458)
local SupportTab = Window:CreateTab("Support", 4483362458)


-------------------- TAB: BOOTH --------------------
BoothTab:CreateSection("Booth Display Settings")

BoothTab:CreateToggle({
    Name = "Cập nhật chữ trên booth (Text Update)",
    CurrentValue = getgenv().settings.textUpdateToggle,
    Callback = function(Value)
        if settingsLock then return end; getgenv().settings.textUpdateToggle = Value; saveSettings()
        if Value then updateBoothText() end
    end,
})
BoothTab:CreateInput({
    Name = "Delay cập nhật chữ (giây)", DefaultText = tostring(getgenv().settings.textUpdateDelay), Numeric = true, Float = 0,
    Callback = function(Text)
        if settingsLock then return end; local n = tonumber(Text); if n then getgenv().settings.textUpdateDelay = n; saveSettings() end
    end,
})
BoothTab:CreateInput({
    Name = "Màu chữ (Hex, vd: #32CD32)", DefaultText = getgenv().settings.hexBox,
    Callback = function(Text)
        if settingsLock then return end
        local s,c = pcall(Color3.fromHex, Text)
        if s and string.sub(Text,1,1) == "#" and #Text == 7 then getgenv().settings.hexBox = Text; saveSettings(); updateBoothText()
        else Rayfield:Notify("Lỗi Hex", "Mã Hex không hợp lệ.", 3) end
    end,
})
BoothTab:CreateInput({
    Name = "Mục tiêu Robux (Goal)", DefaultText = tostring(getgenv().settings.goalBox), Numeric = true, Float = 0,
    Callback = function(Text)
        if settingsLock then return end; local n = tonumber(Text); if n then getgenv().settings.goalBox = n; saveSettings(); updateBoothText() end
    end,
})

BoothTab:CreateLabel("Nội dung booth tùy chỉnh:")
BoothTab:CreateLabel("Dùng: $C = Hiện tại, $G = Mục tiêu, $JPR = Jumps/Robux")
local customBoothTextboxElement -- Biến để lưu trữ đối tượng textbox của Rayfield
customBoothTextboxElement = BoothTab:CreateTextbox({ -- Textbox đa dòng
    Name = "Custom Booth Text Area", Text = getgenv().settings.customBoothText, PlaceholderText = "Nhập nội dung của bạn...",
    Callback = function(Text) -- Callback khi nội dung thay đổi (thường là khi mất focus hoặc nhấn Enter)
        if settingsLock then return end
        if #Text > 221 then Rayfield:Notify("Lỗi", "Nội dung booth quá 221 ký tự!", 5); 
            -- Cần cách để revert text trong Rayfield hoặc báo người dùng sửa
            if customBoothTextboxElement and customBoothTextboxElement.SetText then -- Giả sử có hàm SetText
                customBoothTextboxElement:SetText(string.sub(Text, 1, 221))
            end
            return
        end
        getgenv().settings.customBoothText = Text; saveSettings(); updateBoothText()
    end,
})
-- Nút Update thủ công nếu không muốn lưu tự động từ callback Textbox
BoothTab:CreateButton({
    Name = "Cập nhật Nội Dung Booth Ngay",
    Callback = function()
        if settingsLock then return end
        -- Giả sử customBoothTextboxElement.GetValue() hoặc customBoothTextboxElement.CurrentText tồn tại để lấy text hiện tại
        -- Hoặc, nếu callback ở trên đã lưu vào getgenv().settings.customBoothText thì chỉ cần:
        if #getgenv().settings.customBoothText > 221 then Rayfield:Notify("Lỗi", "Nội dung booth quá 221 ký tự!", 5); return end
        updateBoothText()
        Rayfield:Notify("Thành Công", "Đã thử cập nhật nội dung booth.", 3)
    end,
})


local fontOptions = {} -- Populate from 'fonts' table
for _,f_name in ipairs(fonts) do table.insert(fontOptions, f_name) end
BoothTab:CreateDropdown({
    Name = "Font chữ trên Booth", Options = fontOptions, CurrentOption = getgenv().settings.fontFace,
    Callback = function(Option)
        if settingsLock then return end; getgenv().settings.fontFace = Option; saveSettings(); updateBoothText()
    end,
})
BoothTab:CreateDropdown({
    Name = "Vị trí đứng tại Booth", Options = {"Front", "Left", "Right", "Behind"}, CurrentOption = getgenv().settings.standingPosition,
    Callback = function(Option)
        if settingsLock then return end; getgenv().settings.standingPosition = Option;
        if Option == "Front" then getgenv().settings.boothPosition = 3
        elseif Option == "Left" then getgenv().settings.boothPosition = -6
        elseif Option == "Right" then getgenv().settings.boothPosition = 6
        else getgenv().settings.boothPosition = -5.5 end
        saveSettings()
    end,
})


-------------------- TAB: MAIN --------------------
MainTab:CreateSection("General Settings")
MainTab:CreateDropdown({
    Name = "Kiểu nhảy Dance", Options = {"Disabled", "1", "2", "3"}, CurrentOption = getgenv().settings.danceChoice,
    Callback = function(Option)
        if settingsLock then return end; getgenv().settings.danceChoice = Option; saveSettings()
        if Players.LocalPlayer.Character and Remotes then
            if Option == "Disabled" then Players:Chat("/e wave")
            elseif Option == "1" then Players:Chat("/e dance")
            else Players:Chat("/e dance" .. Option) end
        end
    end,
})
MainTab:CreateToggle({
    Name = "Tắt Render 3D (FPS Boost)", CurrentValue = getgenv().settings.render,
    Callback = function(Value)
        if settingsLock then return end; getgenv().settings.render = Value; saveSettings()
        if RunService then RunService:Set3dRenderingEnabled(not Value) end
    end,
})
MainTab:CreateToggle({
    Name = "Chế độ ẩn danh (Anonymous Mode)", CurrentValue = getgenv().settings.AnonymousMode,
    Callback = function(Value)
        if settingsLock then return end; getgenv().settings.AnonymousMode = Value; saveSettings()
        if Remotes then Remotes.Event('SetAnonymousLive'):FireServer(Value) end
    end,
})
MainTab:CreateToggle({
    Name = "Nhảy khi được Donate (Donation Jump)", CurrentValue = getgenv().settings.donationJump,
    Callback = function(Value)
        if settingsLock then return end; getgenv().settings.donationJump = Value; saveSettings()
    end,
})
MainTab:CreateToggle({
    Name = "Hát theo yêu cầu khi Donate (Highlight)", CurrentValue = getgenv().settings.highlightSwitch,
    Callback = function(Value)
        if settingsLock then return end; getgenv().settings.highlightSwitch = Value; saveSettings()
        pcall(function()
            if not _HIGHLIGHTLOADER then return end
            if Value then _HIGHLIGHTLOADER.HLSetup(Players.LocalPlayer.Character)
            else _HIGHLIGHTLOADER.HLUnload(Players.LocalPlayer.Character) end
        end)
    end,
})

MainTab:CreateSection("Donation Effects")
MainTab:CreateToggle({
    Name = "Quay tròn (Spin) [1R$ = +1 tốc độ]", CurrentValue = getgenv().settings.spinSet,
    Callback = function(Value)
        if settingsLock then return end; getgenv().settings.spinSet = Value; saveSettings()
        local char = Players.LocalPlayer.Character
        if not char or not char:FindFirstChild("HumanoidRootPart") or not char:FindFirstChildOfClass("Humanoid") then return end
        local root = char.HumanoidRootPart
        local spinInstance = root:FindFirstChild("Spin")
        if Value then
            if not spinInstance then
                local Spin = Instance.new("BodyAngularVelocity"); Spin.Name = "Spin"; Spin.Parent = root
                Spin.MaxTorque = Vector3.new(0, math.huge, 0)
                Spin.AngularVelocity = Vector3.new(0, (xspin > 0 and xspin or 0.25) * getgenv().settings.spinSpeedMultiplier, 0) -- Use current xspin if available
            end
            -- Logic giữ vị trí khi quay (từ script gốc)
            task.spawn(function()
                if not bclaimed then repeat task.wait() until bclaimed or not getgenv().settings.spinSet end
                if not getgenv().settings.spinSet then return end
                local sppos = root.Position
                while getgenv().settings.spinSet and task.wait() do
                    if not root or not root.Parent then break end
                    if (root.Position - sppos).Magnitude > 12 then
                        root.CFrame = CFrame.new(sppos) - Vector3.new(0,0.1,0)
                    end
                end
            end)
        else
            if spinInstance then spinInstance:Destroy() end
        end
    end,
})
MainTab:CreateInput({
    Name = "Spin Speed Multiplier", DefaultText = tostring(getgenv().settings.spinSpeedMultiplier), Numeric = true, Float = 2, Min = 0.1, Max = 10,
    Callback = function(Text)
        if settingsLock then return end; local n = tonumber(Text); if n then getgenv().settings.spinSpeedMultiplier = n; saveSettings() end
    end,
})

MainTab:CreateToggle({
    Name = "1R$ = +1 Jump Power", CurrentValue = getgenv().settings.jumpBoost,
    Callback = function(Value) if settingsLock then return end; getgenv().settings.jumpBoost = Value; saveSettings() end,
})
MainTab:CreateToggle({
    Name = "1R$ = -1 Gravity", CurrentValue = getgenv().settings.gravitySwitch,
    Callback = function(Value) if settingsLock then return end; getgenv().settings.gravitySwitch = Value; saveSettings() end,
})
MainTab:CreateToggle({
    Name = "Helicopter khi Donate", CurrentValue = getgenv().settings.helicopterEnabled,
    Callback = function(Value) -- Logic helicopter phức tạp, cần test kỹ
        if settingsLock then return end; getgenv().settings.helicopterEnabled = Value; saveSettings()
        local character = Players.LocalPlayer.Character
        if not character or not character:FindFirstChild("HumanoidRootPart") then return end
        local root = character:FindFirstChildOfClass('Humanoid').RootPart
        local heliSpin = root:FindFirstChild("HL1__HELI")
        local heliPlatform = workspace:FindFirstChild("_HIGHLIGHT.CF")

        if not Value then
            if heliSpin then heliSpin:Destroy() end
            if heliPlatform then heliPlatform:Destroy() end
        else
            if not heliSpin then
                local Spin = Instance.new("BodyAngularVelocity"); Spin.Name = "HL1__HELI"; Spin.Parent = root
                Spin.MaxTorque = Vector3.new(0, math.huge , 0); Spin.AngularVelocity = Vector3.new(0, 1, 0)
            end
            if not heliPlatform then
                local __PART = Instance.new('Part', workspace); __PART.Name = '_HIGHLIGHT.CF'; __PART.Size = Vector3.new(20,2,20)
                __PART.Anchored = true; __PART.CFrame = CFrame.new(root.Position - Vector3.new(0, 3, 0)); __PART.Transparency = 0.7
            end
        end
    end,
})
MainTab:CreateToggle({
    Name = "1R$ = 1 vòng quanh map", CurrentValue = getgenv().settings.robuxLap,
    Callback = function(Value) if settingsLock then return end; getgenv().settings.robuxLap = Value; saveSettings() end,
})
MainTab:CreateInput({
    Name = "Số lần nhảy mỗi Robux", DefaultText = tostring(getgenv().settings.jumpsPerRobux), Numeric = true, Float = 0, Min = 1,
    Callback = function(Text)
        if settingsLock then return end; local n = tonumber(Text); if n and n >=1 then getgenv().settings.jumpsPerRobux = n; saveSettings() end
    end,
})

if setfpscap and type(setfpscap) == "function" then
    MainTab:CreateInput({
        Name = "Giới hạn FPS", DefaultText = tostring(getgenv().settings.fpsLimit), Numeric = true, Float = 0, Min = 10, Max = 240,
        Callback = function(Text)
            if settingsLock then return end; local n = tonumber(Text)
            if n and n >= 10 then getgenv().settings.fpsLimit = n; saveSettings(); pcall(setfpscap, n)
            else Rayfield:Notify("Lỗi", "FPS Limit phải là số >= 10.", 3) end
        end,
    })
end
MainTab:CreateButton({
    Name = "Test Donation (6 Robux)",
    Callback = function()
        if Players.LocalPlayer.leaderstats and Players.LocalPlayer.leaderstats.Raised then
            Players.LocalPlayer.leaderstats.Raised.Value = Players.LocalPlayer.leaderstats.Raised.Value + 6
            Rayfield:Notify("Test", "Đã +6 vào Raised (giả lập).", 3)
        end
    end,
})


-------------------- TAB: CHAT --------------------
ChatTab:CreateSection("Auto Messages")
ChatTab:CreateToggle({
    Name = "Tự động cảm ơn (Auto Thank You)", CurrentValue = getgenv().settings.autoThanks,
    Callback = function(Value) if settingsLock then return end; getgenv().settings.autoThanks = Value; saveSettings() end,
})
ChatTab:CreateInput({
    Name = "Delay cảm ơn (giây)", DefaultText = tostring(getgenv().settings.thanksDelay), Numeric = true, Float = 1, Min = 0,
    Callback = function(Text)
        if settingsLock then return end; local n = tonumber(Text); if n then getgenv().settings.thanksDelay = n; saveSettings() end
    end,
})

ChatTab:CreateToggle({
    Name = "Tự động xin (Auto Beg)", CurrentValue = getgenv().settings.autoBeg,
    Callback = function(Value)
        if settingsLock then return end; getgenv().settings.autoBeg = Value; saveSettings()
        if spamming and not Value then task.cancel(spamming); spamming = nil end
        if Value and not spamming then spamming = task.spawn(begging) end
    end,
})
ChatTab:CreateInput({
    Name = "Delay xin (giây)", DefaultText = tostring(getgenv().settings.begDelay), Numeric = true, Float = 0, Min = 1,
    Callback = function(Text)
        if settingsLock then return end; local n = tonumber(Text)
        if n and n >= 1 then
            getgenv().settings.begDelay = n; saveSettings()
            if getgenv().settings.autoBeg then -- Restart begging task with new delay
                if spamming then task.cancel(spamming); spamming = nil end
                spamming = task.spawn(begging)
            end
        end
    end,
})

ChatTab:CreateSection("Message Lists")
-- Thank You Messages (Textbox đa dòng)
local thankYouMessages_Rayfield = table.concat(getgenv().settings.thanksMessage, "\n")
ChatTab:CreateTextbox({
    Name = "Danh sách lời cảm ơn (mỗi dòng 1 tin)", Text = thankYouMessages_Rayfield, PlaceholderText = "Cảm ơn bạn!\nTuyệt vời!",
    Callback = function(FullText)
        if settingsLock then return end
        local split = {}
        for line in string.gmatch(FullText, "[^\r\n]+") do table.insert(split, line) end
        getgenv().settings.thanksMessage = split; saveSettings()
        Rayfield:Notify("Saved", "Thank You messages updated.", 2)
    end,
})
-- Begging Messages (Textbox đa dòng)
local beggingMessages_Rayfield = table.concat(getgenv().settings.begMessage, "\n")
ChatTab:CreateTextbox({
    Name = "Danh sách lời xin (mỗi dòng 1 tin)", Text = beggingMessages_Rayfield, PlaceholderText = "Cho mình xin Robux đi mà :(\ प्लीज डोनेट करें",
    Callback = function(FullText)
        if settingsLock then return end
        local split = {}
        for line in string.gmatch(FullText, "[^\r\n]+") do table.insert(split, line) end
        getgenv().settings.begMessage = split; saveSettings()
        Rayfield:Notify("Saved", "Begging messages updated.", 2)
    end,
})


-------------------- TAB: WEBHOOK --------------------
WebhookTab:CreateSection("Discord Webhook")
WebhookTab:CreateToggle({
    Name = "Thông báo Discord Webhook", CurrentValue = getgenv().settings.webhookToggle,
    Callback = function(Value) if settingsLock then return end; getgenv().settings.webhookToggle = Value; saveSettings() end,
})
WebhookTab:CreateToggle({
    Name = "Thông báo sau khi Server Hop", CurrentValue = getgenv().settings.webhookAfterSH,
    Callback = function(Value) if settingsLock then return end; getgenv().settings.webhookAfterSH = Value; saveSettings() end,
})
WebhookTab:CreateToggle({
    Name = "Ping @everyone nếu Donate > Min", CurrentValue = getgenv().settings.pingEveryone,
    Callback = function(Value) if settingsLock then return end; getgenv().settings.pingEveryone = Value; saveSettings() end,
})
WebhookTab:CreateInput({
    Name = "Webhook URL", DefaultText = getgenv().settings.webhookBox, PlaceholderText = "Dán URL webhook vào đây",
    Callback = function(Text)
        if settingsLock then return end
        if string.find(Text, "api/webhooks") then getgenv().settings.webhookBox = Text; saveSettings()
        else Rayfield:Notify("Lỗi URL", "Webhook URL không hợp lệ.", 3) end
    end,
})
WebhookTab:CreateInput({
    Name = "Số Robux tối thiểu để Ping @everyone", DefaultText = tostring(getgenv().settings.pingAboveDono), Numeric = true, Float = 0,
    Callback = function(Text)
        if settingsLock then return end; local n = tonumber(Text); if n then getgenv().settings.pingAboveDono = n; saveSettings() end
    end,
})
WebhookTab:CreateDropdown({
    Name = "Loại Webhook", Options = {"New", "Old"}, CurrentOption = getgenv().settings.webhookType,
    Callback = function(Option) if settingsLock then return end; getgenv().settings.webhookType = Option; saveSettings() end,
})
WebhookTab:CreateButton({
    Name = "Test Webhook",
    Callback = function()
        if getgenv().settings.webhookBox:gsub(" ","") ~= "" then
            oldWebhook("Rayfield Webhook Test: Hoạt động tốt!")
            Rayfield:Notify("Webhook", "Đã gửi tin nhắn test.", 3)
        else Rayfield:Notify("Lỗi", "Chưa nhập Webhook URL.", 3) end
    end,
})


-------------------- TAB: SERVER HOP --------------------
ServerHopTab:CreateSection("Auto Server Hop")
ServerHopTab:CreateToggle({
    Name = "Tự động Server Hop", CurrentValue = getgenv().settings.serverHopToggle,
    Callback = function(Value) if settingsLock then return end; getgenv().settings.serverHopToggle = Value; saveSettings(); hopSet() end,
})
ServerHopTab:CreateInput({
    Name = "Delay Server Hop (phút)", DefaultText = tostring(getgenv().settings.serverHopDelay), Numeric = true, Float = 0, Min = 1,
    Callback = function(Text)
        if settingsLock then return end; local n = tonumber(Text)
        if n and n >= 1 then getgenv().settings.serverHopDelay = n; saveSettings(); hopSet() end
    end,
})
ServerHopTab:CreateLabel("Timer Server Hop sẽ reset sau khi có donate.")

if vcEnabled then -- Chỉ hiển thị nếu Voice Chat được kích hoạt cho user
    ServerHopTab:CreateToggle({
        Name = "Ưu tiên Voice Chat Servers", CurrentValue = getgenv().settings.vcServer,
        Callback = function(Value) if settingsLock then return end; getgenv().settings.vcServer = Value; saveSettings() end,
    })
    ServerHopTab:CreateToggle({
        Name = "Ngẫu nhiên giữa Normal/Voice Server", CurrentValue = getgenv().settings.AlternativeHop,
        Callback = function(Value) if settingsLock then return end; getgenv().settings.AlternativeHop = Value; saveSettings() end,
    })
end

ServerHopTab:CreateToggle({
    Name = "Server Hop sau khi có Donate", CurrentValue = getgenv().settings.serverHopAfterDonation,
    Callback = function(Value) if settingsLock then return end; getgenv().settings.serverHopAfterDonation = Value; saveSettings() end,
})
ServerHopTab:CreateToggle({
    Name = "Server Hop nếu bạn bè vào server", CurrentValue = getgenv().settings.friendHop,
    Callback = function(Value) if settingsLock then return end; getgenv().settings.friendHop = Value; saveSettings() end,
})
ServerHopTab:CreateToggle({
    Name = "Server Hop nếu đạt mục tiêu Robux (Server Hop Goal)", CurrentValue = getgenv().settings.goalServerhopSwitch,
    Callback = function(Value) if settingsLock then return end; getgenv().settings.goalServerhopSwitch = Value; saveSettings() end,
})
ServerHopTab:CreateInput({
    Name = "Mục tiêu Robux để Server Hop", DefaultText = tostring(getgenv().settings.goalServerhopGoal), Numeric = true, Float = 0,
    Callback = function(Text)
        if settingsLock then return end; local n = tonumber(Text); if n then getgenv().settings.goalServerhopGoal = n; saveSettings() end
    end,
})
ServerHopTab:CreateToggle({
    Name = "[BETA] Anti Bot Servers", Tooltip = "Server hop nếu có quá nhiều booth text giống bot (>6).", CurrentValue = getgenv().settings.antiBotServers,
    Callback = function(Value)
        if settingsLock then return end; getgenv().settings.antiBotServers = Value; saveSettings()
        if Value then task.spawn(checkForBots) end -- checkForBots cần được copy từ script gốc
    end,
})
ServerHopTab:CreateInput({
    Name = "SH nếu tổng donate server < X Robux", Tooltip = "Server hop nếu tổng Raised của mọi người trên server (trừ bạn) thấp hơn giá trị này.", DefaultText = tostring(getgenv().settings.minimumDonated), Numeric = true, Float = 0,
    Callback = function(Text)
        if settingsLock then return end; local n = tonumber(Text); if n then getgenv().settings.minimumDonated = n; saveSettings() end
    end,
})
ServerHopTab:CreateButton({
    Name = "Server Hop Ngay!",
    Callback = function() if serverHop then serverHop() else Rayfield:Notify("Lỗi", "Chức năng serverHop chưa sẵn sàng.",3) end end,
})


-------------------- TAB: AUTO REPLY (AR) --------------------
ARTab:CreateSection("Auto Near Replies")
ARTab:CreateToggle({
    Name = "Tự động trả lời tin nhắn gần (AR)", CurrentValue = getgenv().settings.autoNearReply,
    Callback = function(Value) if settingsLock then return end; getgenv().settings.autoNearReply = Value; saveSettings() end,
})
ARTab:CreateToggle({
    Name = "[AR] Bỏ qua tin nhắn không nhận diện được", CurrentValue = getgenv().settings.autoReplyNoRespond,
    Callback = function(Value) if settingsLock then return end; getgenv().settings.autoReplyNoRespond = Value; saveSettings() end,
})

-- Helper function to handle AR message textboxes
local function CreateARMessageTextbox(tab, settingName, labelText, defaultTable)
    local currentText = table.concat(defaultTable, "\n")
    tab:CreateLabel(labelText .. " (mỗi dòng 1 tin nhắn):")
    return tab:CreateTextbox({
        Name = settingName .. "_Textbox", Text = currentText, PlaceholderText = "Nhập tin nhắn...",
        Callback = function(FullText)
            if settingsLock then return end
            local split = {}
            for line in string.gmatch(FullText, "[^\r\n]+") do table.insert(split, line) end
            getgenv().settings[settingName] = split; saveSettings()
            Rayfield:Notify("AR Saved", labelText .. " đã được cập nhật.", 2)
        end,
    })
end

CreateARMessageTextbox(ARTab, "helloResponce", "Trả lời cho 'Hello', 'Hi'", getgenv().settings.helloResponce)
CreateARMessageTextbox(ARTab, "botResponce", "Trả lời cho 'You are a bot'", getgenv().settings.botResponce)
CreateARMessageTextbox(ARTab, "donateResponce", "Trả lời cho 'pls donate'", getgenv().settings.donateResponce)
CreateARMessageTextbox(ARTab, "scamResponce", "Trả lời cho 'you are a scammer'", getgenv().settings.scamResponce)
CreateARMessageTextbox(ARTab, "otherResponce", "Trả lời cho các tin khác (nếu không bỏ qua)", getgenv().settings.otherResponce)
-- Nút Save Replies không còn cần thiết nếu các Textbox tự lưu


-------------------- TAB: SUPPORT --------------------
SupportTab:CreateLabel("Script này miễn phí nhưng tác giả không từ chối Robux :3")
SupportTab:CreateLabel("Nếu bạn muốn donate cho tác giả gốc (tzechco/CF-Trail):")
SupportTab:CreateButton({
    Name = "Teleport đến game Donate của tác giả",
    Callback = function()
        if TPService then TPService:Teleport(13461969417) -- ID từ script gốc
        else Rayfield:Notify("Lỗi", "TPService không khả dụng.", 3) end
    end,
})
SupportTab:CreateLabel("Bạn cũng có thể gửi tin nhắn cho họ ở đó miễn phí!")
SupportTab:CreateLabel("Rayfield UI conversion by szze (AI Assisted).")


-------------------- KẾT THÚC KHAI BÁO UI --------------------
settingsLock = false -- Cho phép các callback hoạt động
Rayfield:Notify("Hoàn Tất", "PLS DONATE Autofarm UI (Rayfield) đã sẵn sàng!", 7, Enum.RayfieldNotifyInfoType.Success)

-- ===== KHỞI CHẠY LOGIC BAN ĐẦU SAU KHI UI ĐÃ TẢI =====
task.spawn(function()
    if not _boothlocation then getBoothLocation() end -- Đảm bảo _boothlocation được set
    if not _boothlocation then
        Rayfield:Notify("Lỗi Khởi Tạo", "Không tìm thấy MapUI, không thể tự động claim booth ban đầu.", 5, Enum.RayfieldNotifyInfoType.Error)
        if getgenv().settings.serverHopToggle and serverHop then task.delay(5, serverHop) end
        return
    end

    local initialFindSuccess = pcall(findUnclaimed)
    if not initialFindSuccess then
        Rayfield:Notify("Lỗi Tìm Booth", "Lỗi khi tìm booth ban đầu, thử server hop.", 5)
        if getgenv().settings.serverHopToggle and serverHop then serverHop() end
        return
    end

    claimCount = #unclaimed
    if not unclaimed[2] then -- Logic gốc nhắm unclaimed[2]
        Rayfield:Notify("Không Có Booth", "Không đủ booth trống phù hợp để claim ban đầu (cần >= 2).", 5)
        if getgenv().settings.serverHopToggle and serverHop then serverHop() end
        return
    end
    
    errCount = 0 -- Reset errCount
    local claimAttempts = 0
    while not pcall(boothclaim) do
        claimAttempts = claimAttempts + 1
        if errCount >= claimCount or claimAttempts > (#unclaimed + 3) then -- Thêm giới hạn phòng lặp vô hạn
            Rayfield:Notify("Lỗi Claim Booth", "Không thể claim booth ban đầu sau nhiều lần thử. Server hopping...", 5)
            if getgenv().settings.serverHopToggle and serverHop then serverHop() end
            return
        end
        if #unclaimed > 0 then table.remove(unclaimed, 1) else break end -- Tránh lỗi nếu unclaimed rỗng
        errCount = errCount + 1
        task.wait(0.5)
    end

    hopSet() -- Khởi tạo timer server hop nếu được bật
    if bclaimed then -- Chỉ walk nếu đã claim thành công (bclaimed được set trong boothclaim)
        if walkToBooth then walkToBooth() end
    end
    
    if getgenv().settings.autoBeg and not spamming then -- Khởi tạo autoBeg nếu được bật
        spamming = task.spawn(begging)
    end
end)


-- ===== KẾT NỐI CÁC SỰ KIỆN GAME (GIỮ NGUYÊN TỪ SCRIPT GỐC) =====
-- (Ví dụ: Raised.Changed, PlayerChatted, PlayerAdded, CharacterRemoving, etc.)
-- Đảm bảo các hàm mà chúng gọi đã được copy và hoạt động.

if newRaisedFormat and newRaisedFormat.Changed then
    local RaisedC = newRaisedFormat.Value
    local djset = false
    local helidebounce = false
    local lapdebounce = false
    local sgoalR = 0 -- For server hop goal on donation

    newRaisedFormat.Changed:Connect(function()
        local playerWhoDonated
        local currentRaisedValue = newRaisedFormat.Value
        local raisedAmount = currentRaisedValue - RaisedC
        if raisedAmount <= 0 then RaisedC = currentRaisedValue; return end -- Không có donate thực sự hoặc lỗi số liệu

        sgoalR = sgoalR + raisedAmount
        hopSet() -- Reset server hop timer

        -- Spin effect
        if getgenv().settings.spinSet and Players.LocalPlayer.Character then
            local rootPart = Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            local spinInstance = rootPart and rootPart:FindFirstChild("Spin")
            if spinInstance and spinInstance:IsA("BodyAngularVelocity") then
                local sSM = getgenv().settings.spinSpeedMultiplier
                local currentAV = spinInstance.AngularVelocity
                -- Tăng tốc độ quay dựa trên số Robux donate
                local newSpinY = currentAV.Y + (raisedAmount * 0.1 * sSM) -- Điều chỉnh factor nếu cần
                spinInstance.AngularVelocity = Vector3.new(0, newSpinY, 0)
                xspin = newSpinY -- Cập nhật xspin để dùng nếu toggle lại spin
            end
        end
        
        -- Webhook
        if getgenv().settings.webhookToggle == true and getgenv().settings.webhookBox and httprequest then
            task.spawn(function()
                -- fetchNearPlr() cần được copy từ script gốc
                -- webhook() hoặc oldWebhook() cần được copy từ script gốc
            end)
        end

        -- Server hop after donation
        if getgenv().settings.serverHopAfterDonation == true then
            task.spawn(serverHop)
        end

        -- Jump Boost
        if getgenv().settings.jumpBoost and Players.LocalPlayer.Character then
            local humanoid = Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                pcall(function() humanoid.JumpPower = humanoid.JumpPower + raisedAmount end)
            end
        end
        -- Gravity Switch
        if getgenv().settings.gravitySwitch then
            pcall(function() workspace.Gravity = workspace.Gravity - raisedAmount end)
        end

        -- Helicopter (logic phức tạp, tham khảo script gốc)
        if getgenv().settings.helicopterEnabled and not getgenv().settings.highlightSwitch then
            -- ... (logic helicopter từ script gốc, gọi chat(), Players:Chat(), twn(), etc.) ...
            -- Cần hàm twn(...) từ script gốc: local function twn(...) return TweenService:Create(...) end
        end
        
        -- Donation Jump
        if getgenv().settings.donationJump == true and not getgenv().settings.spinSet == true and not getgenv().settings.highlightSwitch then
            if not djset then
                djset = true
                task.spawn(function()
                    local char = Players.LocalPlayer.Character
                    if not char then djset = false; return end
                    local hum = char:FindFirstChildOfClass("Humanoid")
                    if not hum then djset = false; return end
                    
                    local jumpsToDo = raisedAmount * getgenv().settings.jumpsPerRobux
                    for i = 1, jumpsToDo do
                        if hum.Health > 0 then
                            hum:ChangeState(Enum.HumanoidStateType.Jumping)
                            local landed = false
                            local landConn
                            landConn = hum.StateChanged:Connect(function(old, new)
                                if new == Enum.HumanoidStateType.Landed or new == Enum.HumanoidStateType.Running then
                                    landed = true
                                    if landConn then landConn:Disconnect() end
                                end
                            end)
                            repeat task.wait() until landed or hum.Health <= 0
                            if landConn and landed == false then landConn:Disconnect() end -- Dọn dẹp nếu không land được
                            if hum.Health <= 0 then break end -- Dừng nếu chết
                        else break
                        end
                    end
                    djset = false
                end)
            end
        end

        -- Robux Lap (logic phức tạp, tham khảo script gốc)
        if getgenv().settings.robuxLap and not lapdebounce then
            -- ... (logic robuxLap từ script gốc, gọi twn(), walkToBooth(), _CFRAMETABLE) ...
        end

        -- Highlight song
        if getgenv().settings.highlightSwitch and _HIGHLIGHTLOADER then
            task.spawn(function()
                 -- playerWhoDonated = fetchNearPlr() -- Cần hàm fetchNearPlr
                _HIGHLIGHTLOADER.HLStart(Players.LocalPlayer.Character, raisedAmount, nil) -- (playerWhoDonated or fetchNearPlr() or nil)
            end)
        end

        RaisedC = currentRaisedValue -- Cập nhật RaisedC CUỐI CÙNG

        -- Auto Thanks
        if getgenv().settings.autoThanks == true then
            task.spawn(function()
                task.wait(getgenv().settings.thanksDelay)
                chat(getgenv().settings.thanksMessage[math.random(#getgenv().settings.thanksMessage)])
            end)
        end
        
        -- Reset dance
        task.spawn(function()
            repeat task.wait() until djset == false -- Chờ jump xong
            task.wait(0.5)
            local char = Players.LocalPlayer.Character
            if char then
                local danceChoice = getgenv().settings.danceChoice
                if danceChoice == "Disabled" then Players:Chat("/e wave")
                elseif danceChoice == "1" then Players:Chat("/e dance")
                else Players:Chat(("/e dance%s"):format(danceChoice)) end
            end
        end)

        -- Server hop on goal
        if getgenv().settings.goalServerhopSwitch and sgoalR >= getgenv().settings.goalServerhopGoal then
            sgoalR = 0 -- Reset goal
            serverHop()
        end
        
        task.wait(getgenv().settings.textUpdateDelay) -- Delay trước khi update text
        updateBoothText()
    end)
end


if Players.LocalPlayer then
    Players.LocalPlayer.CharacterRemoving:Connect(function()
        if getgenv().settings.spinSet and not getgenv().settings.highlightSwitch then
            if serverHop then serverHop() end -- Có thể là server hop hoặc chỉ dừng spin
        end
        -- Hủy các BodyMovers nếu có khi nhân vật bị xóa
        local char = Players.LocalPlayer.Character
        if char then
            local root = char:FindFirstChild("HumanoidRootPart")
            if root then
                if root:FindFirstChild("Spin") then root.Spin:Destroy() end
                if root:FindFirstChild("HL1__HELI") then root.HL1__HELI:Destroy() end
            end
            if workspace:FindFirstChild("_HIGHLIGHT.CF") then workspace["_HIGHLIGHT.CF"]:Destroy() end
        end
    end)

    -- Check minimum donated on server (original logic)
    task.spawn(function()
        task.wait(15) -- Chờ một lúc để server ổn định
        local raisedValueOnServer = 0
        for _, p_other in ipairs(Players:GetPlayers()) do
            if p_other ~= Players.LocalPlayer and p_other:FindFirstChild('leaderstats') and p_other.leaderstats:FindFirstChild('Raised') then
                raisedValueOnServer = raisedValueOnServer + p_other.leaderstats.Raised.Value
            end
        end
        if raisedValueOnServer < getgenv().settings.minimumDonated and getgenv().settings.serverHopToggle then
            Rayfield:Notify("Server Info", "Tổng donate server thấp (<" .. getgenv().settings.minimumDonated .. "). Đang tìm server khác.", 5)
            serverHop()
        end
    end)

    -- Anti out of map / stuck (original logic)
    task.spawn(function()
        while task.wait(10) do -- Check mỗi 10 giây
            local char = Players.LocalPlayer.Character
            local root = char and char:FindFirstChild("HumanoidRootPart")
            if root then
                if (root.Position - positionX).Magnitude > 1100 or root.Position.Y < -200 then -- Thêm check Y < -200
                    Rayfield:Notify("Vị Trí", "Phát hiện vị trí bất thường. Đang thử server hop.", 5)
                    serverHop()
                end
            end
        end
    end)
    
    -- Webhook after server hop (original logic)
    -- Cần một cách để biết script vừa được load SAU KHI server hop. Biến getgenv() có thể không đủ.
    -- Phần này có thể khó tái tạo chính xác nếu không có cơ chế của executor.
    -- if getgenv().settings.webhookAfterSH and getgenv().justHopped then
    --     -- Gửi webhook
    --     getgenv().justHopped = false
    -- end
end


-- Auto Reply Logic (PlayerChatted, giữ nguyên từ gốc)
local messagesToResp = { -- copy from original
	['Greetings'] = {'hi','hello','hey','sup','yo','howdy','sup bro','sup dude','hai','hii','hey man','hiya','heyy','hello man','hello dude','hi bro','hi sup','hiey','👋','hey hello','sup hi'},
}
Players.PlayerChatted:Connect(function(chatMessage) -- API mới hơn
    if not getgenv().settings.autoNearReply then return end
    local speakerPlayer = chatMessage.Sender
    if not speakerPlayer or speakerPlayer == Players.LocalPlayer then return end

    local messageText = string.lower(chatMessage.Text)
    if string.find(messageText, 'donates') or string.find(messageText, "spamming") then return end

    if speakerPlayer:GetAttribute('respcd_rayfield') then return end
    speakerPlayer:SetAttribute('respcd_rayfield', true)

    task.delay(2.1 + math.random(), function() -- Dùng task.delay để không block
        local plrChatted = Players:FindFirstChild(speakerPlayer.Name) -- Re-fetch player just in case
        if not plrChatted or not plrChatted.Character or not plrChatted.Character:FindFirstChild("HumanoidRootPart") then
            speakerPlayer:SetAttribute('respcd_rayfield', nil)
            return
        end
        local localChar = Players.LocalPlayer.Character
        if not localChar or not localChar:FindFirstChild("HumanoidRootPart") then
             speakerPlayer:SetAttribute('respcd_rayfield', nil)
            return
        end

        local rootOther = plrChatted.Character.HumanoidRootPart
        local rootLocal = localChar.HumanoidRootPart
        
        if (rootOther.Position - rootLocal.Position).Magnitude < 15 then -- Tăng phạm vi một chút
            local replied = false
            if table.find(messagesToResp.Greetings, messageText) then
                chat(getgenv().settings.helloResponce[math.random(#getgenv().settings.helloResponce)])
                replied = true
            elseif string.find(messageText, 'bot') then
                chat(getgenv().settings.botResponce[math.random(#getgenv().settings.botResponce)])
                replied = true
            elseif string.find(messageText, 'donate') then
                chat(getgenv().settings.donateResponce[math.random(#getgenv().settings.donateResponce)])
                replied = true
            elseif string.find(messageText, 'scam') then
                chat(getgenv().settings.scamResponce[math.random(#getgenv().settings.scamResponce)])
                replied = true
            end

            if not replied and not getgenv().settings.autoReplyNoRespond then
                chat(getgenv().settings.otherResponce[math.random(#getgenv().settings.otherResponce)])
            end
        end
        task.wait(math.random(12,18))
        speakerPlayer:SetAttribute('respcd_rayfield', nil)
    end)
end)

-- Friend Hop Logic (PlayerAdded, giữ nguyên từ gốc)
Players.PlayerAdded:Connect(function(player)
	if getgenv().settings.friendHop and player:IsFriendsWith(uid) then
        Rayfield:Notify("Bạn Bè", player.Name .. " đã vào server! Đang tìm server khác.", 5)
	    task.delay(1, serverHop) -- Delay một chút để thông báo hiển thị
	end
end)
-- Check friends on current server
task.spawn(function()
    task.wait(5) -- Chờ player list ổn định
    for _,player_in_server in ipairs(Players:GetPlayers()) do
        if player_in_server ~= Players.LocalPlayer and getgenv().settings.friendHop and player_in_server:IsFriendsWith(uid) then
            Rayfield:Notify("Bạn Bè", player_in_server.Name .. " đang ở trong server! Đang tìm server khác.", 5)
            serverHop()
            break
        end
    end
end)


-- Main Server Hop Timer Loop (giữ nguyên)
task.spawn(function()
    while task.wait((getgenv().settings.serverHopDelay or 15) * 60) do -- Thêm or 15 để tránh lỗi nếu setting chưa load
        if getgenv().settings.serverHopToggle and not hopTimer then -- Kiểm tra hopTimer để tránh lặp nếu hopSet đã chạy
            hopSet()
        elseif getgenv().settings.serverHopToggle and hopTimer then
            -- Timer đang chạy, có thể log hoặc bỏ qua
        end
    end
end)

Rayfield:Notify("Thông Báo", "Script PLS DONATE (Rayfield) đã được tải và chạy.", 7)
print("Rayfield_CONV: Script PLS DONATE (Rayfield Conversion) loaded and running.")

-- Hàm dọn dẹp khi script bị unload (nếu executor hỗ trợ)
-- Ví dụ: game:GetService("Players").LocalPlayer. chùa.OnTeleport:Connect(function() Rayfield:Destroy() end)
-- Hoặc nếu Rayfield có hàm Unload
-- getgenv().RunningRayfieldScript = Window -- Để có thể Unload từ console: getgenv().RunningRayfieldScript:Destroy()
-- Hoặc: Rayfield:Unload() nếu có
