--[[
    Script tập trung vào: Tìm Booth -> Teleport -> Claim
    Dựa trên script đầy đủ bạn đã cung cấp.
]]

repeat
    task.wait()
until game:IsLoaded()

-- Stops script if on a different game
if game.PlaceId ~= 8737602449 and game.PlaceId ~= 8943844393 then
    warn("Script không dành cho game này. PlaceID:", game.PlaceId)
    return
end

local identifyexecutor = identifyexecutor or function() return 'Unknown' end
local cloneref = (identifyexecutor() ~= "Synapse Z" and not identifyexecutor():find("Codex") and cloneref) or function(o) return o end
local CoreGui = cloneref(game:GetService("CoreGui"))
local Players = cloneref(game:GetService("Players"))
local HttpService = cloneref(game:GetService("HttpService"))
local TPService = cloneref(game:GetService("TeleportService"))
local ReplicatedStorage = cloneref(game:GetService("ReplicatedStorage"))
if not workspace then
    workspace = game:GetService('Workspace')
end
local Remotes

-- Tìm Remotes Module
print("Đang tìm kiếm Remotes module...")
for i, v in next, ReplicatedStorage:GetChildren() do
    if v.Name:find('Remote') and v:IsA('ModuleScript') then -- Kiểm tra IsA đúng cách
        local remoteModule
        local successRequire = pcall(function() remoteModule = require(v) end)
        if successRequire and typeof(remoteModule) == "table" and remoteModule.Event then
            -- Thử một event vô hại hơn nếu có, hoặc chỉ kiểm tra sự tồn tại của .Event
            local sucEventTest = pcall(function()
                -- Thay vì FireServer một event có thể có tác động,
                -- chúng ta chỉ cần xác nhận module có cấu trúc mong đợi.
                -- Nếu bạn biết một event "an toàn" để test, có thể dùng nó.
                -- Hoặc, nếu việc require thành công và có hàm Event là đủ, thì không cần FireServer ở đây.
                -- Ví dụ: chỉ cần remoteModule.Event("Test") mà không FireServer.
                -- Để an toàn, chúng ta có thể bỏ qua việc FireServer ở bước tìm kiếm này.
                -- require(v).Event('PromotionBlimpGiftbux'):FireServer() -- Dòng gốc có thể gây tác dụng phụ
            end)
            -- if sucEventTest then -- Dòng gốc dùng sucEventTest
            Remotes = remoteModule
            print("Đã tìm thấy Remotes module:", v.Name)
            break
            -- end
        end
    end
    task.wait()
end

if not Remotes then
    warn("Không tìm thấy Remotes module! Script không thể tiếp tục.")
    return
end

-- Xác định _boothlocation
local _shuffled = workspace:WaitForChild('MapUI', 3)
local _shufflerandom = 0
if not _shuffled then
    _shufflerandom = 1
end
local _boothlocation
if _shufflerandom == 1 then
    local successPcall = pcall(function()
        _boothlocation = Players.LocalPlayer:WaitForChild('PlayerGui', 5):WaitForChild('MapUIContainer', 5):WaitForChild('MapUI', 5)
    end)
    if not successPcall then
        warn("Lỗi khi tìm _boothlocation trong PlayerGui.")
    end
else
    _boothlocation = _shuffled or workspace:WaitForChild('MapUI')
end

if not _boothlocation then
    warn("Không tìm thấy _boothlocation! Script không thể tiếp tục.")
    -- serverHop() -- Bạn có thể gọi serverHop ở đây nếu muốn
    return
end
print("_boothlocation được xác định là:", _boothlocation:GetFullName())

-- Các biến cần thiết khác
local unclaimed = {}
local mainCheckPosition = Vector3.new(165.161, 0, 311.636)
local LocalPlayer = Players.LocalPlayer

-- Hàm serverHop (từ script gốc, có thể cần điều chỉnh nếu httprequest không hoạt động như mong đợi)
local httprequest = (syn and syn.request) or http and http.request or http_request or (fluxus and fluxus.request) or request

local function serverHop()
    print("Đang thực hiện serverHop...")
    local serverst = {}
    local placeId = 8737602449 -- Mặc định, có thể điều chỉnh nếu cần
    -- local placeId = choosePlaceId() -- choosePlaceId từ script gốc dựa vào settings, ở đây ta dùng mặc định

    local cursor = nil
    local attempts = 0
    local maxAttempts = 5 -- Giới hạn số lần thử fetch server list

    repeat
        attempts = attempts + 1
        if attempts > maxAttempts then
            warn("Đã đạt tối đa số lần thử fetch server list.")
            break
        end

        local url = ("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Asc&limit=100%s")
            :format(placeId, cursor and "&cursor=" .. cursor or "")

        local response
        local successHttp, resultHttp = pcall(function()
            response = httprequest({ Url = url, Method = "GET" })
        end)

        if not successHttp or not response or response.StatusCode ~= 200 then
            warn("Thất bại khi lấy danh sách server:", response and response.StatusMessage or resultHttp or "Không có phản hồi")
            task.wait(2) -- Chờ trước khi thử lại
            cursor = nil -- Reset cursor để thử lại từ đầu trang nếu cần
            goto continue_loop -- Nhảy đến cuối vòng lặp để thử lại
        end

        local data
        local successDecode, resultDecode = pcall(function()
            data = HttpService:JSONDecode(response.Body)
        end)

        if not successDecode then
            warn("Lỗi JSONDecode:", resultDecode)
            cursor = nil
            goto continue_loop
        end
        
        cursor = data.nextPageCursor

        if data and data.data then
            for _, server in ipairs(data.data) do
                if server.playing < server.maxPlayers and server.playing > 11 then -- Điều kiện từ script gốc
                    table.insert(serverst, server.id)
                end
                if #serverst > 5 then break end -- Lấy một vài server để thử
            end
        end
        
        if #serverst > 0 then break end -- Thoát nếu đã có server
        
        ::continue_loop::
        task.wait(0.5)
    until not cursor or #serverst > 0

    if #serverst > 0 then
        local targetServerId = serverst[math.random(1, #serverst)]
        print("Đang dịch chuyển đến server:", targetServerId)
        pcall(TPService.TeleportToPlaceInstance, TPService, placeId, targetServerId, LocalPlayer)
    else
        warn("Không tìm thấy server phù hợp để hop.")
    end
end


-- HÀM TÌM GIAN HÀNG CHƯA CÓ NGƯỜI (từ script gốc)
local function findUnclaimed()
    unclaimed = {} -- Reset
    local boothUIFolder = _boothlocation:WaitForChild("BoothUI", 10)
    local interactionsFolder = workspace:WaitForChild("BoothInteractions", 10)

    if not boothUIFolder then warn("Không tìm thấy BoothUI trong _boothlocation"); return end
    if not interactionsFolder then warn("Không tìm thấy BoothInteractions trong workspace"); return end

    local mainPos2D = Vector3.new(mainCheckPosition.X, 0, mainCheckPosition.Z)

    print("Đang tìm kiếm gian hàng chưa có người...")
    for _, uiFrame in ipairs(boothUIFolder:GetChildren()) do
        if uiFrame:IsA("Frame") and uiFrame:FindFirstChild("Details") and uiFrame.Details:FindFirstChild("Owner") and uiFrame.Details.Owner:IsA("TextLabel") then
            if uiFrame.Details.Owner.Text == "unclaimed" then
                local boothNumMatch = uiFrame.Name:match("%d+")
                if boothNumMatch then
                    local boothNum = tonumber(boothNumMatch)
                    if boothNum then
                        for _, interactPart in ipairs(interactionsFolder:GetChildren()) do
                            if interactPart:IsA("BasePart") and interactPart:GetAttribute("BoothSlot") == boothNum then
                                local pos2D = Vector3.new(interactPart.Position.X, 0, interactPart.Position.Z)
                                if (pos2D - mainPos2D).Magnitude < 92 then
                                    table.insert(unclaimed, boothNum)
                                    print("Tìm thấy gian hàng chưa có người số " .. boothNum .. " trong phạm vi.")
                                    break
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    if #unclaimed == 0 then
        print("Không tìm thấy gian hàng nào chưa có người trong phạm vi.")
    else
        print("Danh sách gian hàng chưa có người đã tìm thấy: ", table.concat(unclaimed, ", "))
    end
end

-- HÀM CHÍNH: TÌM, TELEPORT VÀ CLAIM
local function findTeleportAndClaim()
    local successFind, errFind = pcall(findUnclaimed)
    if not successFind then
        warn("Lỗi khi chạy findUnclaimed:", errFind)
        return
    end

    if #unclaimed == 0 then
        print("Không có gian hàng nào để thử. Kết thúc hoặc thử serverHop.")
        -- serverHop() -- Tùy chọn: tự động hop nếu không tìm thấy
        return
    end

    -- Ưu tiên gian hàng đầu tiên tìm được cho sự đơn giản
    local targetBoothNum = unclaimed[1]
    print("Mục tiêu là gian hàng số: " .. targetBoothNum)

    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local rootPart = character:WaitForChild("HumanoidRootPart", 5)
    if not rootPart then
        warn("Không tìm thấy HumanoidRootPart.")
        return
    end

    -- Lấy CFrame của điểm tương tác gian hàng
    local interactionsFolder = workspace:WaitForChild("BoothInteractions", 5)
    if not interactionsFolder then warn("Không tìm thấy interactionsFolder"); return end
    local targetBoothInteractionCFrame
    for _, interactPartCandidate in ipairs(interactionsFolder:GetChildren()) do
        if interactPartCandidate:IsA("BasePart") and interactPartCandidate:GetAttribute("BoothSlot") == targetBoothNum then
            targetBoothInteractionCFrame = interactPartCandidate.CFrame
            print("Đã tìm thấy CFrame của điểm tương tác cho gian hàng " .. targetBoothNum .. " tại vị trí: " .. tostring(targetBoothInteractionCFrame.Position))
            break
        end
    end

    if not targetBoothInteractionCFrame then
        warn("Không tìm thấy CFrame của điểm tương tác cho gian hàng: " .. targetBoothNum)
        return
    end

    -- Thực hiện Teleport
    print("Đang dịch chuyển đến gian hàng " .. targetBoothNum .. "...")
    rootPart.CFrame = targetBoothInteractionCFrame
    task.wait(0.5) -- Đợi một chút để việc dịch chuyển ổn định

    -- Thực hiện Claim
    print("Đang thử chiếm gian hàng " .. targetBoothNum .. " sau khi teleport.")
    local claimAttemptSuccess, claimResult = pcall(function()
        return Remotes.Event("ClaimBooth"):InvokeServer(targetBoothNum)
    end)

    if not claimAttemptSuccess then
        warn("Lỗi khi gọi InvokeServer để chiếm gian hàng: " .. tostring(claimResult))
        return
    end
    
    task.wait(0.5) -- Đợi server cập nhật UI

    -- Kiểm tra lại chủ sở hữu trên UI
    local boothUIFolder = _boothlocation:WaitForChild("BoothUI", 5)
    if not boothUIFolder then warn("Không tìm thấy boothUIFolder để xác nhận claim"); return end

    local ownerTextUI = boothUIFolder:FindFirstChild("BoothUI" .. tostring(targetBoothNum))
    if ownerTextUI and ownerTextUI:FindFirstChild("Details") and ownerTextUI.Details:FindFirstChild("Owner") and ownerTextUI.Details.Owner:IsA("TextLabel") then
        if string.find(ownerTextUI.Details.Owner.Text, LocalPlayer.DisplayName) then
            print("ĐÃ CHIẾM THÀNH CÔNG GIAN HÀNG " .. targetBoothNum .. "!")
            -- Các hành động khác sau khi thành công (ví dụ: hopSet() nếu bạn giữ lại hàm đó)
        else
            print("CHIẾM GIAN HÀNG " .. targetBoothNum .. " THẤT BẠI (Xác nhận chủ sở hữu không đúng: '" .. ownerTextUI.Details.Owner.Text .. "').")
        end
    else
        warn("Không tìm thấy UI để xác nhận quyền sở hữu cho gian hàng " .. targetBoothNum .. " sau khi claim.")
    end
end

-- CHẠY SCRIPT
print("Bắt đầu script (phiên bản tập trung)...")
findTeleportAndClaim()
print("Script (phiên bản tập trung) đã hoàn tất một lượt chạy.")

-- Bạn có thể đặt findTeleportAndClaim() trong một vòng lặp nếu muốn nó chạy liên tục
-- Ví dụ:
-- while task.wait(60) do -- Chạy mỗi 60 giây
--    findTeleportAndClaim()
-- end
