local SETTINGS = {
    -- =================================================================
    -- C√ÄI ƒê·∫∂T N√â NG∆Ø·ªúI CH∆†I
    -- =================================================================
    ["EnableAvoidPlayers"] = true,
    ["AVOID_PLAYERS"] = {
        "HelloPlayer1st", "Lychkinsama", "Er1kaThe", "FusionViperBlizzard2",
        "Xx_AbigailPixelFr0st", "PrismCraz3Dark2022", "Thunder_Vortex67",
        "WilliamDawnOrbitYT", "FrostNeonBuilder2014", "XX_BaconFlashInf3rno",
        "Abigail_Duck35", "Jax0n_Danc3r2006", "XxTurboDancerCookiex",
        "AquaByt3Pho3nix2002", "XxJackHawkHer0xX", "JacksonEpicAce2003",
        "ToxicGigaMoon29", "FlickQueen2008_YT", "XXHYP3R_FoxxX2017",
        "Victoria_Cyb3r12", "Zer0N0vaFusi0n", "RiftRider2024_YT",
        "ViperPulse85", "ZoeSkaterBuilder2021", "Z0eM00n87",
        "Inf3rnoStarPanda46", "XxJulian_PixelxX54", "SkaterSonic200348",
        "P0wer_WRAITH85", "XxVictoriaFrostChase", "XxGraceStealthT0xicx",
        "Shad0wHunt3rByt3", "XxLucas_DARKXX201736", "AquaBane43"
    },

    -- =================================================================
    -- C√ÄI ƒê·∫∂T CH·ªêNG BOT
    -- =================================================================
    ["EnableAntiBotScan"] = true,
    ["BOT_KEYWORDS"] = { "spin", "afk", "restaurant", "jump", "gift", "speed", "develop", "streaming", "live", "game", "#", "dream", "first", "mom", "big" },
    ["DETECTION_THRESHOLD"] = 4,

    -- =================================================================
    -- C√ÄI ƒê·∫∂T SERVER HOP & AFK
    -- =================================================================
    ["WaitMinutes"] = 10,
    ["MaxServerHistorySize"] = 500,
    ["EnableFileHistory"] = true,
    ["MinPlayerThreshold"] = 14,
    ["MinPlayerPercentage"] = 0.4,
    ["MaxPlayerPercentage"] = 0.9,
    ["EnableServerHop"] = true,
    ["EnableSafePlatform"] = true,
    ["EnableStaticAfkView"] = true,
    ["EnableDonateReset"] = true,
    
    -- C√†i ƒë·∫∑t th·ªùi gian cho Search Logic m·ªõi
    ["baseRetryDelay"] = 3,
    ["maxRetryDelay"] = 30,
    ["waitTimeBetweenPageFetches"] = 0.5,
    ["waitTimeBetweenFullScans"] = 10,

    -- =================================================================
    -- C√ÄI ƒê·∫∂T TH√îNG B√ÅO DISCORD
    -- =================================================================
    ["EnableDiscordWebhook"] = true,
    ["WebhookURL"] = "https://discord.com/api/webhooks/1397368466947969147/HbncMuT0ETe6_5q_kKGzkdd7guLfiGqvewr3WuBFfHAxKBJo3TA7R6ad2ex31YkBHo75",
    ["WebhookColor"] = 16738740,
    ["EnablePingOnDonate"] = true,
    ["PingAmount"] = 1000,
    ["PingUserID"] = "",

    -- =================================================================
    -- C√ÄI ƒê·∫∂T T·ª∞ ƒê·ªòNG TR·∫¢ L·ªúI & CHAT
    -- =================================================================
    ["EnableAutoReply"] = true,
    ["ReplyRadius"] = 25,
    ["ReplyCooldown"] = 7,
    ["ReplyRules"] = {
        { keywords = { "hi", "hello", "hey", "sup", "yo", "wsg", "howdy", "greetings", "wassup", "heya" }, replies = { "Hello!", "Hi there", "Hey!", "Yo", "What's up?", "Heya", "Sup", "Heyo!", "What's good?", "Well hello there." } },
        { keywords = { "only","donate", "pls", "give me", "robux pls", "can i have", "spare", "some robux", "can u donate", "plz donate", "can you give", "i need robux" }, replies = { "Sorry, I'm saving up right now.", "I can't donate at the moment, sorry.", "My robux is pending, can't help sorry.", "Sry, saving for something specific.", "Maybe later, I'm trying to reach my own goal.", "Can't right now, good luck though!", "All my robux is tied up, sorry.", "Sorry, my wallet is on a diet.", "I wish I could, but I'm broke lol." } },
        { keywords = { "bot", "auto", "script", "scripter", "macro", "afk farm", "autoclicker", "you a bot?" }, replies = { "I'm not a bot :)", "lol no, I'm a real player.", "Just vibing, not a bot.", "Beep boop? Nah, just kidding.", "I'm a human, I promise!", "Not a script, just dedicated lol.", "Do I look like a bot to you? :P", "Last time I checked, I still need to sleep. So, not a bot.", "01001110 01101111. (That means 'No' in binary)." } },
        { keywords = { "scam", "fake", "report", "scammer", "this is a scam", "don't trust", "he's a scammer", "is this fake" }, replies = { "This is not a scam.", "I'm not a scammer.", "It's legit, no worries.", "100% legit, my friend.", "No scams here, just good vibes.", "I'm just here to play the game like you.", "Why would you think it's a scam?", "The only thing I'm scamming is time, by playing this game.", "You've got the wrong person, I'm just here to chill." } },
        { keywords = { "why are you", "how are you", "spinning", "jumping", "afk" }, replies = { "Just farming for my goal.", "It's part of the grind.", "Doing this for donations." } },
    },

    ["EnableAutoThank"] = true,
    ["ThankYouMessages"] = { "Thanks for the donation!", "Tysm!!", "Thank you so much!", "OMG THANKKK!", "THANKS", "TYSM!" },

    ["EnableAutoSpam"] = true,
    ["SpamInterval"] = 60,
    ["SpamMessages"] = { "Goal: MAX SPIN LEVEL 100üåÄ - 1 ROBUX = +1 SPEED!", "Goal: MAX SPIN LEVEL 100üåÄ - 1 ROBUX = +1 SPEED!" },

    -- =================================================================
    -- C√ÄI ƒê·∫∂T BOOTH & SPIN
    -- =================================================================
    ["EnableBoothFeatures"] = true,
    ["boothTextFormat"] = "1 DONATE = 1 SPIN SPEED\nGOAL: $GOALK SPEED!",
    ["hexBox"] = "#ffffff",
    ["fontFace"] = "SciFi",
    ["boothOffset"] = 3,
    ["spinEnabled"] = true,
    ["spinBaseSpeed"] = 0.4,
    ["spinSpeedPerR"] = 0.1,

    -- =================================================================
    -- C√ÄI ƒê·∫∂T HI·ªÜU NƒÇNG & KH√ÅC
    -- =================================================================
    ["EnableGraphicsOptimization"] = true,
    ["EnableCpuOptimization"] = true,
    ["SetSimulationRadiusToZero"] = true,
    ["TargetFps"] = 7,
    ["InitialWaitTime"] = 1,
    ["EnableCountdownText"] = true,
    ["EnableCountdownColor"] = true,
}

-- --- N·ªÅn t·∫£ng an to√†n ---
local identifyexecutor = identifyexecutor or function() return 'Unknown' end
local cloneref = (identifyexecutor() ~= "Synapse Z" and not identifyexecutor():find("Codex") and cloneref) or function(o) return o end

-- Services
local Players = cloneref(game:GetService("Players"))
local TeleportService = cloneref(game:GetService("TeleportService"))
local HttpService = cloneref(game:GetService("HttpService"))
local TextChatService = cloneref(game:GetService("TextChatService"))
local Workspace = cloneref(game:GetService("Workspace"))
local Lighting = cloneref(game:GetService("Lighting"))
local SoundService = cloneref(game:GetService("SoundService"))
local RunService = cloneref(game:GetService("RunService"))
local ReplicatedStorage = cloneref(game:GetService("ReplicatedStorage"))
local LocalPlayer = Players.LocalPlayer

-- C·∫•u h√¨nh n·ªôi b·ªô
local placeId = game.PlaceId; local currentJobId = game.JobId; local PLATFORM_VERTICAL_OFFSET = 0; local SERVER_HISTORY_FILENAME = "server_hop_history.txt";
local SERVER_HOP_GUI_NAME = "ServerHopStatusGUI"; local AFK_PLATFORM_NAME = "MySafeAFKPlatform"; local NEON_COLORS = { GREEN = Color3.fromRGB(10, 255, 20), YELLOW = Color3.fromRGB(255, 255, 0), BLUE = Color3.fromRGB(0, 150, 255), RED = Color3.fromRGB(255, 20, 20) }

local statusScreenGui, statusTextLabel, statusFrame
local countdownShouldReset = false; local currentCountdownThread = nil; local playerMonitorThread = nil
local Remotes = nil; local spinVelocity = SETTINGS.spinBaseSpeed or 0.25
local serverHistoryCache = {}

-- Bi·∫øn h·ªó tr·ª£ logic t√¨m server m·ªõi
local baseRetryDelay = SETTINGS.baseRetryDelay
local maxRetryDelay = SETTINGS.maxRetryDelay
local waitTimeBetweenPageFetches = SETTINGS.waitTimeBetweenPageFetches
local waitTimeBetweenFullScans = SETTINGS.waitTimeBetweenFullScans

-- =================================================================
-- H·ªÜ TH·ªêNG GIAO DI·ªÜN
-- =================================================================
local function createStatusGui()
    if LocalPlayer.PlayerGui:FindFirstChild(SERVER_HOP_GUI_NAME) then LocalPlayer.PlayerGui[SERVER_HOP_GUI_NAME]:Destroy() end
    statusScreenGui = Instance.new("ScreenGui", LocalPlayer.PlayerGui); statusScreenGui.Name = SERVER_HOP_GUI_NAME; statusScreenGui.ResetOnSpawn = false; statusScreenGui.IgnoreGuiInset = true;
    statusFrame = Instance.new("Frame", statusScreenGui); statusFrame.Size = UDim2.new(1, 0, 1, 0); statusFrame.BackgroundColor3 = NEON_COLORS.GREEN; statusFrame.BackgroundTransparency = 1; statusFrame.BorderSizePixel = 0;
    statusTextLabel = Instance.new("TextLabel", statusScreenGui); statusTextLabel.Size = UDim2.new(0.9, 0, 0, 130); statusTextLabel.Position = UDim2.new(0.5, 0, 0.5, 0); statusTextLabel.AnchorPoint = Vector2.new(0.5, 0.5); statusTextLabel.BackgroundTransparency = 1; statusTextLabel.TextColor3 = Color3.new(1, 1, 1); statusTextLabel.Font = Enum.Font.SourceSansSemibold; statusTextLabel.TextSize = 35; statusTextLabel.TextWrapped = true; statusTextLabel.Text = "...";
end

local function updateDisplay(state, message)
    task.spawn(function()
        print("[UI] " .. tostring(message))
        if not statusTextLabel or not statusTextLabel.Parent then return end
        local stateColor = NEON_COLORS.GREEN
        if state == "ERROR" then stateColor = NEON_COLORS.YELLOW elseif state == "BOT_DETECTED" then stateColor = NEON_COLORS.RED end
        statusTextLabel.Text = tostring(message); statusTextLabel.TextColor3 = stateColor
        if SETTINGS.EnableCountdownColor and statusFrame then
            if state == "SUCCESS" or state == "ERROR" or state == "BOT_DETECTED" then statusFrame.BackgroundColor3 = stateColor; statusFrame.BackgroundTransparency = 0.5 else statusFrame.BackgroundTransparency = 1 end
        end
    end)
end

-- =================================================================
-- QU·∫¢N L√ù L·ªäCH S·ª¨ FILE
-- =================================================================
local function loadServerHistory()
    if not SETTINGS.EnableFileHistory then serverHistoryCache = {} return end
    serverHistoryCache = {}
    pcall(function()
        if isfile(SERVER_HISTORY_FILENAME) then
            local content = readfile(SERVER_HISTORY_FILENAME)
            local count = 0
            for id in string.gmatch(content, "[^%s]+") do
                serverHistoryCache[id] = true
                count = count + 1
            end
            if count >= SETTINGS.MaxServerHistorySize then
                serverHistoryCache = {}
                writefile(SERVER_HISTORY_FILENAME, "")
            end
        end
    end)
end

local function addJobIdToHistoryAndSave(id)
    serverHistoryCache[id] = true
    if not SETTINGS.EnableFileHistory then return end
    pcall(function()
        local ids = {}
        for k in pairs(serverHistoryCache) do table.insert(ids, k) end
        writefile(SERVER_HISTORY_FILENAME, table.concat(ids, "\n"))
    end)
end

-- =================================================================
-- LOGIC T√åM SERVER (Y NGUY√äN T·ª™ B·∫†N)
-- =================================================================
local chosenServer = nil; local serversUrlBase = "https://games.roblox.com/v1/games/" .. placeId .. "/servers/Public?sortOrder=Asc&limit=100"

function searchForServer()
    if not SETTINGS.EnableFileHistory then serverHistoryCache = {} else loadServerHistory() end;
    local histC = 0; for _ in pairs(serverHistoryCache) do histC = histC + 1 end;
    updateDisplay("INFO", string.format("B·∫Øt ƒë·∫ßu t√¨m server... (Tr√°nh %d)", histC + 1));
    local sLActive = true;
    chosenServer = nil;
    while sLActive and not chosenServer do
        local nextCur = nil;
        updateDisplay("INFO", "ƒêang qu√©t server...");
        local allScanned = false;
        while not allScanned and not chosenServer do
            local pAtt = 0;
            local maxAtt = 4;
            local pFetched = false;
            local curRetry = baseRetryDelay;
            while not pFetched and pAtt < maxAtt do
                pAtt = pAtt + 1;
                if pAtt > 1 then
                    updateDisplay("INFO", string.format("Th·ª≠ l·∫°i (%d/%d)...", pAtt, maxAtt));
                    task.wait(curRetry);
                    curRetry = math.min(curRetry * 2, maxRetryDelay)
                end;
                
                local headers = {
                    ["User-Agent"] = "Roblox/WinInet",
                    ["Referer"] = "https://www.roblox.com/games/" .. placeId .. "/",
                    ["Origin"] = "https://www.roblox.com"
                }
                local req = (syn and syn.request) or (http and http.request) or (fluxus and fluxus.request) or request
                local s, response = pcall(function()
                    return req({
                        Url = serversUrlBase .. (nextCur and "&cursor=" .. nextCur or ""),
                        Method = "GET",
                        Headers = headers
                    })
                end)
                local d = (s and response) and response.Body or nil

                if s and d then
                    pFetched = true;
                    local sListD = HttpService:JSONDecode(d);
                    if sListD and sListD.data then
                        local pSuitS = {};
                        for _, sInf in ipairs(sListD.data) do
                            if not (sInf.id == currentJobId or serverHistoryCache[sInf.id]) then
                                if sInf.playing and sInf.maxPlayers and sInf.maxPlayers > 0 then
                                    local pR = sInf.playing / sInf.maxPlayers
                                    if pR >= SETTINGS.MinPlayerPercentage and pR < SETTINGS.MaxPlayerPercentage and sInf.playing < sInf.maxPlayers then
                                        table.insert(pSuitS, sInf)
                                    end
                                end
                            end
                        end;
                        
                        if #pSuitS > 0 then
                            for i = #pSuitS, 2, -1 do
                                local j = math.random(i)
                                pSuitS[i], pSuitS[j] = pSuitS[j], pSuitS[i]
                            end

                            for _, candidateServer in ipairs(pSuitS) do
                                loadServerHistory() 
                                if not serverHistoryCache[candidateServer.id] then
                                    updateDisplay("INFO", "Ki·ªÉm tra l·∫ßn cu·ªëi OK. ƒê√£ ch·ªçn server!")
                                    chosenServer = candidateServer
                                    addJobIdToHistoryAndSave(chosenServer.id)
                                    allScanned = true 
                                    break 
                                end
                            end
                            if chosenServer then
                                break 
                            end
                        end

                        nextCur = sListD.nextPageCursor;
                        if not nextCur then
                            allScanned = true;
                        end
                    else
                        updateDisplay("ERROR", "D·ªØ li·ªáu server l·ªói.")
                    end
                else
                    updateDisplay("ERROR", "L·ªói API.");
                    if pAtt >= maxAtt then
                        allScanned = true
                    end
                end
            end;
            if chosenServer or allScanned then break end;
            task.wait(waitTimeBetweenPageFetches)
        end;
        if chosenServer then
            updateDisplay("SUCCESS", "ƒê√É CH·ªåN SERVER!");
            sLActive = false
        elseif allScanned then
            updateDisplay("INFO", string.format("Kh√¥ng t√¨m th·∫•y. Ch·ªù %ds.", waitTimeBetweenFullScans));
            task.wait(waitTimeBetweenFullScans)
        end
    end;
    if chosenServer then
        updateDisplay("SUCCESS", "Chu·∫©n b·ªã d·ªãch chuy·ªÉn...");
        addJobIdToHistoryAndSave(currentJobId);
        task.wait(1);
        local sTP, eTP = pcall(function() TeleportService:TeleportToPlaceInstance(placeId, chosenServer.id, LocalPlayer) end);
        if not sTP then
            updateDisplay("ERROR", "L·ªói d·ªãch chuy·ªÉn! Server ƒë√£ ƒë∆∞·ª£c l∆∞u, s·∫Ω t√¨m server kh√°c...");
            chosenServer = nil;
            task.wait(5);
            searchForServer()
        end
    else
        updateDisplay("ERROR", "Kh√¥ng th·ªÉ t√¨m th·∫•y server. D·ª´ng l·∫°i.")
    end
end

-- =================================================================
-- C√ÅC H√ÄM T·ªêI ∆ØU H√ìA & TI·ªÜN √çCH
-- =================================================================
local function createSafePlatform()
    if Workspace:FindFirstChild(AFK_PLATFORM_NAME) then return end
    local p = Instance.new("Part", Workspace); p.Name = AFK_PLATFORM_NAME; p.Anchored = true; p.Size = Vector3.new(20000, 40, 20000); p.Color = Color3.fromRGB(50, 50, 50);
    local char = LocalPlayer.Character; local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if hrp then p.Position = Vector3.new(hrp.Position.X, hrp.Position.Y - 20, hrp.Position.Z) else p.Position = Vector3.new(0, -50, 0) end
end

local function setupFacialCameraAndFreeze()
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local root = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    if char:FindFirstChild("Animate") then char.Animate.Disabled = true end
    hum.AutoRotate = false
    local camera = Workspace.CurrentCamera; camera.CameraType = Enum.CameraType.Scriptable
    RunService.RenderStepped:Connect(function()
        if root and hum.Health > 0 then
            local look = root.CFrame.LookVector
            local targetPos = root.Position + Vector3.new(0, 2, 0)
            camera.CFrame = CFrame.new(targetPos + look * 6, targetPos)
        end
    end)
end

local function optimizeForCpu()
    if not SETTINGS.EnableCpuOptimization then return end
    pcall(function()
        if SETTINGS.SetSimulationRadiusToZero then LocalPlayer.SimulationRadius = 0 end
    end)
end

local function optimizeGraphics()
    if not SETTINGS.EnableGraphicsOptimization then return end
    pcall(function()
        Lighting.GlobalShadows = false; Lighting.Brightness = 0; Lighting.ExposureCompensation = -2;
        for _, v in pairs(game.Workspace:GetChildren()) do
            if not (v:IsA("Camera") or (LocalPlayer.Character and v.Name == LocalPlayer.Character.Name) or v.Name == AFK_PLATFORM_NAME) then
                pcall(function() v:Destroy() end)
            end
        end
        local s = settings(); if s and s.Rendering then s.Rendering.QualityLevel = Enum.QualityLevel.Level01 end
        pcall(function() RunService:Set3dRenderingEnabled(false) end)
    end)
end

-- =================================================================
-- H·ªÜ TH·ªêNG BOOTH & SPIN
-- =================================================================
local function findRemotes()
    if Remotes then return true end
    for _, v in next, ReplicatedStorage:GetChildren() do
        if v:IsA("ModuleScript") and v.Name:find("Remote") then
            local ok = pcall(function() require(v).Event("PromotionBlimpGiftbux"):FireServer() end)
            if ok then Remotes = require(v); return true end
        end
    end
    return false
end

local function updateBoothText()
    if not SETTINGS.EnableBoothFeatures or not Remotes then return end
    local raised = LocalPlayer:FindFirstChild("leaderstats") and LocalPlayer.leaderstats:FindFirstChild("Raised")
    if not raised then return end
    local goal = math.floor(raised.Value / 1000) + 1
    local text = SETTINGS.boothTextFormat:gsub("%$GOAL", tostring(goal))
    Remotes.Event("SetCustomization"):FireServer({
        text = text, textFont = Enum.Font[SETTINGS.fontFace], richText = true, textColor = Color3.fromHex(SETTINGS.hexBox)
    }, "booth")
end

local function updateSpinSpeed()
    local spin = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character.HumanoidRootPart:FindFirstChild("Spin")
    if spin then spin.AngularVelocity = Vector3.new(0, spinVelocity, 0) end
end

local function startSpin()
    if not SETTINGS.spinEnabled then return end
    local root = LocalPlayer.Character and LocalPlayer.Character:WaitForChild("HumanoidRootPart")
    if not root then return end
    if root:FindFirstChild("Spin") then root.Spin:Destroy() end
    local spin = Instance.new("BodyAngularVelocity", root); spin.Name = "Spin"; spin.MaxTorque = Vector3.new(0, math.huge, 0); spin.AngularVelocity = Vector3.new(0, spinVelocity, 0); spin.P = 1250;
end

local function claimAndSetupBooth()
    if not SETTINGS.EnableBoothFeatures or not findRemotes() then return end
    updateDisplay("INFO", "ƒêang claim booth...")
    local boothUI = Workspace:WaitForChild("MapUI"):WaitForChild("BoothUI")
    local unclaimed = {}
    for _, frame in ipairs(boothUI:GetChildren()) do
        if frame:FindFirstChild("Details") and frame.Details.Owner.Text == "unclaimed" then
            table.insert(unclaimed, tonumber(frame.Name:match("%d+")))
        end
    end
    if #unclaimed > 0 then
        local chosen = unclaimed[1]
        pcall(function() Remotes.Event("ClaimBooth"):InvokeServer(chosen) end)
        task.wait(0.5); updateBoothText(); startSpin();
    end
end

-- =================================================================
-- CHAT & SOCIAL
-- =================================================================
local function safeChat(msg)
    local chat = TextChatService and TextChatService.TextChannels and TextChatService.TextChannels.RBXGeneral
    if chat then pcall(function() chat:SendAsync(msg) end) end
end

local function setupAutoReply()
    if not SETTINGS.EnableAutoReply then return end
    local cd = {}
    Players.PlayerChatted:Connect(function(_, player, message)
        if player == LocalPlayer or not player.Character then return end
        local dist = (player.Character.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
        if dist > SETTINGS.ReplyRadius or (cd[player] and tick() - cd[player] < SETTINGS.ReplyCooldown) then return end
        local lower = string.lower(message)
        for _, rule in ipairs(SETTINGS.ReplyRules) do
            for _, kw in ipairs(rule.keywords) do
                if string.find(lower, kw) then
                    task.wait(math.random(1, 3)); safeChat(rule.replies[math.random(1, #rule.replies)])
                    cd[player] = tick(); return
                end
            end
        end
    end)
end

local function setupAutoSpam()
    if not SETTINGS.EnableAutoSpam then return end
    task.spawn(function()
        while task.wait(SETTINGS.SpamInterval) do
            safeChat(SETTINGS.SpamMessages[math.random(1, #SETTINGS.SpamMessages)])
        end
    end)
end

local function setupUnifiedDonationListener()
    local raised = LocalPlayer:WaitForChild("leaderstats"):WaitForChild("Raised")
    local last = raised.Value
    raised.Changed:Connect(function(new)
        local diff = new - last
        if diff > 0 then
            if SETTINGS.EnableDiscordWebhook then
                pcall(function()
                    local req = (syn and syn.request) or (http and http.request) or request
                    req({ Url = SETTINGS.WebhookURL, Method = "POST", Headers = {["Content-Type"]="application/json"}, Body = HttpService:JSONEncode({embeds={{description=string.format("**%s**\n# +%d\nTOTAL : %d", LocalPlayer.Name, diff, new), color=SETTINGS.WebhookColor}}})})
                end)
            end
            if SETTINGS.EnableDonateReset then countdownShouldReset = true end
            spinVelocity += diff * SETTINGS.spinSpeedPerR; updateSpinSpeed();
            if SETTINGS.EnableAutoThank then task.wait(1); safeChat(SETTINGS.ThankYouMessages[math.random(1, #SETTINGS.ThankYouMessages)]) end
        end
        last = new
    end)
end

-- =================================================================
-- LOGIC KI·ªÇM TRA
-- =================================================================
local function scanForBots()
    updateDisplay("INFO", "ƒêang qu√©t bot..."); task.wait(1)
    local boothUI = Workspace:WaitForChild("MapUI"):WaitForChild("BoothUI")
    local count = 0
    for _, frame in ipairs(boothUI:GetChildren()) do
        if frame.Details.Owner.Text ~= "unclaimed" then
            local txt = string.lower(frame.Sign.TextLabel.Text)
            for _, kw in ipairs(SETTINGS.BOT_KEYWORDS) do if string.find(txt, kw) then count = count + 1; break end end
        end
    end
    return count
end

local function checkAvoidPlayersOnce()
    if not SETTINGS.EnableAvoidPlayers then return false end
    for _, p in ipairs(Players:GetPlayers()) do
        for _, name in ipairs(SETTINGS.AVOID_PLAYERS) do
            if p.Name == name then updateDisplay("ERROR", "Ph√°t hi·ªán " .. name); return true end
        end
    end
    return false
end

-- =================================================================
-- KH·ªûI CH·∫†Y CH√çNH
-- =================================================================
task.spawn(function()
    createStatusGui(); updateDisplay("INFO", "ƒêang kh·ªüi t·∫°o...")
    task.wait(SETTINGS.InitialWaitTime)
    if type(setfpscap) == "function" then setfpscap(SETTINGS.TargetFps) end
    
    task.spawn(claimAndSetupBooth); task.spawn(setupUnifiedDonationListener);
    task.spawn(setupAutoReply); task.spawn(setupAutoSpam);

    if SETTINGS.EnableServerHop then
        local bots = SETTINGS.EnableAntiBotScan and scanForBots() or 0
        if bots >= SETTINGS.DETECTION_THRESHOLD or checkAvoidPlayersOnce() then
            searchForServer()
        else
            updateDisplay("SUCCESS", "Server ·ªïn. B·∫Øt ƒë·∫ßu AFK.")
            if SETTINGS.EnableSafePlatform then createSafePlatform() end
            if SETTINGS.EnableStaticAfkView then setupFacialCameraAndFreeze() end
            optimizeForCpu(); optimizeGraphics();
            
            task.spawn(function()
                local total = SETTINGS.WaitMinutes * 60
                for i = total, 0, -1 do
                    if countdownShouldReset then countdownShouldReset = false; updateDisplay("SUCCESS", "Reset!"); task.wait(1); return end
                    updateDisplay("INFO", string.format("%02d:%02d | %d ng∆∞·ªùi", math.floor(i/60), i%60, #Players:GetPlayers()))
                    task.wait(1)
                end
                searchForServer()
            end)
        end
    end
end)

updateDisplay("SUCCESS", "Script Ho√†n t·∫•t.")
