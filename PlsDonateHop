-- Các service cần thiết
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local CoreGui = game:GetService("CoreGui")
local Lighting = game:GetService("Lighting")
local SoundService = game:GetService("SoundService")
local RunService = game:GetService("RunService")

-- --- Cấu hình Script ---
local placeId = game.PlaceId
local currentJobId = game.JobId

local DEFAULT_WAIT_MINUTES = 10
local minPlayerPercentage = 0.50
local maxPlayerPercentageLimit = 0.90
local waitTimeBetweenFullScans = 7
local waitTimeBetweenPageFetches = 0.75
local baseRetryDelay = 1
local maxRetryDelay = 16

local SERVER_HISTORY_FILENAME = "server_hop_history.txt"
local SERVER_HOP_GUI_NAME = "ServerHopStatusGUI" -- Tên GUI để không xóa

-- [[ NEW CONFIG FOR FIXED TEXT SIZE ]]
local FIXED_TEXT_SIZE = 50 -- Kích thước chữ cố định

-- --- Kiểm tra và gán hàm đọc/ghi file (NẾU CÓ) ---
local canAccessFiles = false
local writefile_func, readfile_func
local can_access_files_success, _ = pcall(function()
    if writefile and readfile then
        canAccessFiles = true
        writefile_func = writefile
        readfile_func = readfile
    end
end)

if canAccessFiles then
    print("[ServerHop] Phát hiện writefile/readfile. Tính năng lưu lịch sử server được kích hoạt.")
else
    print("[ServerHop] Không phát hiện writefile/readfile. Sẽ chỉ tránh server hiện tại.")
end

-- --- UI Chính (Thông báo trạng thái) ---
local playerGui = LocalPlayer:WaitForChild("PlayerGui")
local statusScreenGui = playerGui:FindFirstChild(SERVER_HOP_GUI_NAME)
if statusScreenGui then statusScreenGui:Destroy() end -- Xóa GUI cũ nếu có

statusScreenGui = Instance.new("ScreenGui")
statusScreenGui.Name = SERVER_HOP_GUI_NAME
statusScreenGui.ResetOnSpawn = false
statusScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
statusScreenGui.IgnoreGuiInset = true -- Căn giữa chính xác hơn
statusScreenGui.Parent = playerGui

local statusTextLabel = Instance.new("TextLabel")
statusTextLabel.Name = "StatusLabel"
statusTextLabel.Size = UDim2.new(0.9, 0, 0, FIXED_TEXT_SIZE + 20)
statusTextLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
statusTextLabel.AnchorPoint = Vector2.new(0.5, 0.5)
statusTextLabel.BackgroundTransparency = 1
statusTextLabel.TextColor3 = Color3.fromRGB(255, 87, 51) -- Neon Pink
statusTextLabel.Font = Enum.Font.SourceSansSemibold
statusTextLabel.TextScaled = false
statusTextLabel.TextSize = FIXED_TEXT_SIZE
statusTextLabel.TextXAlignment = Enum.TextXAlignment.Center
statusTextLabel.TextYAlignment = Enum.TextYAlignment.Center
statusTextLabel.TextWrapped = false
statusTextLabel.Parent = statusScreenGui
statusTextLabel.Text = "..." -- Văn bản khởi tạo

local function updateStatus(message)
    print("[ServerHop] " .. tostring(message)) -- Giữ log console, đảm bảo message là string
    if statusTextLabel and statusTextLabel.Parent then
        statusTextLabel.Text = tostring(message)
    end
end

-- --- Hàm xử lý file cho LỊCH SỬ server ---
local serverHistoryCache = {}

local function loadServerHistory()
    if not canAccessFiles then return {} end
    local historySet = {}
    local success, content = pcall(readfile_func, SERVER_HISTORY_FILENAME)
    if success and content then
        local count = 0
        for line in string.gmatch(content, "[^" .. "\r\n" .. "]+") do
            local trimmedLine = line:match("^%s*(.-)%s*$")
            if trimmedLine and #trimmedLine > 0 then
                historySet[trimmedLine] = true
                count = count + 1
            end
        end
        if count > 0 then print("[ServerHop] Đã tải lịch sử " .. count .. " server.")
        else print("[ServerHop] File lịch sử rỗng hoặc không có ID hợp lệ.") end
    else
        if not success then print("[ServerHop] Lỗi đọc " .. SERVER_HISTORY_FILENAME .. ": " .. tostring(content))
        else print("[ServerHop] File lịch sử " .. SERVER_HISTORY_FILENAME .. " không tồn tại/rỗng.") end
    end
    serverHistoryCache = historySet
    return historySet
end

local function addJobIdToHistoryAndSave(jobIdToAdd)
    if not jobIdToAdd or not canAccessFiles then return end
    serverHistoryCache[jobIdToAdd] = true
    local historyLines = {}
    for id in pairs(serverHistoryCache) do table.insert(historyLines, id) end
    local contentToWrite = table.concat(historyLines, "\n")
    local success, err = pcall(writefile_func, SERVER_HISTORY_FILENAME, contentToWrite)
    if success then print("[ServerHop] Đã cập nhật lịch sử server, thêm ID: " .. jobIdToAdd)
    else print("[ServerHop] Lỗi lưu lịch sử: " .. tostring(err)) end
end

-- --- Script Xóa Hoàn Toàn Đồ Họa ---
local function removeAllGraphics()
    local success_pcall, error_pcall = pcall(function()
        updateStatus("Tối ưu hóa đồ họa...")
        task.wait(0.1)

        -- Xóa đối tượng trong Workspace (trừ Terrain, Camera, LocalPlayer character)
        print("[GraphicsRemover] Bắt đầu xóa đối tượng trong Workspace...")
        for _, obj in pairs(game.Workspace:GetChildren()) do
            if not obj:IsA("Terrain") and not obj:IsA("Camera") and obj.Name ~= LocalPlayer.Name then
                pcall(function() obj:Destroy() end)
            end
        end
        print("[GraphicsRemover] Đã xóa các đối tượng không cần thiết trong Workspace.")

        -- Vô hiệu hóa Lighting
        print("[GraphicsRemover] Cấu hình Lighting...")
        Lighting.GlobalShadows = false
        Lighting.Brightness = 0
        Lighting.Ambient = Color3.new(0,0,0)
        Lighting.OutdoorAmbient = Color3.new(0,0,0)
        Lighting.ClockTime = 12
        Lighting.FogEnd = 1e9
        Lighting.FogStart = 1e9 -1
        Lighting.GeographicLatitude = 0
        Lighting.ExposureCompensation = -2

        pcall(function() if Lighting:FindFirstChild("Atmosphere") then Lighting.Atmosphere:Destroy() end end)
        pcall(function() if Lighting:FindFirstChild("Sky") then Lighting.Sky:Destroy() end end)
        pcall(function() if Lighting:FindFirstChildOfClass("BloomEffect") then Lighting:FindFirstChildOfClass("BloomEffect").Enabled = false end end)
        pcall(function() if Lighting:FindFirstChildOfClass("BlurEffect") then Lighting:FindFirstChildOfClass("BlurEffect").Enabled = false end end)
        pcall(function() if Lighting:FindFirstChildOfClass("ColorCorrectionEffect") then Lighting:FindFirstChildOfClass("ColorCorrectionEffect").Enabled = false end end)
        pcall(function() if Lighting:FindFirstChildOfClass("DepthOfFieldEffect") then Lighting:FindFirstChildOfClass("DepthOfFieldEffect").Enabled = false end end)
        pcall(function() if Lighting:FindFirstChildOfClass("SunRaysEffect") then Lighting:FindFirstChildOfClass("SunRaysEffect").Enabled = false end end)
        print("[GraphicsRemover] Đã cấu hình Lighting.")

        -- Xóa GUI không cần thiết (TRỪ GUI CỦA SERVER HOP)
        print("[GraphicsRemover] Xóa GUI không cần thiết...")
        if LocalPlayer:FindFirstChild("PlayerGui") then
            for _, gui in pairs(LocalPlayer.PlayerGui:GetChildren()) do
                if gui.Name ~= SERVER_HOP_GUI_NAME then
                    pcall(function() gui:Destroy() end)
                end
            end
            print("[GraphicsRemover] Đã xóa GUI không cần thiết.")
        end

        -- Vô hiệu hóa Render
        print("[GraphicsRemover] Cấu hình Rendering...")
        local settingsAccessible, settingsObj = pcall(function() return settings() end)
        if settingsAccessible and settingsObj and settingsObj.Rendering then
            settingsObj.Rendering.QualityLevel = Enum.QualityLevel.Level01
            local renderDisabledSuccess = pcall(function() RunService:Set3dRenderingEnabled(false) end)
            if renderDisabledSuccess then
                 print("[GraphicsRemover] Đã cố gắng tắt 3D rendering.")
            else
                 print("[GraphicsRemover] Không thể gọi Set3dRenderingEnabled(false).")
            end
        else
            print("[GraphicsRemover] Không thể truy cập settings().Rendering hoặc settings() không tồn tại.")
        end
        print("[GraphicsRemover] Đã cấu hình Rendering.")

        -- Tắt toàn bộ âm thanh
        print("[GraphicsRemover] Tắt âm thanh...")
        SoundService.RespectFilteringEnabled = true
        SoundService.AmbientReverb = Enum.ReverbType.NoReverb
        SoundService.DopplerScale = 0
        SoundService.DistanceFactor = 0

        for _, sound in pairs(game:GetDescendants()) do
            if sound:IsA("Sound") then
                pcall(function()
                    sound.Playing = false
                    sound:Stop()
                    sound.Volume = 0
                    sound.PlaybackSpeed = 0
                end)
            end
        end
        print("[GraphicsRemover] Đã tắt âm thanh.")

        -- Ngăn chặn các đối tượng mới được thêm vào Workspace (CẨN THẬN KHI KÍCH HOẠT)
        --[[
        print("[GraphicsRemover] Kích hoạt ngăn chặn đối tượng mới trong Workspace (CÓ THỂ GÂY LỖI GAME).")
        game.Workspace.DescendantAdded:Connect(function(obj)
            if not obj:IsA("Camera") and (not obj:IsA("Model") or obj.Name ~= LocalPlayer.Name) and not obj:IsA("Terrain") then
                task.wait()
                pcall(function() obj:Destroy() end)
                print("[GraphicsRemover] Đã tự động xóa đối tượng mới: " .. obj.Name)
            end
        end)
        --]]

        updateStatus("Đồ họa đã được tối ưu.")
        print("[GraphicsRemover] Đã xóa/tối ưu hóa đồ họa.")
    end)
    if not success_pcall then
        warn("[GraphicsRemover] Lỗi khi thực hiện removeAllGraphics: " .. tostring(error_pcall))
        updateStatus("Lỗi tối ưu đồ họa.")
    end
end

-- --- Logic Tìm Server ---
local chosenServer = nil
local serversUrlBase = "https://games.roblox.com/v1/games/" .. placeId .. "/servers/Public?sortOrder=Asc&limit=100"
local serverHistoryToAvoid = loadServerHistory()

local function listServers(cursor)
    local requestUrl = serversUrlBase
    if cursor then requestUrl = requestUrl .. "&cursor=" .. cursor end

    local successCall, result = pcall(function()
        return HttpService:RequestAsync({Url = requestUrl, Method = "GET"})
    end)

    if not successCall or not result or not result.Success then
        local errorMsg = result and result.Body or tostring(result) -- result có thể là lỗi từ pcall
        return false, "Yêu cầu HTTP thất bại: " .. errorMsg
    end

    local successDecode, decodedResult = pcall(function() return HttpService:JSONDecode(result.Body) end)
    if not successDecode then return false, "JSONDecode thất bại: " .. tostring(decodedResult) end
    return true, decodedResult
end

function searchForServer()
    local historyCount = 0
    for _ in pairs(serverHistoryToAvoid) do historyCount = historyCount + 1 end
    updateStatus(string.format("Tìm server (%.0f%%-%.0f%%). Tránh %d server.",
        minPlayerPercentage * 100, maxPlayerPercentageLimit * 100, historyCount + 1))

    local searchLoopActive = true
    chosenServer = nil
    while searchLoopActive and not chosenServer do
        local currentNextCursorForFullScan = nil
        updateStatus("Quét server...")

        local allPagesScannedForThisRound = false
        while not allPagesScannedForThisRound and not chosenServer do
            local pageScanAttempts = 0
            local maxPageScanAttempts = 4
            local pageSuccessfullyFetched = false
            local currentRetryDelayPage = baseRetryDelay

            while not pageSuccessfullyFetched and pageScanAttempts < maxPageScanAttempts do
                pageScanAttempts = pageScanAttempts + 1
                if pageScanAttempts > 1 then
                    updateStatus(string.format("Thử lại trang (%d/%d). Chờ %.1fs...", pageScanAttempts, maxPageScanAttempts, currentRetryDelayPage))
                    task.wait(currentRetryDelayPage)
                    currentRetryDelayPage = math.min(currentRetryDelayPage * 2, maxRetryDelay)
                else
                    updateStatus("Lấy trang server...")
                end

                local success, dataOrError = listServers(currentNextCursorForFullScan)

                if success then
                    pageSuccessfullyFetched = true
                    currentRetryDelayPage = baseRetryDelay
                    local serverListData = dataOrError

                    if serverListData and serverListData.data then
                        local pageSuitableServers = {}
                        if #serverListData.data > 0 then
                            for _, serverInfo in ipairs(serverListData.data) do
                                local serverId = serverInfo.id
                                local isCurrentServer = (serverId == currentJobId)
                                local isInHistory = (serverHistoryToAvoid[serverId] == true)

                                if not isCurrentServer and not isInHistory then
                                    if serverInfo.playing and serverInfo.maxPlayers and serverInfo.maxPlayers > 0 then
                                        local playerRatio = serverInfo.playing / serverInfo.maxPlayers
                                        if playerRatio >= minPlayerPercentage and playerRatio < maxPlayerPercentageLimit and serverInfo.playing < serverInfo.maxPlayers then
                                            table.insert(pageSuitableServers, serverInfo)
                                        end
                                    end
                                end
                            end

                            if #pageSuitableServers > 0 then
                                updateStatus("Thấy " .. #pageSuitableServers .. " server tốt!")
                                chosenServer = pageSuitableServers[math.random(1, #pageSuitableServers)]
                                allPagesScannedForThisRound = true
                                break
                            end
                        end

                        if not chosenServer then
                            currentNextCursorForFullScan = serverListData.nextPageCursor
                            if not currentNextCursorForFullScan then
                                allPagesScannedForThisRound = true
                                updateStatus("Hết server để quét.")
                            end
                        end
                    else
                        updateStatus("Dữ liệu server không hợp lệ hoặc trống.")
                    end
                else
                    local errorMessageStr = tostring(dataOrError)
                    local shortError = #errorMessageStr > 40 and (string.sub(errorMessageStr, 1, 40) .. "...") or errorMessageStr
                    updateStatus("Lỗi API: " .. shortError)
                    if pageScanAttempts >= maxPageScanAttempts then
                        updateStatus("Lỗi lấy trang nhiều lần. Bỏ qua.")
                        allPagesScannedForThisRound = true -- Dừng quét trang này nếu lỗi liên tục
                    end
                end
            end

            if chosenServer or allPagesScannedForThisRound then break end
            if pageSuccessfullyFetched and not allPagesScannedForThisRound and not chosenServer then
                task.wait(waitTimeBetweenPageFetches)
            end
        end

        if chosenServer then
            local shortId = chosenServer.id and string.sub(tostring(chosenServer.id), 1, 8) or "N/A"
            updateStatus(string.format("CHỌN SERVER! ID: %s (%d/%d)",
                shortId, chosenServer.playing or 0, chosenServer.maxPlayers or 0))
            searchLoopActive = false
        elseif allPagesScannedForThisRound then -- Chỉ chờ nếu đã quét hết mà không tìm thấy
            updateStatus(string.format("Không tìm thấy server phù hợp. Chờ %ds quét lại...", waitTimeBetweenFullScans))
            task.wait(waitTimeBetweenFullScans)
        end
         -- Nếu vòng lặp tìm kiếm vẫn hoạt động (searchLoopActive) và chưa có server, nó sẽ tự động lặp lại.
    end

    if chosenServer then
        updateStatus("Đang dịch chuyển...")
        addJobIdToHistoryAndSave(currentJobId)
        task.wait(1) -- Thời gian ngắn trước khi teleport

        local success_tp, err_tp = pcall(function()
            TeleportService:TeleportToPlaceInstance(placeId, chosenServer.id, LocalPlayer)
        end)

        if not success_tp then
            local errorTpStr = tostring(err_tp)
            local shortErrorTp = #errorTpStr > 40 and (string.sub(errorTpStr, 1, 40) .. "...") or errorTpStr
            updateStatus("Dịch chuyển lỗi: " .. shortErrorTp)
            serverHistoryToAvoid[chosenServer.id] = true
            print("[ServerHop] Đã thêm server lỗi dịch chuyển ("..tostring(chosenServer.id)..") vào danh sách tránh tạm thời.")
            chosenServer = nil
            task.wait(5)
            searchForServer() -- Thử tìm lại
        end
    else
        updateStatus("Không thể tìm thấy server phù hợp sau nhiều lần quét. Dừng.")
        -- Cân nhắc thêm: có thể thử lại sau một khoảng thời gian dài hơn, hoặc yêu cầu người dùng can thiệp.
    end
end

local countdownShouldReset = false
local currentCountdownThread = nil

local function performCountdownThenSearch(minutesToWait)
    if not minutesToWait or minutesToWait <= 0 then
        updateStatus("Thời gian chờ không hợp lệ. Tìm ngay...")
        searchForServer()
        return
    end

    local totalWaitSeconds = minutesToWait * 60
    print(string.format("[ServerHop] Bắt đầu tìm server sau: %d phút %d giây...", math.floor(totalWaitSeconds / 60), totalWaitSeconds % 60))

    for i = totalWaitSeconds, 0, -1 do
        if countdownShouldReset then
            countdownShouldReset = false
            updateStatus("Donate! Reset đếm ngược.")
            -- Gọi lại startInitialCountdown để đảm bảo coroutine được quản lý đúng cách
            startInitialCountdown()
            return -- Thoát khỏi coroutine hiện tại
        end
        local minutesLeft = math.floor(i / 60)
        local secondsLeft = i % 60

        if statusTextLabel and statusTextLabel.Parent then
            statusTextLabel.Text = string.format("%02d:%02d", minutesLeft, secondsLeft)
        end
        task.wait(1)
    end

    updateStatus("Hết giờ! Bắt đầu tìm server...")
    searchForServer()
end

local function startInitialCountdown()
    if currentCountdownThread and coroutine.status(currentCountdownThread) ~= "dead" then
        pcall(coroutine.close, currentCountdownThread) -- Cố gắng đóng coroutine cũ
        currentCountdownThread = nil
        print("[ServerHop] Đã cố gắng đóng coroutine đếm ngược cũ.")
    end

    currentCountdownThread = coroutine.create(function()
        local success, err = pcall(performCountdownThenSearch, DEFAULT_WAIT_MINUTES)
        if not success then
            warn("[ServerHop] Lỗi trong coroutine đếm ngược: " .. tostring(err))
            updateStatus("Lỗi coroutine. Thử lại sau 5s...")
            task.wait(5)
            startInitialCountdown() -- Thử khởi động lại nếu coroutine bị lỗi nghiêm trọng
        end
    end)
    coroutine.resume(currentCountdownThread)
end

-- --- Xử lý sự kiện Donate ---
local leaderstatsSuccess, leaderstats = pcall(function() return LocalPlayer:WaitForChild("leaderstats", 15) end)
if leaderstatsSuccess and leaderstats then
    local raisedValueObjectSuccess, raisedValueObject = pcall(function() return leaderstats:WaitForChild("Raised", 15) end)
    if raisedValueObjectSuccess and raisedValueObject then
        local lastRaisedValue = raisedValueObject.Value

        raisedValueObject.Changed:Connect(function(newRaisedAmount)
            if newRaisedAmount > lastRaisedValue then
                updateStatus(string.format("Donate! Raised: %.0f -> %.0f", lastRaisedValue, newRaisedAmount))
                lastRaisedValue = newRaisedAmount
                countdownShouldReset = true
