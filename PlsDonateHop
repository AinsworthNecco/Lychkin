-- Các service cần thiết
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local CoreGui = game:GetService("CoreGui")

-- --- Cấu hình Script ---
local placeId = game.PlaceId
local currentJobId = game.JobId

local DEFAULT_WAIT_MINUTES = 10
local minPlayerPercentage = 0.50
local maxPlayerPercentageLimit = 0.90
local waitTimeBetweenFullScans = 7
local waitTimeBetweenPageFetches = 0.75
local baseRetryDelay = 1
local maxRetryDelay = 16

local SERVER_HISTORY_FILENAME = "server_hop_history.txt"

-- [[ NEW CONFIG FOR FIXED TEXT SIZE ]]
-- Đặt kích thước chữ cố định bằng pixel.
local FIXED_TEXT_SIZE = 50 -- Kích thước chữ cố định là 300 pixels

-- --- Kiểm tra và gán hàm đọc/ghi file (NẾU CÓ) ---
local canAccessFiles = false
local writefile_func, readfile_func
if writefile and readfile then
    canAccessFiles = true
    writefile_func = writefile
    readfile_func = readfile
    print("[ServerHop] Phát hiện writefile/readfile. Tính năng lưu lịch sử server được kích hoạt.")
else
    print("[ServerHop] Không phát hiện writefile/readfile. Sẽ chỉ tránh server hiện tại.")
end

-- --- UI Chính (Thông báo trạng thái) ---
local playerGui = LocalPlayer:WaitForChild("PlayerGui")
local statusScreenGui = playerGui:FindFirstChild("ServerHopStatusGUI")
if statusScreenGui then statusScreenGui:Destroy() end -- Xóa GUI cũ nếu có

statusScreenGui = Instance.new("ScreenGui")
statusScreenGui.Name = "ServerHopStatusGUI"
statusScreenGui.ResetOnSpawn = false
statusScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
-- [[ MODIFICATION FOR BETTER CENTERING ]]
-- Bỏ qua phần diện tích bị chiếm bởi các thanh UI mặc định của Roblox (ví dụ: top bar)
-- để việc căn giữa được chính xác hơn trên toàn màn hình.
statusScreenGui.IgnoreGuiInset = true
statusScreenGui.Parent = playerGui

local statusTextLabel = Instance.new("TextLabel")
statusTextLabel.Name = "StatusLabel"
-- [[ MODIFIED UI PROPERTIES FOR NEON PINK TEXT, NO OUTLINE ]]

-- Kích thước của label cần đủ lớn cho chữ kích thước 300.
-- Sử dụng Offset cho chiều cao để đảm bảo đủ không gian.
-- Chiều rộng 90% màn hình, chiều cao là kích thước chữ + một chút padding (ví dụ: 20px).
statusTextLabel.Size = UDim2.new(0.9, 0, 0, FIXED_TEXT_SIZE + 20) -- Giảm padding một chút vì không còn viền
statusTextLabel.Position = UDim2.new(0.5, 0, 0.5, 0) -- Căn giữa màn hình
statusTextLabel.AnchorPoint = Vector2.new(0.5, 0.5) -- Đặt điểm neo ở giữa label
statusTextLabel.BackgroundTransparency = 1 -- Nền trong suốt

-- Màu chữ hồng neon rực rỡ
statusTextLabel.TextColor3 = Color3.fromRGB(255, 0, 255) -- Màu Magenta/Fuchsia (Neon Pink)
-- Hoặc thử: Color3.fromRGB(255, 87, 51) -- HotPink
-- Hoặc: Color3.fromRGB(255, 20, 147) -- DeepPink

statusTextLabel.Font = Enum.Font.SourceSansSemibold -- Giữ font gốc (hoặc chọn font khác nếu muốn)

statusTextLabel.TextScaled = false -- KHÔNG sử dụng TextScaled
statusTextLabel.TextSize = FIXED_TEXT_SIZE -- Sử dụng kích thước chữ cố định từ cấu hình

statusTextLabel.TextXAlignment = Enum.TextXAlignment.Center -- Căn chữ theo chiều ngang
statusTextLabel.TextYAlignment = Enum.TextYAlignment.Center -- Căn chữ theo chiều dọc
statusTextLabel.TextWrapped = false -- Với kích thước chữ lớn và nội dung ngắn (MM:SS), không cần wrap
statusTextLabel.Parent = statusScreenGui

-- [[ UIStroke (viền) đã được loại bỏ ]]

-- [[ MODIFIED UI PROPERTIES END ]]
statusTextLabel.Text = "..." -- Văn bản khởi tạo ngắn gọn

local function updateStatus(message)
    print("[ServerHop] " .. message) -- Giữ log console
    if statusTextLabel and statusTextLabel.Parent then
        statusTextLabel.Text = message
    end
end

-- --- Hàm xử lý file cho LỊCH SỬ server ---
local serverHistoryCache = {}

local function loadServerHistory()
    local historySet = {}
    if canAccessFiles then
        local success, content = pcall(readfile_func, SERVER_HISTORY_FILENAME)
        if success and content then
            local count = 0
            for line in string.gmatch(content, "[^" .. "\r\n" .. "]+") do
                local trimmedLine = line:match("^%s*(.-)%s*$")
                if trimmedLine and #trimmedLine > 0 then
                    historySet[trimmedLine] = true
                    count = count + 1
                end
            end
            if count > 0 then print("[ServerHop] Đã tải lịch sử " .. count .. " server.")
            else print("[ServerHop] File lịch sử rỗng hoặc không có ID hợp lệ.") end
        else
            if not success then print("[ServerHop] Lỗi đọc " .. SERVER_HISTORY_FILENAME .. ": " .. tostring(content))
            else print("[ServerHop] File lịch sử " .. SERVER_HISTORY_FILENAME .. " không tồn tại/rỗng.") end
        end
    end
    serverHistoryCache = historySet
    return historySet
end

local function addJobIdToHistoryAndSave(jobIdToAdd)
    if not jobIdToAdd or not canAccessFiles then return end
    serverHistoryCache[jobIdToAdd] = true
    local historyLines = {}
    for id in pairs(serverHistoryCache) do table.insert(historyLines, id) end
    local contentToWrite = table.concat(historyLines, "\n")
    local success, err = pcall(writefile_func, SERVER_HISTORY_FILENAME, contentToWrite)
    if success then print("[ServerHop] Đã cập nhật lịch sử server, thêm ID: " .. jobIdToAdd)
    else print("[ServerHop] Lỗi lưu lịch sử: " .. tostring(err)) end
end

-- --- Logic Tìm Server ---
local chosenServer = nil
local serversUrlBase = "https://games.roblox.com/v1/games/" .. placeId .. "/servers/Public?sortOrder=Asc&limit=100"
local serverHistoryToAvoid = loadServerHistory()

local function listServers(cursor)
    local requestUrl = serversUrlBase
    if cursor then requestUrl = requestUrl .. "&cursor=" .. cursor end
    local successCall, result = pcall(function() return game:HttpGet(requestUrl, true) end)
    if not successCall then return false, "HttpGet thất bại: " .. tostring(result) end
    local successDecode, decodedResult = pcall(function() return HttpService:JSONDecode(result) end)
    if not successDecode then return false, "JSONDecode thất bại: " .. tostring(decodedResult) end
    return true, decodedResult
end

function searchForServer()
    local historyCount = 0
    for _ in pairs(serverHistoryToAvoid) do historyCount = historyCount + 1 end
    updateStatus(string.format("Tìm server (%.0f%%-%.0f%%). Tránh %d server.",
        minPlayerPercentage * 100, maxPlayerPercentageLimit * 100, historyCount + 1))

    local searchLoopActive = true
    chosenServer = nil 
    while searchLoopActive and not chosenServer do
        local currentNextCursorForFullScan = nil
        local currentRetryDelaySearch = baseRetryDelay 
        updateStatus("Quét server...")
        
        local allPagesScannedForThisRound = false
        while not allPagesScannedForThisRound and not chosenServer do
            local pageScanAttempts = 0
            local maxPageScanAttempts = 4
            local pageSuccessfullyFetched = false
            local currentRetryDelayPage = baseRetryDelay

            while not pageSuccessfullyFetched and pageScanAttempts < maxPageScanAttempts do
                pageScanAttempts = pageScanAttempts + 1
                if pageScanAttempts > 1 then
                    updateStatus(string.format("Thử lại trang (%d/%d). Chờ %.1fs...", pageScanAttempts, maxPageScanAttempts, currentRetryDelayPage))
                    task.wait(currentRetryDelayPage) 
                    currentRetryDelayPage = math.min(currentRetryDelayPage * 2, maxRetryDelay)
                else
                    updateStatus("Lấy trang server...")
                end

                local success, dataOrError = listServers(currentNextCursorForFullScan)

                if success then
                    pageSuccessfullyFetched = true
                    currentRetryDelayPage = baseRetryDelay  
                    local serverListData = dataOrError

                    if serverListData and serverListData.data then
                        local pageSuitableServers = {}
                        if #serverListData.data > 0 then
                            -- updateStatus("Đã nhận " .. #serverListData.data .. " server. Đang lọc...")
                            
                            for _, serverInfo in ipairs(serverListData.data) do
                                local serverId = serverInfo.id
                                local isCurrentServer = (serverId == currentJobId)
                                local isInHistory = (serverHistoryToAvoid[serverId] == true)

                                if not isCurrentServer and not isInHistory then
                                    if serverInfo.playing and serverInfo.maxPlayers and serverInfo.maxPlayers > 0 then
                                        local playerRatio = serverInfo.playing / serverInfo.maxPlayers
                                        if playerRatio >= minPlayerPercentage and playerRatio < maxPlayerPercentageLimit and serverInfo.playing < serverInfo.maxPlayers then
                                            table.insert(pageSuitableServers, serverInfo)
                                        end
                                    end
                                end
                            end

                            if #pageSuitableServers > 0 then
                                updateStatus("Thấy " .. #pageSuitableServers .. " server tốt!")
                                chosenServer = pageSuitableServers[math.random(1, #pageSuitableServers)]
                                allPagesScannedForThisRound = true  
                                break  
                            else
                                -- updateStatus("Không có server phù hợp trang này.")
                            end
                        else
                            -- updateStatus("Trang này không có server.")
                        end
                        
                        if not chosenServer then
                            currentNextCursorForFullScan = serverListData.nextPageCursor
                            if not currentNextCursorForFullScan then
                                allPagesScannedForThisRound = true  
                                updateStatus("Hết server để quét.")
                            end
                        end
                    else
                        updateStatus("Dữ liệu server không hợp lệ.")
                        currentNextCursorForFullScan = serverListData and serverListData.nextPageCursor
                            if not currentNextCursorForFullScan then allPagesScannedForThisRound = true end
                    end
                else  
                    local errorMessage = dataOrError
                    updateStatus("Lỗi API: " .. tissus.left(errorMessage, 20)) -- Rút gọn tin nhắn lỗi dài
                    if pageScanAttempts >= maxPageScanAttempts then
                        updateStatus("Lỗi lấy trang. Bỏ qua.")
                        allPagesScannedForThisRound = true  
                    end
                end
            end  

            if chosenServer or allPagesScannedForThisRound then break end
            if pageSuccessfullyFetched and not allPagesScannedForThisRound and not chosenServer then
                -- updateStatus("Chờ " .. waitTimeBetweenPageFetches .. "s...")
                task.wait(waitTimeBetweenPageFetches) 
            end
        end

        if chosenServer then
            updateStatus(string.format("CHỌN SERVER! ID: %s (%d/%d)",
                chosenServer.id:sub(1,8), chosenServer.playing, chosenServer.maxPlayers)) -- Rút gọn ID
            searchLoopActive = false
        elseif allPagesScannedForThisRound then
                updateStatus(string.format("Không tìm thấy. Chờ %ds quét lại...", waitTimeBetweenFullScans))
                task.wait(waitTimeBetweenFullScans) 
        end
            if not searchLoopActive then break end
    end

    if chosenServer then
        updateStatus("Dịch chuyển...")
        addJobIdToHistoryAndSave(currentJobId)
        task.wait(2) 
        
        local success_tp, err_tp = pcall(function()
            TeleportService:TeleportToPlaceInstance(placeId, chosenServer.id, LocalPlayer)
        end)
        
        if not success_tp then
            updateStatus("Dịch chuyển lỗi: " .. tissus.left(tostring(err_tp), 20))
            chosenServer = nil  
            task.wait(5) 
            searchForServer()  
        end
    else
        updateStatus("Không tìm thấy server. Dừng.")
    end
end

local countdownShouldReset = false
local currentCountdownThread = nil 

local function performCountdownThenSearch(minutesToWait)
    if not minutesToWait or minutesToWait <= 0 then
        updateStatus("Thời gian chờ lỗi. Tìm ngay...") 
        searchForServer()
        return
    end

    local totalWaitSeconds = minutesToWait * 60
    print(string.format("[ServerHop] Đã đặt giờ! Bắt đầu tìm server sau: %d phút %d giây...", math.floor(totalWaitSeconds / 60), totalWaitSeconds % 60))
    
    for i = totalWaitSeconds, 0, -1 do
        if countdownShouldReset then 
            countdownShouldReset = false 
            updateStatus("Donate! Reset đếm ngược.") 
            performCountdownThenSearch(DEFAULT_WAIT_MINUTES) 
            return 
        end
        local minutesLeft = math.floor(i / 60)
        local secondsLeft = i % 60
        
        if statusTextLabel and statusTextLabel.Parent then
            statusTextLabel.Text = string.format("%02d:%02d", minutesLeft, secondsLeft)
        end
        
        task.wait(1) 
    end

    updateStatus("Hết giờ! Tìm server...") 
    searchForServer()
end

local function startInitialCountdown()
    if currentCountdownThread and coroutine.status(currentCountdownThread) ~= "dead" then
        coroutine.close(currentCountdownThread) 
    end
    currentCountdownThread = coroutine.create(function()
        performCountdownThenSearch(DEFAULT_WAIT_MINUTES)
    end)
    coroutine.resume(currentCountdownThread)
end

-- --- Xử lý sự kiện Donate ---
local leaderstats = LocalPlayer:WaitForChild("leaderstats")
local raisedValueObject = leaderstats:WaitForChild("Raised") 
local lastRaisedValue = raisedValueObject.Value

raisedValueObject.Changed:Connect(function(newRaisedAmount)
    if newRaisedAmount > lastRaisedValue then
        updateStatus(string.format("Donate! Raised: %d -> %d", lastRaisedValue, newRaisedAmount)) 
        lastRaisedValue = newRaisedAmount
        
        countdownShouldReset = true  
        
        print("[ServerHop] Cờ reset đã được đặt do có donate.")
    end
end)

-- --- Khởi chạy Script ---
updateStatus("...") -- Văn bản khởi tạo ngắn gọn
task.wait(1) -- Giảm thời gian chờ ban đầu
print("[ServerHop] Thời gian chờ mặc định trước khi tìm server: " .. DEFAULT_WAIT_MINUTES .. " phút.")
startInitialCountdown()
