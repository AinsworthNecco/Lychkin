-- Các service cần thiết
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService") -- Added RunService
local LocalPlayer = Players.LocalPlayer
local CoreGui = game:GetService("CoreGui")

-- --- Cấu hình Script ---
local placeId = game.PlaceId
local currentJobId = game.JobId

local DEFAULT_WAIT_MINUTES = 10
local minPlayerPercentage = 0.50
local maxPlayerPercentageLimit = 0.90
local waitTimeBetweenFullScans = 7
local waitTimeBetweenPageFetches = 0.75
local baseRetryDelay = 1
local maxRetryDelay = 16

local SERVER_HISTORY_FILENAME = "server_hop_history.txt"

-- [[ NEW CONFIG FOR FIXED TEXT SIZE ]]
-- Đặt kích thước chữ cố định bằng pixel.
local FIXED_TEXT_SIZE = 50 -- Kích thước chữ cố định

-- --- Kiểm tra và gán hàm đọc/ghi file (NẾU CÓ) ---
local canAccessFiles = false
local writefile_func, readfile_func
if writefile and readfile then
    canAccessFiles = true
    writefile_func = writefile
    readfile_func = readfile
    print("[ServerHop] Phát hiện writefile/readfile. Tính năng lưu lịch sử server được kích hoạt.")
else
    print("[ServerHop] Không phát hiện writefile/readfile. Sẽ chỉ tránh server hiện tại.")
end

-- --- UI Chính (Thông báo trạng thái) ---
local playerGui = LocalPlayer:WaitForChild("PlayerGui")
local statusScreenGui = playerGui:FindFirstChild("ServerHopStatusGUI")
if statusScreenGui then statusScreenGui:Destroy() end -- Xóa GUI cũ nếu có

statusScreenGui = Instance.new("ScreenGui")
statusScreenGui.Name = "ServerHopStatusGUI"
statusScreenGui.ResetOnSpawn = false
statusScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
statusScreenGui.IgnoreGuiInset = true
statusScreenGui.Parent = playerGui

-- [[ MODIFIED UI: Full-screen black layer ]]
local blackBackgroundFrame = Instance.new("Frame")
blackBackgroundFrame.Name = "BlackBackground"
blackBackgroundFrame.Size = UDim2.new(1, 0, 1, 0) -- Full screen
blackBackgroundFrame.Position = UDim2.new(0, 0, 0, 0)
blackBackgroundFrame.AnchorPoint = Vector2.new(0, 0)
blackBackgroundFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0) -- Black color
blackBackgroundFrame.BackgroundTransparency = 0 -- Fully opaque
blackBackgroundFrame.BorderSizePixel = 0
blackBackgroundFrame.ZIndex = 1 -- Base layer
blackBackgroundFrame.Parent = statusScreenGui

local statusTextLabel = Instance.new("TextLabel")
statusTextLabel.Name = "StatusLabel"
-- Kích thước của label cần đủ lớn cho chữ.
-- Chiều rộng 90% màn hình, chiều cao là kích thước chữ + một chút padding.
statusTextLabel.Size = UDim2.new(0.9, 0, 0, FIXED_TEXT_SIZE + 20)
statusTextLabel.Position = UDim2.new(0.5, 0, 0.5, 0) -- Căn giữa màn hình
statusTextLabel.AnchorPoint = Vector2.new(0.5, 0.5) -- Đặt điểm neo ở giữa label
statusTextLabel.BackgroundTransparency = 1 -- Nền trong suốt

-- Màu chữ hồng neon rực rỡ
statusTextLabel.TextColor3 = Color3.fromRGB(255, 87, 51) -- Màu Magenta/Fuchsia (Neon Pink)

statusTextLabel.Font = Enum.Font.SourceSansSemibold
statusTextLabel.TextScaled = false
statusTextLabel.TextSize = FIXED_TEXT_SIZE

statusTextLabel.TextXAlignment = Enum.TextXAlignment.Center
statusTextLabel.TextYAlignment = Enum.TextYAlignment.Center
statusTextLabel.TextWrapped = false
statusTextLabel.ZIndex = 2 -- Ensure text is above the black background
statusTextLabel.Parent = statusScreenGui

statusTextLabel.Text = "..." -- Văn bản khởi tạo ngắn gọn

local function updateStatus(message)
    print("[ServerHop] " .. message) -- Giữ log console
    if statusTextLabel and statusTextLabel.Parent then
        statusTextLabel.Text = message
    end
end

-- --- Hàm xử lý file cho LỊCH SỬ server ---
local serverHistoryCache = {}

local function loadServerHistory()
    local historySet = {}
    if canAccessFiles then
        local success, content = pcall(readfile_func, SERVER_HISTORY_FILENAME)
        if success and content then
            local count = 0
            for line in string.gmatch(content, "[^" .. "\r\n" .. "]+") do
                local trimmedLine = line:match("^%s*(.-)%s*$")
                if trimmedLine and #trimmedLine > 0 then
                    historySet[trimmedLine] = true
                    count = count + 1
                end
            end
            if count > 0 then print("[ServerHop] Đã tải lịch sử " .. count .. " server.")
            else print("[ServerHop] File lịch sử rỗng hoặc không có ID hợp lệ.") end
        else
            if not success then print("[ServerHop] Lỗi đọc " .. SERVER_HISTORY_FILENAME .. ": " .. tostring(content))
            else print("[ServerHop] File lịch sử " .. SERVER_HISTORY_FILENAME .. " không tồn tại/rỗng.") end
        end
    end
    serverHistoryCache = historySet
    return historySet
end

local function addJobIdToHistoryAndSave(jobIdToAdd)
    if not jobIdToAdd or not canAccessFiles then return end
    serverHistoryCache[jobIdToAdd] = true
    local historyLines = {}
    for id in pairs(serverHistoryCache) do table.insert(historyLines, id) end
    local contentToWrite = table.concat(historyLines, "\n")
    local success, err = pcall(writefile_func, SERVER_HISTORY_FILENAME, contentToWrite)
    if success then print("[ServerHop] Đã cập nhật lịch sử server, thêm ID: " .. jobIdToAdd)
    else print("[ServerHop] Lỗi lưu lịch sử: " .. tostring(err)) end
end

-- --- Logic Tìm Server ---
local chosenServer = nil
local serversUrlBase = "https://games.roblox.com/v1/games/" .. placeId .. "/servers/Public?sortOrder=Asc&limit=100"
local serverHistoryToAvoid = loadServerHistory()

local function listServers(cursor)
    local requestUrl = serversUrlBase
    if cursor then requestUrl = requestUrl .. "&cursor=" .. cursor end
    local successCall, result = pcall(function() return game:HttpGet(requestUrl, true) end)
    if not successCall then return false, "HttpGet thất bại: " .. tostring(result) end
    local successDecode, decodedResult = pcall(function() return HttpService:JSONDecode(result) end)
    if not successDecode then return false, "JSONDecode thất bại: " .. tostring(decodedResult) end
    return true, decodedResult
end

function searchForServer()
    local historyCount = 0
    for _ in pairs(serverHistoryToAvoid) do historyCount = historyCount + 1 end
    updateStatus(string.format("Tìm server (%.0f%%-%.0f%%). Tránh %d server.",
        minPlayerPercentage * 100, maxPlayerPercentageLimit * 100, historyCount + 1))

    local searchLoopActive = true
    chosenServer = nil
    while searchLoopActive and not chosenServer do
        local currentNextCursorForFullScan = nil
        local currentRetryDelaySearch = baseRetryDelay
        updateStatus("Quét server...")
        
        local allPagesScannedForThisRound = false
        while not allPagesScannedForThisRound and not chosenServer do
            local pageScanAttempts = 0
            local maxPageScanAttempts = 4
            local pageSuccessfullyFetched = false
            local currentRetryDelayPage = baseRetryDelay

            while not pageSuccessfullyFetched and pageScanAttempts < maxPageScanAttempts do
                pageScanAttempts = pageScanAttempts + 1
                if pageScanAttempts > 1 then
                    updateStatus(string.format("Thử lại trang (%d/%d). Chờ %.1fs...", pageScanAttempts, maxPageScanAttempts, currentRetryDelayPage))
                    task.wait(currentRetryDelayPage)
                    currentRetryDelayPage = math.min(currentRetryDelayPage * 2, maxRetryDelay)
                else
                    updateStatus("Lấy trang server...")
                end

                local success, dataOrError = listServers(currentNextCursorForFullScan)

                if success then
                    pageSuccessfullyFetched = true
                    currentRetryDelayPage = baseRetryDelay
                    local serverListData = dataOrError

                    if serverListData and serverListData.data then
                        local pageSuitableServers = {}
                        if #serverListData.data > 0 then
                            for _, serverInfo in ipairs(serverListData.data) do
                                local serverId = serverInfo.id
                                local isCurrentServer = (serverId == currentJobId)
                                local isInHistory = (serverHistoryToAvoid[serverId] == true)

                                if not isCurrentServer and not isInHistory then
                                    if serverInfo.playing and serverInfo.maxPlayers and serverInfo.maxPlayers > 0 then
                                        local playerRatio = serverInfo.playing / serverInfo.maxPlayers
                                        if playerRatio >= minPlayerPercentage and playerRatio < maxPlayerPercentageLimit and serverInfo.playing < serverInfo.maxPlayers then
                                            table.insert(pageSuitableServers, serverInfo)
                                        end
                                    end
                                end
                            end

                            if #pageSuitableServers > 0 then
                                updateStatus("Thấy " .. #pageSuitableServers .. " server tốt!")
                                chosenServer = pageSuitableServers[math.random(1, #pageSuitableServers)]
                                allPagesScannedForThisRound = true
                                break
                            end
                        end
                        
                        if not chosenServer then
                            currentNextCursorForFullScan = serverListData.nextPageCursor
                            if not currentNextCursorForFullScan then
                                allPagesScannedForThisRound = true
                                updateStatus("Hết server để quét.")
                            end
                        end
                    else
                        updateStatus("Dữ liệu server không hợp lệ.")
                        currentNextCursorForFullScan = serverListData and serverListData.nextPageCursor
                        if not currentNextCursorForFullScan then allPagesScannedForThisRound = true end
                    end
                else
                    local errorMessage = tostring(dataOrError) -- Ensure it's a string
                    -- Check if 'tissus' is a defined library or if it was a typo for 'string'
                    -- Assuming 'string.sub' was intended for robust error message shortening
                    local shortError = #errorMessage > 20 and (string.sub(errorMessage, 1, 20) .. "...") or errorMessage
                    updateStatus("Lỗi API: " .. shortError)
                    if pageScanAttempts >= maxPageScanAttempts then
                        updateStatus("Lỗi lấy trang. Bỏ qua.")
                        allPagesScannedForThisRound = true
                    end
                end
            end

            if chosenServer or allPagesScannedForThisRound then break end
            if pageSuccessfullyFetched and not allPagesScannedForThisRound and not chosenServer then
                task.wait(waitTimeBetweenPageFetches)
            end
        end

        if chosenServer then
            updateStatus(string.format("CHỌN SERVER! ID: %s (%d/%d)",
                chosenServer.id:sub(1,8), chosenServer.playing, chosenServer.maxPlayers))
            searchLoopActive = false
        elseif allPagesScannedForThisRound then
                updateStatus(string.format("Không tìm thấy. Chờ %ds quét lại...", waitTimeBetweenFullScans))
                task.wait(waitTimeBetweenFullScans)
        end
            if not searchLoopActive then break end
    end

    if chosenServer then
        updateStatus("Dịch chuyển...")
        addJobIdToHistoryAndSave(currentJobId)
        task.wait(2)
        
        local success_tp, err_tp = pcall(function()
            TeleportService:TeleportToPlaceInstance(placeId, chosenServer.id, LocalPlayer)
        end)
        
        if not success_tp then
            local errorMsgTp = tostring(err_tp)
            local shortErrorTp = #errorMsgTp > 20 and (string.sub(errorMsgTp, 1, 20) .. "...") or errorMsgTp
            updateStatus("Dịch chuyển lỗi: " .. shortErrorTp)
            chosenServer = nil
            task.wait(5)
            searchForServer()
        end
    else
        updateStatus("Không tìm thấy server. Dừng.")
    end
end

local countdownShouldReset = false
local currentCountdownThread = nil

local function performCountdownThenSearch(minutesToWait)
    if not minutesToWait or minutesToWait <= 0 then
        updateStatus("Thời gian chờ lỗi. Tìm ngay...")
        searchForServer()
        return
    end

    local totalWaitSeconds = minutesToWait * 60
    print(string.format("[ServerHop] Đã đặt giờ! Bắt đầu tìm server sau: %d phút %d giây...", math.floor(totalWaitSeconds / 60), totalWaitSeconds % 60))
    
    for i = totalWaitSeconds, 0, -1 do
        if countdownShouldReset then
            countdownShouldReset = false
            updateStatus("Donate! Reset đếm ngược.")
            performCountdownThenSearch(DEFAULT_WAIT_MINUTES)
            return
        end
        local minutesLeft = math.floor(i / 60)
        local secondsLeft = i % 60
        
        if statusTextLabel and statusTextLabel.Parent then
            statusTextLabel.Text = string.format("%02d:%02d", minutesLeft, secondsLeft)
        end
        
        task.wait(1)
    end

    updateStatus("Hết giờ! Tìm server...")
    searchForServer()
end

local function startInitialCountdown()
    if currentCountdownThread and coroutine.status(currentCountdownThread) ~= "dead" then
        coroutine.close(currentCountdownThread)
    end
    currentCountdownThread = coroutine.create(function()
        performCountdownThenSearch(DEFAULT_WAIT_MINUTES)
    end)
    coroutine.resume(currentCountdownThread)
end

-- --- Xử lý sự kiện Donate ---
-- Assuming 'leaderstats' and 'Raised' are correctly set up elsewhere for the LocalPlayer
pcall(function() -- Wrap in pcall in case leaderstats or Raised are not immediately available
    local leaderstats = LocalPlayer:WaitForChild("leaderstats")
    local raisedValueObject = leaderstats:WaitForChild("Raised")
    local lastRaisedValue = raisedValueObject.Value

    raisedValueObject.Changed:Connect(function(newRaisedAmount)
        if newRaisedAmount > lastRaisedValue then
            updateStatus(string.format("Donate! Raised: %d -> %d", lastRaisedValue, newRaisedAmount))
            lastRaisedValue = newRaisedAmount
            
            countdownShouldReset = true
            
            print("[ServerHop] Cờ reset đã được đặt do có donate.")
        end
    end)
end)


-- --- Khởi chạy Script ---

-- Disable 3D rendering and set FPS cap
-- Note: setfpscap might be a debug-only function or specific to certain exploiters.
-- If it's not standard, this line might error or do nothing in a regular environment.
pcall(function()
    RunService:Set3dRenderingEnabled(false)
    if setfpscap then -- Check if setfpscap exists
        setfpscap(5)
        print("[ServerHop] 3D Rendering Disabled. FPS Cap set to 5.")
    else
        print("[ServerHop] 3D Rendering Disabled. 'setfpscap' not available.")
    end
end)

updateStatus("...") -- Văn bản khởi tạo ngắn gọn
task.wait(1) -- Giảm thời gian chờ ban đầu
print("[ServerHop] Thời gian chờ mặc định trước khi tìm server: " .. DEFAULT_WAIT_MINUTES .. " phút.")
startInitialCountdown()
