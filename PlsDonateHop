local SETTINGS = {
    -- =================================================================
    -- C√ÄI ƒê·∫∂T N√â NG∆Ø·ªúI CH∆†I (T·ª™ SCRIPT B)
    -- =================================================================
    ["EnableAvoidPlayers"] = true, -- B·∫≠t/t·∫Øt t√≠nh nƒÉng n√© t√†i kho·∫£n
    ["AVOID_PLAYERS"] = {
        "HelloPlayer1st",
        "Er1ka_iA",
        "WolfCodeFusion", 
        "ArrowStarHaz3",
        "Sab3r_Aqua2007",
        "XxJacksonUltraxX14",
        "XxAlpha_ZAPXX2007",
        "Xx_Isab3llaRiftF",
        "Aria_Duck2019",
        "XxNightRogueLuck",
        "LuckyCookieAce",
        "XxZaydenPixelxX2"
    },

    -- =================================================================
    -- C√ÄI ƒê·∫∂T CH·ªêNG BOT
    -- =================================================================
    ["EnableAntiBotScan"] = true,
    ["BOT_KEYWORDS"] = { "spin", "afk", "restaurant", "jump", "gift", "speed", "develop", "streaming", "live", "game", "#", "dream", "first", "mom", "big" },
    ["DETECTION_THRESHOLD"] = 4,

    -- =================================================================
    -- C√ÄI ƒê·∫∂T SERVER HOP & AFK
    -- =================================================================
    ["WaitMinutes"] = 10,
    ["MaxServerHistorySize"] = 500,
    ["EnableSharedServerCache"] = true, -- [M·ªöI T·ª™ D] B·∫≠t/t·∫Øt cache server d√πng chung
    ["EnablePlayerCountCheck"] = true,
    ["MinPlayerThreshold"] = 10,
    ["EnableServerHop"] = true,
    ["EnableSafePlatform"] = true,
    ["EnableStaticAfkView"] = true, -- ƒêi·ªÅu khi·ªÉn camera m·ªõi
    ["EnableDonateReset"] = true,
    
    -- =================================================================
    -- C√ÄI ƒê·∫∂T TH√îNG B√ÅO DISCORD
    -- =================================================================
    ["EnableDiscordWebhook"] = true,
    ["WebhookURL"] = "https://discord.com/api/webhooks/1397368466947969147/HbncMuT0ETe6_5q_kKGzkdd7guLfiGqvewr3WuBFfHAxKBJo3TA7R6ad2ex31YkBHo75",
    ["WebhookColor"] = 16738740,
    ["EnablePingOnDonate"] = true,
    ["PingAmount"] = 1000,
    ["PingUserID"] = "",

    -- =================================================================
    -- C√ÄI ƒê·∫∂T T·ª∞ ƒê·ªòNG TR·∫¢ L·ªúI & CHAT
    -- =================================================================
    ["EnableAutoReply"] = true,
    ["ReplyRadius"] = 25,
    ["ReplyCooldown"] = 7,
    ["ReplyRules"] = {
        { keywords = { "hi", "hello", "hey", "sup", "yo", "wsg", "howdy", "greetings", "wassup", "heya" }, replies = { "Hello!", "Hi there", "Hey!", "Yo", "What's up?", "Heya", "Sup", "Heyo!", "What's good?", "Well hello there." } },
        { keywords = { "only","donate", "pls", "give me", "robux pls", "can i have", "spare", "some robux", "can u donate", "plz donate", "can you give", "i need robux" }, replies = { "Sorry, I'm saving up right now.", "I can't donate at the moment, sorry.", "My robux is pending, can't help sorry.", "Sry, saving for something specific.", "Maybe later, I'm trying to reach my own goal.", "Can't right now, good luck though!", "All my robux is tied up, sorry.", "Sorry, my wallet is on a diet.", "I wish I could, but I'm broke lol." } },
        { keywords = { "bot", "auto", "script", "scripter", "macro", "afk farm", "autoclicker", "you a bot?" }, replies = { "I'm not a bot :)", "lol no, I'm a real player.", "Just vibing, not a bot.", "Beep boop? Nah, just kidding.", "I'm a human, I promise!", "Not a script, just dedicated lol.", "Do I look like a bot to you? :P", "Last time I checked, I still need to sleep. So, not a bot.", "01001110 01101111. (That means 'No' in binary)." } },
        { keywords = { "scam", "fake", "report", "scammer", "this is a scam", "don't trust", "he's a scammer", "is this fake" }, replies = { "This is not a scam.", "I'm not a scammer.", "It's legit, no worries.", "100% legit, my friend.", "No scams here, just good vibes.", "I'm just here to play the game like you.", "Why would you think it's a scam?", "The only thing I'm scamming is time, by playing this game.", "You've got the wrong person, I'm just here to chill." } },
        { keywords = { "why are you", "how are you", "spinning", "jumping", "afk" }, replies = { "Just farming for my goal.", "It's part of the grind.", "Doing this for donations." } },
    },

        ["EnableAutoThank"] = true, -- B·∫≠t/t·∫Øt t·ª± ƒë·ªông c·∫£m ∆°n khi ƒë∆∞·ª£c donate
    ["ThankYouMessages"] = {    -- Danh s√°ch c√°c tin nh·∫Øn c·∫£m ∆°n
        "Thanks for the donation!",
        "Tysm!!",
        "Thank you so much!",
        "OMG THANKKK!",
        "THANKS",
        "TYSM!"
    },

    ["EnableAutoSpam"] = true, -- B·∫≠t/t·∫Øt t·ª± ƒë·ªông spam tin nh·∫Øn
    ["SpamInterval"] = 60, -- Th·ªùi gian (gi√¢y) gi·ªØa m·ªói l·∫ßn chat
    ["SpamMessages"] = {    -- Danh s√°ch c√°c tin nh·∫Øn ƒë·ªÉ spam
        "Goal: MAX SPIN LEVEL 100üåÄ - 1 ROBUX = +1 SPEED!",
        "Goal: MAX SPIN LEVEL 100üåÄ - 1 ROBUX = +1 SPEED!"
    },

    -- =================================================================
    -- C√ÄI ƒê·∫∂T BOOTH & SPIN
    -- =================================================================
    ["EnableBoothFeatures"] = true, -- B·∫≠t/t·∫Øt to√†n b·ªô t√≠nh nƒÉng booth (claim, text, spin)
    ["boothTextFormat"] = "1 DONATE = 1 SPIN SPEED\nGOAL: $GOALK SPEED!", -- [M·ªöI] ƒê·ªãnh d·∫°ng vƒÉn b·∫£n. $GOALK s·∫Ω ƒë∆∞·ª£c thay th·∫ø b·∫±ng m·ª•c ti√™u (v√≠ d·ª•: 12K)
    ["hexBox"] = "#ffffff", -- M√†u vƒÉn b·∫£n (HEX)
    ["fontFace"] = "SciFi", -- Font ch·ªØ (xem Enum.Font)
    ["boothOffset"] = 3, -- Kho·∫£ng c√°ch ƒë·ª©ng tr∆∞·ªõc booth
    ["spinEnabled"] = true, -- B·∫≠t/t·∫Øt xoay
    ["spinBaseSpeed"] = 0.4, -- T·ªëc ƒë·ªô xoay c∆° b·∫£n
    ["spinSpeedPerR"] = 0.1, -- T·ªëc ƒë·ªô c·ªông th√™m cho m·ªói Robux ƒë∆∞·ª£c donate

    -- =================================================================
    -- C√ÄI ƒê·∫∂T HI·ªÜU NƒÇNG & KH√ÅC
    -- =================================================================
    ["EnableGraphicsOptimization"] = true,
    ["EnableCpuOptimization"] = true,
    ["SetSimulationRadiusToZero"] = true,
    ["TargetFps"] = 7,
    ["EnableFileHistory"] = true,
    ["InitialWaitTime"] = 1,
    ["EnableCountdownText"] = true,
    ["EnableCountdownColor"] = true,
}
-- --- K·∫æT TH√öC C√ÄI ƒê·∫∂T ---

-- N·ªÅn t·∫£ng an to√†n (Anti-Cheat Bypass)
local identifyexecutor = identifyexecutor or function() return 'Unknown' end
local cloneref = (identifyexecutor() ~= "Synapse Z" and not identifyexecutor():find("Codex") and cloneref) or function(o) return o end

-- C√°c service c·∫ßn thi·∫øt
local Players = cloneref(game:GetService("Players"))
local TeleportService = cloneref(game:GetService("TeleportService"))
local HttpService = cloneref(game:GetService("HttpService"))
local TextChatService = cloneref(game:GetService("TextChatService"))
local Workspace = cloneref(game:GetService("Workspace"))
local Lighting = cloneref(game:GetService("Lighting"))
local SoundService = cloneref(game:GetService("SoundService"))
local RunService = cloneref(game:GetService("RunService"))
local CoreGui = cloneref(game:GetService("CoreGui"))
local ReplicatedStorage = cloneref(game:GetService("ReplicatedStorage"))
local rng = Random.new() -- [M·ªöI T·ª™ D]
local LocalPlayer = Players.LocalPlayer

-- --- C·∫•u h√¨nh Script (Kh√¥ng n√™n thay ƒë·ªïi) ---
local placeId = game.PlaceId; local currentJobId = game.JobId; local PLATFORM_VERTICAL_OFFSET = 0; local SERVER_HISTORY_FILENAME = "server_hop_history.txt"; local SHARED_SERVER_CACHE_FILENAME = "shared_server_cache.txt"; local NECO_SERVER_LIST_FILENAME = "neco.txt"
local SERVER_HOP_GUI_NAME = "ServerHopStatusGUI"; local AFK_PLATFORM_NAME = "MySafeAFKPlatform"; local NEON_COLORS = { GREEN = Color3.fromRGB(10, 255, 20), YELLOW = Color3.fromRGB(255, 255, 0), BLUE = Color3.fromRGB(0, 150, 255), RED = Color3.fromRGB(255, 20, 20) }

-- --- Bi·∫øn to√†n c·ª•c ---
local playerGui = LocalPlayer and LocalPlayer:WaitForChild("PlayerGui")
local statusScreenGui, statusTextLabel, statusFrame
local countdownShouldReset = false; local currentCountdownThread = nil; local playerMonitorThread = nil
local Remotes = nil; local spinVelocity = SETTINGS.spinBaseSpeed or 0.25
local serverHistoryCache = {}
local isRateLimited = false
local isHoppingFromCache = false 
local isHoppingFromNeco = false
local cachedCandidateServers = {}
local necoCandidateServers = {}

-- --- Ki·ªÉm tra v√† g√°n h√†m ƒë·ªçc/ghi file ---
local canAccessFiles = false; local writefile_func, readfile_func; if SETTINGS.EnableFileHistory then pcall(function() if writefile and readfile then canAccessFiles, writefile_func, readfile_func = true, writefile, readfile; print("[FileIO] Quy·ªÅn file c√≥ s·∫µn.") else print("[FileIO] Quy·ªÅn file KH√îNG c√≥ s·∫µn.") end end) else print("[FileIO] L·ªãch s·ª≠ file b·ªã T·∫ÆT.") end

-- =================================================================
-- H·ªÜ TH·ªêNG GIAO DI·ªÜN
-- =================================================================
local function createStatusGui() if playerGui:FindFirstChild(SERVER_HOP_GUI_NAME) then playerGui[SERVER_HOP_GUI_NAME]:Destroy() end; statusScreenGui = Instance.new("ScreenGui"); statusScreenGui.Name = SERVER_HOP_GUI_NAME; statusScreenGui.ResetOnSpawn, statusScreenGui.ZIndexBehavior, statusScreenGui.IgnoreGuiInset = false, Enum.ZIndexBehavior.Sibling, true; statusScreenGui.Parent = playerGui; statusFrame = Instance.new("Frame"); statusFrame.Name = "StatusFrame"; statusFrame.Size = UDim2.new(1, 0, 1, 0); statusFrame.BackgroundColor3, statusFrame.BorderSizePixel = NEON_COLORS.GREEN, 0; statusFrame.BackgroundTransparency = 1; statusFrame.ZIndex = 1; statusFrame.Parent = statusScreenGui; local FIXED_TEXT_SIZE = 50; statusTextLabel = Instance.new("TextLabel"); statusTextLabel.Name = "StatusLabel"; statusTextLabel.Size = UDim2.new(0.9, 0, 0, FIXED_TEXT_SIZE + 80); statusTextLabel.Position = UDim2.new(0.5, 0, 0.5, 0); statusTextLabel.AnchorPoint = Vector2.new(0.5, 0.5); statusTextLabel.BackgroundTransparency = 1; statusTextLabel.TextColor3 = Color3.new(1, 1, 1); statusTextLabel.Font = Enum.Font.SourceSansSemibold; statusTextLabel.TextScaled = false; statusTextLabel.TextSize = FIXED_TEXT_SIZE - 15; statusTextLabel.TextXAlignment, statusTextLabel.TextYAlignment = Enum.TextXAlignment.Center, Enum.TextYAlignment.Center; statusTextLabel.TextWrapped = true; statusTextLabel.Text = "..."; statusTextLabel.ZIndex = 2; statusTextLabel.Parent = statusScreenGui end
local function updateDisplay(state, message) task.spawn(function() print("[UI] " .. tostring(message)); if not statusTextLabel or not statusTextLabel.Parent then return end; local stateColor = NEON_COLORS.GREEN; if state == "ERROR" then stateColor = NEON_COLORS.YELLOW elseif state == "BOT_DETECTED" then stateColor = NEON_COLORS.RED end; statusTextLabel.Text = tostring(message); statusTextLabel.TextColor3 = stateColor; if SETTINGS.EnableCountdownColor then if statusFrame and statusFrame.Parent then if state == "SUCCESS" or state == "ERROR" or state == "BOT_DETECTED" then statusFrame.BackgroundColor3 = stateColor; statusFrame.BackgroundTransparency = 0.5 else statusFrame.BackgroundTransparency = 1 end end else if statusFrame then statusFrame.BackgroundTransparency = 1 end end end) end

-- =================================================================
-- C√ÅC H√ÄM TI·ªÜN √çCH (LOGIC M·ªöI T·ª™ D)
-- =================================================================
-- --- Ti·ªán √≠ch File (T·ª™ D) ---
local function loadServerHistoryOnce()
    if not canAccessFiles then 
        print("[History] Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p file, l·ªãch s·ª≠ s·∫Ω ch·ªâ t·ªìn t·∫°i trong phi√™n n√†y.")
        serverHistoryCache = {}
        return
    end
    
    local historySet = {}
    local success, content = pcall(readfile_func, SERVER_HISTORY_FILENAME)
    if success and content then
        for line in string.gmatch(content, "[^" .. "\r\n" .. "]+") do
            local trimmedLine = line:match("^%s*(.-)%s*$")
            if trimmedLine and #trimmedLine > 0 then
                historySet[trimmedLine] = true
            end
        end
    end
    
    local historySize = 0
    for _ in pairs(historySet) do historySize = historySize + 1 end
    
    local maxSize = SETTINGS.MaxServerHistorySize
    if maxSize and maxSize > 0 and historySize >= maxSize then
        print(string.format("[History] L·ªãch s·ª≠ ƒë·∫°t gi·ªõi h·∫°n (%d/%d). ƒêang x√≥a...", historySize, maxSize))
        updateDisplay("INFO", "L·ªãch s·ª≠ server ƒë·∫ßy, ƒëang reset...")
        historySet = {}
        pcall(writefile_func, SERVER_HISTORY_FILENAME, "")
        print("[History] L·ªãch s·ª≠ file ƒë√£ ƒë∆∞·ª£c x√≥a.")
        task.wait(2)
    end
    
    serverHistoryCache = historySet
    print(string.format("[History] ƒê√£ t·∫£i %d server t·ª´ l·ªãch s·ª≠ v√†o b·ªô nh·ªõ.", historySize))
end

local function saveServerHistoryToFile()
    if not canAccessFiles then return end
    
    local serverIds = {}
    for id in pairs(serverHistoryCache) do
        table.insert(serverIds, id)
    end
    
    local success, err = pcall(writefile_func, SERVER_HISTORY_FILENAME, table.concat(serverIds, "\n"))
    if not success then
        print("[History] L·ªñI: Kh√¥ng th·ªÉ ghi l·ªãch s·ª≠ ra file: " .. tostring(err))
    else
        print("[History] ƒê√£ l∆∞u l·ªãch s·ª≠ c·∫≠p nh·∫≠t ra file.")
    end
end

local function saveServersToSharedCache(serverList)
    if not canAccessFiles or not SETTINGS.EnableSharedServerCache or not serverList then return end

    local validServerIds = {}
    for _, server in ipairs(serverList) do
        if server.id ~= currentJobId and not serverHistoryCache[server.id] then
            table.insert(validServerIds, server.id)
        end
    end

    if #validServerIds > 0 then
        local success, err = pcall(writefile_func, SHARED_SERVER_CACHE_FILENAME, table.concat(validServerIds, "\n"))
        if success then
            print(string.format("[SharedCache] ƒê√£ l∆∞u %d server h·ª£p l·ªá v√†o cache chung.", #validServerIds))
        else
            print("[SharedCache] L·ªñI: Kh√¥ng th·ªÉ ghi file cache chung: " .. tostring(err))
        end
    end
end

local function loadServersFromSharedCache()
    if not canAccessFiles or not SETTINGS.EnableSharedServerCache then return {} end

    local cachedIds = {}
    local success, content = pcall(readfile_func, SHARED_SERVER_CACHE_FILENAME)
    if success and content then
        for line in string.gmatch(content, "[^" .. "\r\n" .. "]+") do
            local trimmedLine = line:match("^%s*(.-)%s*$")
            if trimmedLine and #trimmedLine > 0 then
                table.insert(cachedIds, trimmedLine)
            end
        end
        print(string.format("[SharedCache] ƒê√£ t·∫£i %d server t·ª´ cache chung.", #cachedIds))
    end
    return cachedIds
end

local function loadNecoServers()
    if not canAccessFiles then return {} end

    local necoIds = {}
    local success, content = pcall(readfile_func, NECO_SERVER_LIST_FILENAME)
    if success and content then
        for line in string.gmatch(content, "[^" .. "\r\n" .. "]+") do
            local trimmedLine = line:match("^%s*(.-)%s*$")
            if trimmedLine and #trimmedLine > 0 and trimmedLine ~= currentJobId and not serverHistoryCache[trimmedLine] then
                table.insert(necoIds, trimmedLine)
            end
        end
        print(string.format("[Neco] ƒê√£ t·∫£i %d server h·ª£p l·ªá t·ª´ %s.", #necoIds, NECO_SERVER_LIST_FILENAME))
    end
    return necoIds
end

-- --- Ti·ªán √≠ch T·ªëi ∆∞u ---
local function createSafePlatform() updateDisplay("INFO", "ƒêang t·∫°o platform..."); if game.Workspace:FindFirstChild(AFK_PLATFORM_NAME) then updateDisplay("INFO", "Platform ƒë√£ c√≥."); return end; local p=Instance.new("Part");p.Name=AFK_PLATFORM_NAME;p.Anchored=true;p.CanCollide=true;p.Size=Vector3.new(20000,40,20000);p.Color=Color3.fromRGB(50,50,50);p.Transparency=0; local char=LocalPlayer.Character; local hum=char and char:FindFirstChildOfClass("Humanoid"); local hrp=char and char:FindFirstChild("HumanoidRootPart"); if hum and hrp then local hrpP=hrp.Position;local hrpSY=hrp.Size.Y;local hipH=hum.HipHeight;local fCIY=hrpP.Y-(hrpSY/2)-hipH;local pTTY=fCIY-PLATFORM_VERTICAL_OFFSET;local pCY=pTTY-(p.Size.Y/2);p.Position=Vector3.new(hrpP.X,pCY,hrpP.Z); else p.Position=Vector3.new(0,-30-PLATFORM_VERTICAL_OFFSET,0); end; p.Parent=game.Workspace; updateDisplay("SUCCESS", "Platform ƒë√£ t·∫°o."); end

-- Logic camera m·ªõi t·ª´ script C
local function setupFacialCameraAndFreeze()
    updateDisplay("INFO", "Thi·∫øt l·∫≠p camera v√† ƒë√≥ng bƒÉng animation...")
    local player = LocalPlayer
    local char = player.Character or player.CharacterAdded:Wait()
    if not char then return end
    local humanoid = char:WaitForChild("Humanoid")
    local root = char:WaitForChild("HumanoidRootPart")

    local animate = char:FindFirstChild("Animate")
    if animate then
        animate.Disabled = true
    end

    if humanoid then
        humanoid.AutoRotate = false
    end

    local camera = workspace.CurrentCamera
    camera.CameraType = Enum.CameraType.Scriptable

    local forwardOffset = 6
    local heightOffset = 2

    RunService.RenderStepped:Connect(function()
        if root and root.Parent and humanoid and humanoid.Health > 0 then
            local look = root.CFrame.LookVector
            local targetPos = root.Position + Vector3.new(0, heightOffset, 0)
            local camPos = targetPos + look * forwardOffset
            camera.CFrame = CFrame.new(camPos, targetPos)
        end
    end)
    updateDisplay("SUCCESS", "Camera v√† animation ƒë√£ ƒë∆∞·ª£c thi·∫øt l·∫≠p.")
end

local function optimizeForCpu() if not SETTINGS.EnableCpuOptimization then return end; updateDisplay("INFO", "B·∫Øt ƒë·∫ßu t·ªëi ∆∞u h√≥a CPU..."); pcall(function() if type(setfpscap) == "function" and SETTINGS.TargetFps and SETTINGS.TargetFps > 0 then print("[CPU-Opt] Gi·ªõi h·∫°n FPS ƒëang ho·∫°t ƒë·ªông ·ªü m·ª©c: " .. tostring(SETTINGS.TargetFps)) end; if SETTINGS.SetSimulationRadiusToZero then if LocalPlayer then LocalPlayer.SimulationRadius = 0; print("[CPU-Opt] SimulationRadius ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t v·ªÅ 0.") end end end); updateDisplay("SUCCESS", "T·ªëi ∆∞u h√≥a CPU ho√†n t·∫•t.") end
local function optimizeGraphics() updateDisplay("INFO", "B·∫Øt ƒë·∫ßu t·ªëi ∆∞u ƒë·ªì h·ªça..."); if SETTINGS.EnableSafePlatform then createSafePlatform(); end; task.wait(0.1); pcall(function() local itemsToDel={}; for _,item in pairs(game.Workspace:GetChildren()) do local keep=(LocalPlayer.Character and item.Name==LocalPlayer.Character.Name)or(item==workspace.CurrentCamera)or(SETTINGS.EnableSafePlatform and item.Name==AFK_PLATFORM_NAME);if not keep then table.insert(itemsToDel,item)end end; for _,item in ipairs(itemsToDel)do pcall(function()item:Destroy()end)end;Lighting.GlobalShadows,Lighting.Brightness,Lighting.Ambient,Lighting.OutdoorAmbient,Lighting.ExposureCompensation=false,0,Color3.new(0,0,0),Color3.new(0,0,0),-2;pcall(function()Lighting.Atmosphere:Destroy()end);pcall(function()Lighting.Sky:Destroy()end); if LocalPlayer.PlayerGui then for _,gui in pairs(LocalPlayer.PlayerGui:GetChildren())do if gui.Name~=SERVER_HOP_GUI_NAME then pcall(function()gui:Destroy()end)end end end;local sO=settings();if sO and sO.Rendering then sO.Rendering.QualityLevel=Enum.QualityLevel.Level01;pcall(function()if RunService:IsClient()then RunService:Set3dRenderingEnabled(false)end end)end;SoundService.RespectFilteringEnabled,SoundService.AmbientReverb=true,Enum.ReverbType.NoReverb;for _,sound in pairs(game:GetDescendants())do if sound:IsA("Sound")then sound.Volume=0;sound:Stop()end end; end); updateDisplay("SUCCESS", "ƒê·ªì h·ªça ƒë√£ ƒë∆∞·ª£c t·ªëi ∆∞u."); end

-- --- Ti·ªán √≠ch Booth ---
local function rgb(hex) hex = hex:gsub("#", ""); local r = tonumber("0x" .. hex:sub(1, 2)) or 255; local g = tonumber("0x" .. hex:sub(3, 4)) or 255; local b = tonumber("0x" .. hex:sub(5, 6)) or 255; return Color3.fromRGB(r, g, b) end
local function formatNumber(n) if n >= 10000 then return string.format("%.1fk", n / 1000) elseif n >= 1000 then return string.format("%.2fk", n / 1000) else return tostring(n) end end

-- =================================================================
-- LOGIC T√åM SERVER (HO√ÄN TO√ÄN T·ª™ SCRIPT D)
-- =================================================================
local candidateServers = {}
local nextServerCursor = nil
local currentRetryDelay = 5
local tryNextServer
local tryNextCachedServer
local tryNextNecoServer
local searchForServer
local fetchNextBatch

local function prepareToHop()
    print("[ServerHop] Preparing to hop servers...")
    if currentCountdownThread and coroutine.status(currentCountdownThread) ~= "dead" then
        pcall(coroutine.close, currentCountdownThread);
        currentCountdownThread = nil
    end
    if playerMonitorThread and coroutine.status(playerMonitorThread) ~= "dead" then
        pcall(coroutine.close, playerMonitorThread);
        playerMonitorThread = nil
    end
    serverHistoryCache[currentJobId] = true
    print(string.format("[History] JobId %s... ƒë√£ th√™m v√†o cache b·ªô nh·ªõ.", string.sub(currentJobId, 1, 8)))
    saveServerHistoryToFile()
end

local function executeTeleport(jobId)
    updateDisplay("SUCCESS", string.format("Server ƒë∆∞·ª£c ch·ªçn!\nƒêang v√†o: %s...", jobId:sub(1, 12)))
    task.wait(0.5)
    print(string.format("[Teleport] B·∫Øt ƒë·∫ßu d·ªãch chuy·ªÉn ƒë·∫øn Job ID: %s", jobId))
    pcall(function()
        TeleportService:TeleportToPlaceInstance(game.PlaceId, jobId, Players.LocalPlayer)
    end)
end

tryNextCachedServer = function()
    if #cachedCandidateServers > 0 then
        local targetServerId = table.remove(cachedCandidateServers, 1)
        updateDisplay("INFO", string.format("Th·ª≠ server t·ª´ cache: %s... (%d c√≤n l·∫°i)", targetServerId:sub(1, 12), #cachedCandidateServers))
        executeTeleport(targetServerId)
    else
        updateDisplay("ERROR", "ƒê√£ th·ª≠ h·∫øt server trong cache. T·∫•t c·∫£ ƒë·ªÅu l·ªói.")
        updateDisplay("INFO", "Quay l·∫°i qu√©t API ƒë·ªÉ l·∫•y server m·ªõi...")
        isHoppingFromCache = false 
        isRateLimited = false      
        task.wait(1)               
        fetchNextBatch()          
    end
end

-- =================================================================
-- [N√ÇNG C·∫§P] LOGIC CH·ªåN SERVER NG·∫™U NHI√äN T·ª™ NECO.TXT
-- =================================================================
tryNextNecoServer = function()
    if #necoCandidateServers > 0 then
        -- CH·ªåN NG·∫™U NHI√äN: L·∫•y m·ªôt index ng·∫´u nhi√™n t·ª´ danh s√°ch server c√≤n l·∫°i
        local randomIndex = rng:NextInteger(1, #necoCandidateServers)
        local targetServerId = necoCandidateServers[randomIndex]

        -- X√ìA SERVER ƒê√É CH·ªåN: Lo·∫°i b·ªè server kh·ªèi danh s√°ch ƒë·ªÉ kh√¥ng th·ª≠ l·∫°i
        table.remove(necoCandidateServers, randomIndex)
        
        updateDisplay("INFO", string.format("Th·ª≠ server Neco ng·∫´u nhi√™n: %s... (%d c√≤n l·∫°i)", targetServerId:sub(1, 12), #necoCandidateServers))
        executeTeleport(targetServerId)
    else
        -- KHI H·∫æT SERVER: Quay l·∫°i lu·ªìng t√¨m server b√¨nh th∆∞·ªùng
        isHoppingFromNeco = false
        updateDisplay("ERROR", "H·∫øt server trong neco.txt ƒë·ªÉ th·ª≠.")
        searchForServer() 
    end
end

function persistentFetch(url)
    local success, response = false, nil
    repeat
        local pcallSuccess, pcallResponse = pcall(function() return HttpService:JSONDecode(game:HttpGet(url, true)) end)
        if pcallSuccess and pcallResponse and pcallResponse.data then
            success, response = true, pcallResponse
            currentRetryDelay = 5
        else
            local wasRateLimited = false
            if pcallSuccess and pcallResponse and pcallResponse.errors and pcallResponse.errors[1] and pcallResponse.errors[1].message and string.find(string.lower(pcallResponse.errors[1].message), "too many requests") then
                wasRateLimited = true
            end

            if wasRateLimited then
                isRateLimited = true
                updateDisplay("ERROR", "B·ªã gi·ªõi h·∫°n (429). Th·ª≠ d√πng cache chung...")
                
                local allCachedServers = loadServersFromSharedCache()
                
                local freshCachedServers = {}
                for _, serverId in ipairs(allCachedServers) do
                    if serverId ~= currentJobId and not serverHistoryCache[serverId] then
                        table.insert(freshCachedServers, serverId)
                    end
                end
                
                cachedCandidateServers = freshCachedServers 
                
                if #cachedCandidateServers > 0 then
                    updateDisplay("INFO", string.format("ƒê√£ l·ªçc cache. B·∫Øt ƒë·∫ßu th·ª≠ %d server h·ª£p l·ªá.", #cachedCandidateServers))
                    
                    for i = #cachedCandidateServers, 2, -1 do
                        local j = rng:NextInteger(1, i)
                        cachedCandidateServers[i], cachedCandidateServers[j] = cachedCandidateServers[j], cachedCandidateServers[i]
                    end
                    isHoppingFromCache = true
                    tryNextCachedServer()
                    return nil
                else
                    updateDisplay("ERROR", "Cache chung r·ªóng ho·∫∑c ƒë√£ v√†o h·∫øt. Ph·∫£i ch·ªù 30 gi√¢y...")
                    task.wait(30)
                    isRateLimited = false
                    updateDisplay("INFO", "H·∫øt th·ªùi gian gi·ªõi h·∫°n. Th·ª≠ qu√©t l·∫°i...")
                end
            else
                updateDisplay("ERROR", "L·ªói qu√©t. Th·ª≠ l·∫°i sau " .. currentRetryDelay .. "s...")
                task.wait(currentRetryDelay)
                currentRetryDelay = math.min(currentRetryDelay * 2, 60)
            end
        end
    until success
    return response
end

fetchNextBatch = function()
    updateDisplay("INFO", "ƒêang qu√©t 100 server ti·∫øp theo...")
    
    local apiUrl = "https://games.roblox.com/v1/games/" .. placeId .. "/servers/Public?sortOrder=Desc&limit=100&excludeFullGames=true"
    if nextServerCursor then
        apiUrl = apiUrl .. "&cursor=" .. nextServerCursor
    end

    local response = persistentFetch(apiUrl)
    if not response then return end

    if response and response.data and #response.data > 0 then
        saveServersToSharedCache(response.data)
        nextServerCursor = response.nextPageCursor
        
        local newCandidatesCount = 0
        local ignoredHistoryCount = 0
        
        for _, server in ipairs(response.data) do
            if server.id ~= currentJobId and not serverHistoryCache[server.id] then
                table.insert(candidateServers, server)
                newCandidatesCount = newCandidatesCount + 1
            else
                ignoredHistoryCount = ignoredHistoryCount + 1
            end
        end

        print(string.format("[ServerScan] Qu√©t xong. Th√™m %d server m·ªõi. B·ªè qua %d (l·ªãch s·ª≠).", newCandidatesCount, ignoredHistoryCount))
        
        if newCandidatesCount > 0 then
             updateDisplay("SUCCESS", "Qu√©t xong! T√¨m th·∫•y " .. newCandidatesCount .. " server h·ª£p l·ªá.")
             for i = #candidateServers, 2, -1 do
                  local j = rng:NextInteger(1, i)
                  candidateServers[i], candidateServers[j] = candidateServers[j], candidateServers[i]
             end
             tryNextServer()
        else
            updateDisplay("INFO", "Trang n√†y to√†n server ƒë√£ v√†o. ƒêang t√¨m trang ti·∫øp...")
            fetchNextBatch()
        end

    else
        updateDisplay("ERROR", "H·∫øt server ho·∫∑c l·ªói API. B·∫Øt ƒë·∫ßu l·∫°i t·ª´ ƒë·∫ßu sau 15s...")
        nextServerCursor = nil
        task.wait(15)
        fetchNextBatch()
    end
end

tryNextServer = function()
    if #candidateServers == 0 then
        if not isRateLimited then
            fetchNextBatch()
        end
    else
        local targetServer = table.remove(candidateServers, 1)
        executeTeleport(targetServer.id)
    end
end

searchForServer = function()
    prepareToHop()
    isHoppingFromNeco = false
    isHoppingFromCache = false

    necoCandidateServers = loadNecoServers()
    if #necoCandidateServers > 0 then
        isHoppingFromNeco = true
        updateDisplay("INFO", string.format("T√¨m th·∫•y %d server trong neco.txt.\nB·∫Øt ƒë·∫ßu ch·ªçn ng·∫´u nhi√™n...", #necoCandidateServers))
        tryNextNecoServer()
    else
        updateDisplay("INFO", "neco.txt r·ªóng ho·∫∑c ƒë√£ v√†o h·∫øt.\nB·∫Øt ƒë·∫ßu t√¨m server t·ª´ API...")
        candidateServers = {}
        nextServerCursor = nil
        currentRetryDelay = 5
        tryNextServer() 
    end
end

TeleportService.TeleportInitFailed:Connect(function(player, teleportResult, errorMessage)
    if not SETTINGS.EnableServerHop then return end

    local reason = "L√Ω do kh√¥ng x√°c ƒë·ªãnh"
    if teleportResult == Enum.TeleportResult.GameFull then
        reason = "Server ƒë·∫ßy!"
    elseif teleportResult == Enum.TeleportResult.Flooded then
        reason = "Thao t√°c qu√° nhanh!"
    else
        reason = errorMessage
    end
    
    -- =================================================================
    -- [N√ÇNG C·∫§P] X·ª¨ L√ù L·ªñI KHI D·ªäCH CHUY·ªÇN T·ªöI SERVER NECO NG·∫™U NHI√äN
    -- =================================================================
    if isHoppingFromNeco then
        updateDisplay("ERROR", "Neco teleport th·∫•t b·∫°i: " .. reason)
        -- CH·ªà C·∫¶N G·ªåI L·∫†I: H√†m tryNextNecoServer s·∫Ω t·ª± ƒë·ªông ch·ªçn m·ªôt server ng·∫´u nhi√™n kh√°c t·ª´ danh s√°ch ƒë√£ b·ªã r√∫t g·ªçn.
        updateDisplay("INFO", "Th·ª≠ server Neco ng·∫´u nhi√™n kh√°c sau 0.5s...") 
        task.wait(0.5)
        tryNextNecoServer() 
        return 
    end

    updateDisplay("ERROR", "D·ªãch chuy·ªÉn th·∫•t b·∫°i: " .. reason)
    updateDisplay("INFO", "T√¨m server kh√°c sau 0.5 gi√¢y...")
    task.wait(0.5)

    if isHoppingFromCache then
        print("[Teleport] L·ªói khi hop t·ª´ cache. Th·ª≠ server cache ti·∫øp theo.")
        tryNextCachedServer()
    else
        print("[Teleport] L·ªói khi hop b√¨nh th∆∞·ªùng. Th·ª≠ server API ti·∫øp theo.")
        tryNextServer()
    end
end)

-- =================================================================
-- H·ªÜ TH·ªêNG BOOTH & SPIN
-- =================================================================
local function findRemotes()
    if Remotes then return true end
    updateDisplay("INFO", "ƒêang t√¨m Remotes...")
    for _, v in next, ReplicatedStorage:GetChildren() do
        if v:IsA("ModuleScript") and v.Name:find("Remote") then
            local ok = pcall(function() require(v).Event("PromotionBlimpGiftbux"):FireServer() end)
            if ok then
                Remotes = require(v)
                updateDisplay("SUCCESS", "ƒê√£ t√¨m th·∫•y Remotes.")
                return true
            end
        end
    end
    updateDisplay("ERROR", "Kh√¥ng t√¨m th·∫•y Remotes module.")
    return false
end

local function updateBoothText()
    if not SETTINGS.EnableBoothFeatures or not Remotes then return end
    local stats = LocalPlayer:FindFirstChild("leaderstats")
    local raisedObj = stats and stats:FindFirstChild("Raised")
    if not raisedObj then return end

    local raised = raisedObj.Value
    
    local goal = math.floor(raised / 1000) + 1
    local text = SETTINGS.boothTextFormat:gsub("%$GOAL", tostring(goal))

    local payload = {
        text = text,
        textFont = Enum.Font[SETTINGS.fontFace],
        richText = true,
        strokeColor = Color3.new(0, 0, 0),
        strokeOpacity = 0,
        textColor = rgb(SETTINGS.hexBox),
        buttonStrokeColor = Color3.new(0, 0, 0),
        buttonTextColor = Color3.new(1, 1, 1),
        buttonColor = Color3.fromRGB(98, 255, 0),
        buttonHoverColor = Color3.fromRGB(98, 255, 0),
        buttonLayout = ""
    }
    Remotes.Event("SetCustomization"):FireServer(payload, "booth")
    print("[Booth] VƒÉn b·∫£n ƒë√£ c·∫≠p nh·∫≠t:", text)
end

local function updateSpinSpeed()
    if not SETTINGS.EnableBoothFeatures or not SETTINGS.spinEnabled then return end
    local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    local spin = root and root:FindFirstChild("Spin")
    if spin then spin.AngularVelocity = Vector3.new(0, spinVelocity, 0) end
end

local function startSpin()
    if not SETTINGS.EnableBoothFeatures or not SETTINGS.spinEnabled then return end
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local root = char:WaitForChild("HumanoidRootPart")
    if root:FindFirstChild("Spin") then root:FindFirstChild("Spin"):Destroy() end
    local spin = Instance.new("BodyAngularVelocity")
    spin.Name = "Spin"; spin.MaxTorque = Vector3.new(0, math.huge, 0); spin.AngularVelocity = Vector3.new(0, spinVelocity, 0); spin.P = 1250; spin.Parent = root
end

local function claimAndSetupBooth()
    if not SETTINGS.EnableBoothFeatures then updateDisplay("INFO", "T√≠nh nƒÉng Booth b·ªã t·∫Øt."); return end
    if not findRemotes() then return end

    updateDisplay("INFO", "ƒêang t√¨m booth tr·ªëng...")
    local boothUI; local ok, result = pcall(function() return Workspace:WaitForChild("MapUI", 2) end); if ok and result then boothUI = result else local gui = LocalPlayer:FindFirstChild("PlayerGui"); boothUI = gui and gui:FindFirstChild("MapUIContainer") and gui.MapUIContainer:FindFirstChild("MapUI") end
    if not boothUI then updateDisplay("ERROR", "Kh√¥ng t√¨m th·∫•y MapUI ƒë·ªÉ claim booth."); return end

    local boothFrames = boothUI:WaitForChild("BoothUI"); local interactions = Workspace:WaitForChild("BoothInteractions"); local mainCheckPosition = Vector3.new(165.161, 0, 311.636); local unclaimed = {}
    for _, frame in ipairs(boothFrames:GetChildren()) do
        if frame:FindFirstChild("Details") and frame.Details.Owner.Text == "unclaimed" then
            local id = tonumber(frame.Name:match("%d+")); if id then for _, inter in ipairs(interactions:GetChildren()) do if inter:GetAttribute("BoothSlot") == id then if (Vector3.new(inter.Position.X, 0, inter.Position.Z) - mainCheckPosition).Magnitude < 92 then table.insert(unclaimed, id); break end end end end
        end
    end

    if #unclaimed == 0 then updateDisplay("ERROR", "Kh√¥ng c√≥ booth tr·ªëng."); return end
    local chosen = unclaimed[1]; local success = pcall(function() Remotes.Event("ClaimBooth"):InvokeServer(chosen); task.wait(0.3); local b = boothFrames:FindFirstChild("BoothUI" .. chosen); if not b or not string.find(b.Details.Owner.Text, LocalPlayer.DisplayName) then error() end end)
    if not success then updateDisplay("ERROR", "Claim booth th·∫•t b·∫°i."); return end

    for _, booth in ipairs(interactions:GetChildren()) do
        if booth:GetAttribute("BoothSlot") == chosen then
            local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait(); local root = char:WaitForChild("HumanoidRootPart"); local lookAt = Vector3.new(mainCheckPosition.X, root.Position.Y, mainCheckPosition.Z); local target = booth.CFrame * CFrame.new(0, 0, SETTINGS.boothOffset); root.CFrame = CFrame.new(target.Position, lookAt)
            updateDisplay("SUCCESS", "ƒê√£ claim booth #" .. chosen)
            task.wait(0.2)
            updateBoothText()
            if SETTINGS.spinEnabled then startSpin() end
            break
        end
    end
end

-- =================================================================
-- QU·∫¢N L√ù AFK & C√ÅC B·ªò L·∫ÆNG NGHE
-- =================================================================
local function safeChat(msg)
    local ChatChannel = TextChatService and TextChatService.TextChannels and TextChatService.TextChannels.RBXGeneral
    if ChatChannel then
        pcall(function() ChatChannel:SendAsync(msg) end)
    else
        print("[Chat] Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn, k√™nh chat kh√¥ng t·ªìn t·∫°i.")
    end
end

function startInitialCountdown()
    updateDisplay("INFO", "B·∫Øt ƒë·∫ßu chu tr√¨nh AFK...");
    if currentCountdownThread and coroutine.status(currentCountdownThread) ~= "dead" then pcall(coroutine.close, currentCountdownThread); currentCountdownThread = nil end
    local function performCountdownThenSearch(minutesToWait)
        if not minutesToWait or minutesToWait <= 0 then 
            updateDisplay("ERROR", "Th·ªùi gian ch·ªù l·ªói.");
            searchForServer();
            return 
        end
        if not SETTINGS.EnableCountdownText then if statusTextLabel then statusTextLabel.Text = "" end end
        if not SETTINGS.EnableCountdownColor then if statusFrame then statusFrame.BackgroundTransparency = 1 end end
        local totalS = minutesToWait * 60
        for i = totalS, 0, -1 do
            if countdownShouldReset and SETTINGS.EnableDonateReset then
                countdownShouldReset = false; if statusTextLabel then statusTextLabel.Text = "" end; if statusFrame then statusFrame.BackgroundTransparency = 1 end
                updateDisplay("SUCCESS", "Donate! Reset th·ªùi gian.")
                startInitialCountdown(); return
            end
            if SETTINGS.EnableCountdownText then if statusTextLabel and statusTextLabel.Parent then local currentPlayers = #Players:GetPlayers(); local maxPlayers = Players.MaxPlayers; local playerCountText = string.format("%d/%d", currentPlayers, maxPlayers); local timerText = string.format("%02d:%02d", math.floor(i/60), i%60); local jobIdText = "Server: " .. string.sub(currentJobId, 1, 12) .. "..."; statusTextLabel.Text = string.format("%s\n%s\n%s", timerText, playerCountText, jobIdText); statusTextLabel.TextColor3 = Color3.new(1,1,1) end end
            if SETTINGS.EnableCountdownColor then
                if statusFrame and statusFrame.Parent then
                    statusFrame.BackgroundColor3 = Color3.new(0, 0, 0)
                    statusFrame.BackgroundTransparency = 0
                end
            end
            task.wait(1)
        end
        if statusTextLabel then statusTextLabel.Text = "" end; if statusFrame then statusFrame.BackgroundTransparency = 1 end
        updateDisplay("SUCCESS", "H·∫øt gi·ªù! B·∫Øt ƒë·∫ßu t√¨m server..."); 
        searchForServer() 
    end
    currentCountdownThread = coroutine.create(function()
        local s,e = pcall(performCountdownThenSearch, SETTINGS.WaitMinutes); if not s then updateDisplay("ERROR", "L·ªói Coroutine. Th·ª≠ l·∫°i sau 5s..."); task.wait(5); if SETTINGS.EnableServerHop then startInitialCountdown() end end
    end); coroutine.resume(currentCountdownThread)
end

local function startPlayerCountMonitor()
    if not SETTINGS.EnablePlayerCountCheck or (SETTINGS.MinPlayerThreshold or 0) <= 0 then return end
    if playerMonitorThread and coroutine.status(playerMonitorThread) ~= "dead" then pcall(coroutine.close, playerMonitorThread); playerMonitorThread = nil end
    playerMonitorThread = coroutine.create(function()
        while true do
            task.wait(60); if not SETTINGS.EnablePlayerCountCheck or not SETTINGS.EnableServerHop then break end
            local currentPlayers = #Players:GetPlayers()
            if currentPlayers < SETTINGS.MinPlayerThreshold then
                updateDisplay("ERROR", string.format("Server v·∫Øng! (%d/%d ng∆∞·ªùi)\nƒêang t√¨m server m·ªõi...", currentPlayers, SETTINGS.MinPlayerThreshold))
                task.wait(3); 
                searchForServer(); 
                break
            else
                print(string.format("[PlayerMonitor] Check OK: %d/%d players.", currentPlayers, SETTINGS.MinPlayerThreshold))
            end
        end
    end); coroutine.resume(playerMonitorThread)
end

local function setupAutoReply() if not SETTINGS.EnableAutoReply then return end; local Cooldowns = {}; Players.PlayerChatted:Connect(function(_, player, message) if not SETTINGS.EnableAutoReply then return end; if player == LocalPlayer then return end; if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end; if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end; local distance = (player.Character.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude; if distance > SETTINGS.ReplyRadius then return end; if Cooldowns[player] and tick() - Cooldowns[player] < SETTINGS.ReplyCooldown then return end; local lowerMsg = string.lower(message); local replied = false; for _, rule in ipairs(SETTINGS.ReplyRules) do for _, keyword in ipairs(rule.keywords) do if string.find(lowerMsg, keyword) then local reply = rule.replies[math.random(1, #rule.replies)]; task.wait(math.random(1,3)); safeChat(reply); Cooldowns[player] = tick(); replied = true; break end end; if replied then break end end end); updateDisplay("SUCCESS", "T·ª± ƒë·ªông tr·∫£ l·ªùi ƒë√£ k√≠ch ho·∫°t.") end

local function setupAutoSpam()
    if not SETTINGS.EnableAutoSpam or not SETTINGS.SpamMessages or #SETTINGS.SpamMessages == 0 then return end
    task.spawn(function()
        updateDisplay("SUCCESS", "T√≠nh nƒÉng AutoSpam ƒë√£ k√≠ch ho·∫°t.")
        while task.wait(SETTINGS.SpamInterval) do
            if not SETTINGS.EnableAutoSpam then break end
            local message = SETTINGS.SpamMessages[math.random(1, #SETTINGS.SpamMessages)]
            safeChat(message)
            print("[AutoSpam] ƒê√£ g·ª≠i: " .. message)
        end
    end)
end

local function setupUnifiedDonationListener()
    local leaderstats = LocalPlayer:WaitForChild("leaderstats", 30)
    if not leaderstats then updateDisplay("ERROR", "Kh√¥ng t√¨m th·∫•y leaderstats sau 30 gi√¢y."); return end
    local raised = leaderstats:WaitForChild("Raised", 30)
    if not raised then updateDisplay("ERROR", "Kh√¥ng t√¨m th·∫•y 'Raised' trong leaderstats."); return end
    
    local lastRaised = raised.Value

    local function sendWebhook(amount, total)
        if not SETTINGS.EnableDiscordWebhook or not SETTINGS.WebhookURL or SETTINGS.WebhookURL == "" then return end
        local pingContent = nil; if SETTINGS.EnablePingOnDonate and amount >= (SETTINGS.PingAmount or 0) then if SETTINGS.PingUserID and SETTINGS.PingUserID ~= "" then pingContent = string.format("<@%s>", SETTINGS.PingUserID) else pingContent = "@everyone" end end
        local embed = { description = string.format("**%s**\n# +%d\nTOTAL : %d", LocalPlayer.Name, amount, total), color = SETTINGS.WebhookColor }; local payloadData = { embeds = { embed } }; if pingContent then payloadData.content = pingContent end
        local payload = HttpService:JSONEncode(payloadData); local req = (syn and syn.request) or (http and http.request) or (fluxus and fluxus.request) or request
        if req then pcall(function() req({ Url = SETTINGS.WebhookURL, Method = "POST", Headers = { ["Content-Type"] = "application/json" }, Body = payload }) end) else updateDisplay("ERROR", "[Webhook] Kh√¥ng t√¨m th·∫•y h√†m request.") end
    end

    raised.Changed:Connect(function(newRaisedValue)
        local difference = newRaisedValue - lastRaised
        if difference > 0 then
            sendWebhook(difference, newRaisedValue)
            if SETTINGS.EnableDonateReset then countdownShouldReset = true end
            if SETTINGS.EnableBoothFeatures and SETTINGS.spinEnabled then
                spinVelocity += difference * SETTINGS.spinSpeedPerR
                updateSpinSpeed()
                print("üéâ Nh·∫≠n " .. difference .. " R$ ‚Üí Spin speed: " .. string.format("%.2f", spinVelocity))
            end
            if SETTINGS.EnableAutoThank and SETTINGS.ThankYouMessages and #SETTINGS.ThankYouMessages > 0 then
                task.wait(math.random(1, 2))
                local message = SETTINGS.ThankYouMessages[math.random(1, #SETTINGS.ThankYouMessages)]
                safeChat(message)
                print("[AutoThank] ƒê√£ c·∫£m ∆°n: " .. message)
            end
        end
        lastRaised = newRaisedValue
    end)
    updateDisplay("SUCCESS", "B·ªô l·∫Øng nghe donate h·ª£p nh·∫•t ƒë√£ k√≠ch ho·∫°t.")
end

-- =================================================================
-- H√ÄM QU√âT BOT & N√â NG∆Ø·ªúI CH∆†I
-- =================================================================
local function scanForBots() updateDisplay("INFO", "B·∫Øt ƒë·∫ßu qu√©t bot..."); task.wait(2); local _boothlocation; local suc, _shuffled = pcall(function() return Workspace:WaitForChild('MapUI', 5) end); if not suc or not _shuffled then local playerGuiMap = LocalPlayer:WaitForChild("PlayerGui"); if playerGuiMap then local mapUiContainer = playerGuiMap:WaitForChild('MapUIContainer', 5); if mapUiContainer then _boothlocation = mapUiContainer:WaitForChild('MapUI', 5) end end else _boothlocation = _shuffled end; if not _boothlocation then updateDisplay("ERROR", "L·ªñI: Kh√¥ng t√¨m th·∫•y MapUI ƒë·ªÉ qu√©t bot."); return 0 end; local boothUI = _boothlocation:WaitForChild("BoothUI"); if not boothUI then updateDisplay("ERROR", "L·ªñI: Kh√¥ng t√¨m th·∫•y BoothUI b√™n trong MapUI."); return 0 end; local currentBotCount = 0; for _, uiFrame in ipairs(boothUI:GetChildren()) do local success, err = pcall(function() local ownerName = uiFrame.Details.Owner.Text; if ownerName ~= "unclaimed" then local boothText = string.lower(uiFrame.Sign.TextLabel.Text); for _, keyword in ipairs(SETTINGS.BOT_KEYWORDS) do if string.find(boothText, keyword) then currentBotCount = currentBotCount + 1; local alertMessage = string.format("PH√ÅT HI·ªÜN BOT #%d\n'%s'", currentBotCount, ownerName); updateDisplay("BOT_DETECTED", alertMessage); task.wait(2.5); break end end end end); if not success then print("[Anti-Bot] L·ªói khi qu√©t gian h√†ng: " .. tostring(err)) end end; updateDisplay("INFO", "Qu√©t xong. Ph√°t hi·ªán: " .. currentBotCount .. " bot."); task.wait(3); return currentBotCount end

local function checkAvoidPlayersOnce()
    if not SETTINGS.EnableAvoidPlayers or not SETTINGS.AVOID_PLAYERS or #SETTINGS.AVOID_PLAYERS == 0 then
        return false
    end
    local avoidNamesSet = {}
    for _, name in ipairs(SETTINGS.AVOID_PLAYERS) do
        avoidNamesSet[name] = true
    end
    local playersInServer = Players:GetPlayers()
    for _, player in ipairs(playersInServer) do
        if player.Name ~= LocalPlayer.Name and avoidNamesSet[player.Name] then
            updateDisplay("ERROR", string.format("Ph√°t hi·ªán t√†i kho·∫£n '%s'!\nƒêang t√¨m server m·ªõi...", player.Name))
            task.wait(3)
            searchForServer()
            return true
        end
    end
    print("[AvoidPlayerCheck] Qu√©t 1 l·∫ßn OK, kh√¥ng ph√°t hi·ªán t√†i kho·∫£n c·∫ßn n√©.")
    return false
end

-- =================================================================
-- LOGIC KH·ªûI CH·∫†Y CH√çNH
-- =================================================================
task.spawn(function()
    pcall(createStatusGui)
    updateDisplay("INFO", "ƒêang kh·ªüi t·∫°o...")
    task.wait(0.5)

    loadServerHistoryOnce() -- [M·ªöI T·ª™ D]

    if type(setfpscap) == "function" and SETTINGS.TargetFps and SETTINGS.TargetFps > 0 then task.spawn(function() while task.wait() do pcall(setfpscap, SETTINGS.TargetFps) end end) end
    if SETTINGS.EnableAutoReply then task.spawn(setupAutoReply) end
    if SETTINGS.EnableAutoSpam then task.spawn(setupAutoSpam) end
    
    LocalPlayer.CharacterAdded:Connect(function(character)
        task.wait(1)
        if SETTINGS.EnableBoothFeatures and SETTINGS.spinEnabled then
            startSpin()
            updateSpinSpeed()
        end
        if SETTINGS.EnableStaticAfkView then
            setupFacialCameraAndFreeze()
        end
    end)

    updateDisplay("INFO", string.format("Ch·ªù game t·∫£i trong %d gi√¢y...", SETTINGS.InitialWaitTime))
    task.wait(SETTINGS.InitialWaitTime)
    
    -- [ƒê√É S·ª¨A] Ch·∫°y song song t√°c v·ª• booth v√† t√°c v·ª• qu√©t server
    task.spawn(claimAndSetupBooth)
    task.spawn(setupUnifiedDonationListener)
    
    updateDisplay("INFO", "B·∫Øt ƒë·∫ßu lu·ªìng quy·∫øt ƒë·ªãnh...")
    
    if SETTINGS.EnableServerHop then
        local botCount = 0
        if SETTINGS.EnableAntiBotScan then botCount = scanForBots() end

        if SETTINGS.EnableAntiBotScan and botCount >= SETTINGS.DETECTION_THRESHOLD then
            updateDisplay("ERROR", string.format("Ph√°t hi·ªán %d/%d bot!\nƒêang t√¨m server m·ªõi...", botCount, SETTINGS.DETECTION_THRESHOLD))
            task.wait(1)
            searchForServer()
        else
            local willHopForAvoid = checkAvoidPlayersOnce()

            if not willHopForAvoid then
                if SETTINGS.EnableAntiBotScan then updateDisplay("SUCCESS", "Server s·∫°ch.\nB·∫Øt ƒë·∫ßu AFK.") else updateDisplay("INFO", "B·ªè qua qu√©t bot.\nB·∫Øt ƒë·∫ßu AFK.") end
                task.wait(2)
                
                if SETTINGS.EnableSafePlatform then createSafePlatform() end
                if SETTINGS.EnableStaticAfkView then setupFacialCameraAndFreeze() end
                if SETTINGS.EnableCpuOptimization then optimizeForCpu() end
                if SETTINGS.EnableGraphicsOptimization then optimizeGraphics() end
                
                startInitialCountdown()
                startPlayerCountMonitor()
            end
        end
    else
        if SETTINGS.EnableSafePlatform then createSafePlatform() end
        if SETTINGS.EnableStaticAfkView then setupFacialCameraAndFreeze() end
        if SETTINGS.EnableCpuOptimization then optimizeForCpu() end
        if SETTINGS.EnableGraphicsOptimization then optimizeGraphics() end
        updateDisplay("INFO", "Server Hop T·∫ÆT.\nHo√†n th√†nh thi·∫øt l·∫≠p.")
    end
    print("[MainInit] Script ƒë√£ ho√†n t·∫•t.")
end)
