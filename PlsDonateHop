-- Các service cần thiết
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local CoreGui = game:GetService("CoreGui")
local Lighting = game:GetService("Lighting")
local SoundService = game:GetService("SoundService")
local RunService = game:GetService("RunService")

-- --- Cấu hình Script ---
local placeId = game.PlaceId
local currentJobId = game.JobId

local DEFAULT_WAIT_MINUTES = 10
local minPlayerPercentage = 0.50
local maxPlayerPercentageLimit = 0.90
local waitTimeBetweenFullScans = 7
local waitTimeBetweenPageFetches = 0.75
local baseRetryDelay = 1
local maxRetryDelay = 16

local SERVER_HISTORY_FILENAME = "server_hop_history.txt"
local SERVER_HOP_GUI_NAME = "ServerHopStatusGUI"
local AFK_PLATFORM_NAME = "MySafeAFKPlatform" -- Tên cho platform tự tạo

-- [[ NEW CONFIG FOR FIXED TEXT SIZE ]]
local FIXED_TEXT_SIZE = 50

-- --- Kiểm tra và gán hàm đọc/ghi file (NẾU CÓ) ---
local canAccessFiles = false
local writefile_func, readfile_func
pcall(function()
    if writefile and readfile then
        canAccessFiles = true
        writefile_func = writefile
        readfile_func = readfile
    end
end)
if canAccessFiles then print("[ServerHop] writefile/readfile được kích hoạt.")
else print("[ServerHop] writefile/readfile không khả dụng.") end

-- --- UI Chính (Thông báo trạng thái) ---
local playerGui = LocalPlayer:WaitForChild("PlayerGui")
local statusScreenGui = playerGui:FindFirstChild(SERVER_HOP_GUI_NAME)
if statusScreenGui then statusScreenGui:Destroy() end

statusScreenGui = Instance.new("ScreenGui")
statusScreenGui.Name = SERVER_HOP_GUI_NAME
statusScreenGui.ResetOnSpawn = false
statusScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
statusScreenGui.IgnoreGuiInset = true
statusScreenGui.Parent = playerGui

local statusTextLabel = Instance.new("TextLabel")
statusTextLabel.Name = "StatusLabel"
statusTextLabel.Size = UDim2.new(0.9, 0, 0, FIXED_TEXT_SIZE + 20)
statusTextLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
statusTextLabel.AnchorPoint = Vector2.new(0.5, 0.5)
statusTextLabel.BackgroundTransparency = 1
statusTextLabel.TextColor3 = Color3.fromRGB(255, 87, 51)
statusTextLabel.Font = Enum.Font.SourceSansSemibold
statusTextLabel.TextScaled = false
statusTextLabel.TextSize = FIXED_TEXT_SIZE
statusTextLabel.TextXAlignment = Enum.TextXAlignment.Center
statusTextLabel.TextYAlignment = Enum.TextYAlignment.Center
statusTextLabel.TextWrapped = false
statusTextLabel.Parent = statusScreenGui
statusTextLabel.Text = "..."

local function updateStatus(message)
    print("[ServerHop] " .. tostring(message))
    if statusTextLabel and statusTextLabel.Parent then statusTextLabel.Text = tostring(message) end
end

-- --- Hàm xử lý file cho LỊCH SỬ server ---
local serverHistoryCache = {}
local function loadServerHistory()
    if not canAccessFiles then return {} end
    local historySet = {}
    local s, c = pcall(readfile_func, SERVER_HISTORY_FILENAME)
    if s and c then
        for line in string.gmatch(c, "[^".."\r\n".."]+") do
            local tL = line:match("^%s*(.-)%s*$")
            if tL and #tL > 0 then historySet[tL] = true end
        end
        print("[ServerHop] Đã tải " .. table.maxn(historySet) .. " server từ lịch sử.") -- Note: table.maxn might not be ideal for set size
    else print("[ServerHop] Lỗi đọc/không có file lịch sử.") end
    serverHistoryCache = historySet; return historySet
end

local function addJobIdToHistoryAndSave(jobIdToAdd)
    if not jobIdToAdd or not canAccessFiles then return end
    serverHistoryCache[jobIdToAdd] = true
    local lines = {}
    for id in pairs(serverHistoryCache) do table.insert(lines, id) end
    pcall(writefile_func, SERVER_HISTORY_FILENAME, table.concat(lines, "\n"))
    print("[ServerHop] Đã cập nhật lịch sử server.")
end

-- --- Hàm Tạo Platform An Toàn ---
local function createSafePlatform()
    if game.Workspace:FindFirstChild(AFK_PLATFORM_NAME) then
        print("[Platform] Platform an toàn đã tồn tại.")
        return game.Workspace:FindFirstChild(AFK_PLATFORM_NAME)
    end

    print("[Platform] Đang tạo Platform an toàn...")
    local platform = Instance.new("Part")
    platform.Name = AFK_PLATFORM_NAME
    platform.Anchored = true
    platform.CanCollide = true
    platform.Size = Vector3.new(20000, 40, 20000) -- Kích thước rất lớn
    platform.Color = Color3.fromRGB(50, 50, 50)   -- Màu xám tối
    platform.Material = Enum.Material.Concrete
    platform.TopSurface = Enum.SurfaceType.Smooth
    platform.BottomSurface = Enum.SurfaceType.Smooth
    platform.Transparency = 0 -- Hoàn toàn thấy được

    local character = LocalPlayer.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

    if humanoidRootPart then
        local hrpPos = humanoidRootPart.Position
        local hrpSizeY = humanoidRootPart.Size.Y
        platform.Position = Vector3.new(hrpPos.X, hrpPos.Y - (hrpSizeY / 2) - (platform.Size.Y / 2) - 5, hrpPos.Z)
        print("[Platform] Platform được tạo tại: " .. tostring(platform.Position))
    else
        platform.Position = Vector3.new(0, -30, 0) -- Vị trí dự phòng
        print("[Platform] Không tìm thấy HumanoidRootPart, đặt platform ở vị trí mặc định.")
    end

    platform.Parent = game.Workspace
    return platform
end

-- --- Script Tối Ưu Hóa Đồ Họa (Làm Tàng Hình) ---
local function optimizeGraphics()
    -- 1. TẠO PLATFORM AN TOÀN TRƯỚC TIÊN
    createSafePlatform()
    task.wait(0.1) -- Chờ một chút để platform được render (nếu cần)

    local success_pcall, error_pcall = pcall(function()
        updateStatus("Tối ưu hóa đồ họa (tàng hình)...")
        task.wait(0.1)

        local function setInstanceInvisible(instance)
            pcall(function()
                if instance:IsA("BasePart") then
                    instance.Transparency = 1
                    instance.CastShadow = false
                    for _, child_obj in ipairs(instance:GetChildren()) do
                        if child_obj:IsA("Decal") or child_obj:IsA("Texture") then
                            child_obj.Transparency = 1
                        end
                    end
                elseif instance:IsA("Decal") or instance:IsA("Texture") then
                    instance.Transparency = 1
                elseif instance:IsA("ParticleEmitter") or instance:IsA("Beam") or instance:IsA("Trail") or instance:IsA("Explosion") then
                    instance.Enabled = false
                elseif instance:IsA("Light") then
                    instance.Enabled = false
                elseif instance:IsA("BillboardGui") or instance:IsA("SurfaceGui") then
                    instance.Enabled = false
                end
            end)
        end

        print("[GraphicsOptimizer] Bắt đầu làm tàng hình đối tượng trong Workspace...")
        for _, topLevelItem in pairs(game.Workspace:GetChildren()) do
            -- KHÔNG làm ẩn Terrain gốc, Camera, Nhân vật, hoặc Platform tự tạo
            if topLevelItem:IsA("Terrain") or
               topLevelItem:IsA("Camera") or
               topLevelItem.Name == LocalPlayer.Name or
               topLevelItem:IsA("CurrentCamera") or
               topLevelItem.Name == AFK_PLATFORM_NAME then
                continue
            end

            setInstanceInvisible(topLevelItem)
            if topLevelItem:IsA("Model") or topLevelItem:IsA("Folder") or topLevelItem:IsA("Tool") then
                for _, descendant in ipairs(topLevelItem:GetDescendants()) do
                    setInstanceInvisible(descendant)
                end
            end
        end
        print("[GraphicsOptimizer] Đã xử lý tàng hình cho các đối tượng trong Workspace.")

        print("[GraphicsOptimizer] Cấu hình Lighting...")
        Lighting.GlobalShadows = false; Lighting.Brightness = 0
        Lighting.Ambient = Color3.new(0,0,0); Lighting.OutdoorAmbient = Color3.new(0,0,0)
        Lighting.ClockTime = 12; Lighting.FogEnd = 1e9; Lighting.FogStart = 1e9-1
        Lighting.ExposureCompensation = -2
        pcall(function() if Lighting:FindFirstChild("Atmosphere") then Lighting.Atmosphere:Destroy() end end)
        pcall(function() if Lighting:FindFirstChild("Sky") then Lighting.Sky:Destroy() end end)
        -- (Các hiệu ứng khác tương tự)
        print("[GraphicsOptimizer] Đã cấu hình Lighting.")

        print("[GraphicsOptimizer] Xử lý GUI trong PlayerGui...")
        if LocalPlayer:FindFirstChild("PlayerGui") then
            for _, gui in pairs(LocalPlayer.PlayerGui:GetChildren()) do
                if gui.Name ~= SERVER_HOP_GUI_NAME then
                    pcall(function() gui:Destroy() end) -- Vẫn đang xóa GUI khác
                end
            end
        end
        print("[GraphicsOptimizer] Đã xử lý GUI trong PlayerGui.")

        print("[GraphicsOptimizer] Cấu hình Rendering...")
        local sS, sO = pcall(function() return settings() end)
        if sS and sO and sO.Rendering then
            sO.Rendering.QualityLevel = Enum.QualityLevel.Level01
            pcall(function() RunService:Set3dRenderingEnabled(false) end)
        else print("[GraphicsOptimizer] Không thể truy cập settings().Rendering.") end
        print("[GraphicsOptimizer] Đã cấu hình Rendering.")

        print("[GraphicsOptimizer] Tắt âm thanh...")
        SoundService.RespectFilteringEnabled = true
        SoundService.AmbientReverb = Enum.ReverbType.NoReverb
        for _, sound in pairs(game:GetDescendants()) do
            if sound:IsA("Sound") then pcall(function() sound.Volume = 0; sound:Stop() end) end
        end
        print("[GraphicsOptimizer] Đã tắt âm thanh.")

        updateStatus("Đồ họa đã được tối ưu (tàng hình).")
        print("[GraphicsOptimizer] Hoàn tất tối ưu hóa đồ họa.")
    end)
    if not success_pcall then
        warn("[GraphicsOptimizer] Lỗi khi tối ưu đồ họa: " .. tostring(error_pcall))
        updateStatus("Lỗi tối ưu đồ họa.")
    end
end

-- --- Logic Tìm Server ---
-- (Phần code này giữ nguyên như trước, không cần thay đổi)
local chosenServer = nil
local serversUrlBase = "https://games.roblox.com/v1/games/" .. placeId .. "/servers/Public?sortOrder=Asc&limit=100"
local serverHistoryToAvoid = loadServerHistory()

local function listServers(cursor)
    local requestUrl = serversUrlBase
    if cursor then requestUrl = requestUrl .. "&cursor=" .. cursor end
    local successCall, result = pcall(function() return HttpService:RequestAsync({Url = requestUrl, Method = "GET"}) end)
    if not successCall or not result or not result.Success then
        local errorMsg = result and result.Body or tostring(result)
        return false, "Yêu cầu HTTP thất bại: " .. errorMsg
    end
    local successDecode, decodedResult = pcall(function() return HttpService:JSONDecode(result.Body) end)
    if not successDecode then return false, "JSONDecode thất bại: " .. tostring(decodedResult) end
    return true, decodedResult
end

function searchForServer()
    local historyCount = 0
    -- Simple count for dictionary
    for _ in pairs(serverHistoryToAvoid) do historyCount = historyCount + 1 end
    updateStatus(string.format("Tìm server (%.0f%%-%.0f%%). Tránh %d server.",
        minPlayerPercentage * 100, maxPlayerPercentageLimit * 100, historyCount + 1))

    local searchLoopActive = true
    chosenServer = nil
    while searchLoopActive and not chosenServer do
        local currentNextCursorForFullScan = nil
        updateStatus("Quét server...")
        local allPagesScannedForThisRound = false
        while not allPagesScannedForThisRound and not chosenServer do
            local pageScanAttempts = 0; local maxPageScanAttempts = 4
            local pageSuccessfullyFetched = false; local currentRetryDelayPage = baseRetryDelay
            while not pageSuccessfullyFetched and pageScanAttempts < maxPageScanAttempts do
                pageScanAttempts = pageScanAttempts + 1
                if pageScanAttempts > 1 then
                    updateStatus(string.format("Thử lại trang (%d/%d). Chờ %.1fs...", pageScanAttempts, maxPageScanAttempts, currentRetryDelayPage))
                    task.wait(currentRetryDelayPage)
                    currentRetryDelayPage = math.min(currentRetryDelayPage * 2, maxRetryDelay)
                else updateStatus("Lấy trang server...") end
                local success, dataOrError = listServers(currentNextCursorForFullScan)
                if success then
                    pageSuccessfullyFetched = true; currentRetryDelayPage = baseRetryDelay
                    local serverListData = dataOrError
                    if serverListData and serverListData.data then
                        local pageSuitableServers = {}
                        if #serverListData.data > 0 then
                            for _, serverInfo in ipairs(serverListData.data) do
                                local serverId = serverInfo.id
                                if not (serverId == currentJobId) and not (serverHistoryToAvoid[serverId] == true) then
                                    if serverInfo.playing and serverInfo.maxPlayers and serverInfo.maxPlayers > 0 then
                                        local playerRatio = serverInfo.playing / serverInfo.maxPlayers
                                        if playerRatio >= minPlayerPercentage and playerRatio < maxPlayerPercentageLimit and serverInfo.playing < serverInfo.maxPlayers then
                                            table.insert(pageSuitableServers, serverInfo)
                                        end
                                    end
                                end
                            end
                            if #pageSuitableServers > 0 then
                                updateStatus("Thấy " .. #pageSuitableServers .. " server tốt!")
                                chosenServer = pageSuitableServers[math.random(1, #pageSuitableServers)]
                                allPagesScannedForThisRound = true; break
                            end
                        end
                        if not chosenServer then
                            currentNextCursorForFullScan = serverListData.nextPageCursor
                            if not currentNextCursorForFullScan then
                                allPagesScannedForThisRound = true; updateStatus("Hết server để quét.")
                            end
                        end
                    else updateStatus("Dữ liệu server không hợp lệ/trống.") end
                else
                    local errMsgStr = tostring(dataOrError); local shortErr = #errMsgStr > 40 and (string.sub(errMsgStr, 1, 40).."...") or errMsgStr
                    updateStatus("Lỗi API: " .. shortErr)
                    if pageScanAttempts >= maxPageScanAttempts then allPagesScannedForThisRound = true end
                end
            end
            if chosenServer or allPagesScannedForThisRound then break end
            if pageSuccessfullyFetched and not allPagesScannedForThisRound and not chosenServer then task.wait(waitTimeBetweenPageFetches) end
        end
        if chosenServer then
            local shortId = chosenServer.id and string.sub(tostring(chosenServer.id),1,8) or "N/A"
            updateStatus(string.format("CHỌN SERVER! ID: %s (%d/%d)",shortId, chosenServer.playing or 0, chosenServer.maxPlayers or 0))
            searchLoopActive = false
        elseif allPagesScannedForThisRound then
            updateStatus(string.format("Không tìm thấy. Chờ %ds quét lại...", waitTimeBetweenFullScans))
            task.wait(waitTimeBetweenFullScans)
        end
    end
    if chosenServer then
        updateStatus("Đang dịch chuyển...")
        addJobIdToHistoryAndSave(currentJobId)
        task.wait(1)
        local success_tp, err_tp = pcall(function() TeleportService:TeleportToPlaceInstance(placeId, chosenServer.id, LocalPlayer) end)
        if not success_tp then
            local errTpStr = tostring(err_tp); local shortErrTp = #errTpStr > 40 and (string.sub(errTpStr,1,40).."...") or errTpStr
            updateStatus("Dịch chuyển lỗi: " .. shortErrTp)
            serverHistoryToAvoid[chosenServer.id] = true
            print("[ServerHop] Đã thêm server lỗi ("..tostring(chosenServer.id)..") vào danh sách tránh tạm thời.")
            chosenServer = nil; task.wait(5); searchForServer()
        end
    else updateStatus("Không tìm thấy server phù hợp. Dừng.") end
end

-- --- Quản lý Countdown và Donate ---
local countdownShouldReset = false
local currentCountdownThread = nil
local function performCountdownThenSearch(minutesToWait)
    if not minutesToWait or minutesToWait <= 0 then updateStatus("Thời gian chờ lỗi. Tìm ngay..."); searchForServer(); return end
    local totalWaitSeconds = minutesToWait * 60
    print(string.format("[ServerHop] Tìm server sau: %d phút %d giây...", math.floor(totalWaitSeconds/60), totalWaitSeconds%60))
    for i = totalWaitSeconds, 0, -1 do
        if countdownShouldReset then countdownShouldReset = false; updateStatus("Donate! Reset đếm ngược."); startInitialCountdown(); return end
        if statusTextLabel and statusTextLabel.Parent then statusTextLabel.Text = string.format("%02d:%02d", math.floor(i/60), i%60) end
        task.wait(1)
    end
    updateStatus("Hết giờ! Tìm server..."); searchForServer()
end

local function startInitialCountdown()
    if currentCountdownThread and coroutine.status(currentCountdownThread) ~= "dead" then
        pcall(coroutine.close, currentCountdownThread); currentCountdownThread = nil
        print("[ServerHop] Đã đóng coroutine đếm ngược cũ.")
    end
    currentCountdownThread = coroutine.create(function()
        local s, e = pcall(performCountdownThenSearch, DEFAULT_WAIT_MINUTES)
        if not s then warn("[ServerHop] Lỗi coroutine đếm ngược: "..tostring(e)); updateStatus("Lỗi coroutine. Thử lại sau 5s..."); task.wait(5); startInitialCountdown() end
    end)
    coroutine.resume(currentCountdownThread)
end

local lsSuccess, ls = pcall(function() return LocalPlayer:WaitForChild("leaderstats",15) end)
if lsSuccess and ls then
    local rvSuccess, rvObj = pcall(function() return ls:WaitForChild("Raised",15) end)
    if rvSuccess and rvObj then
        local lastRaised = rvObj.Value
        rvObj.Changed:Connect(function(newVal)
            if newVal > lastRaised then updateStatus(string.format("Donate! Raised: %.0f -> %.0f", lastRaised, newVal)); lastRaised=newVal; countdownShouldReset=true; print("[ServerHop] Cờ reset được đặt.") end
        end)
    else print("[ServerHop] Không thấy 'Raised' trong leaderstats.") end
else print("[ServerHop] Không thấy 'leaderstats'.") end

-- --- Khởi chạy Script ---
updateStatus("Khởi tạo ServerHop...")
task.wait(0.2)
optimizeGraphics() -- Gọi hàm tối ưu hóa đồ họa (bao gồm tạo platform)
task.wait(0.3)
print("[ServerHop] Thời gian chờ mặc định: " .. DEFAULT_WAIT_MINUTES .. " phút.")
startInitialCountdown()

