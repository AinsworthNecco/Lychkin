-- Các service cần thiết
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local CoreGui = game:GetService("CoreGui")
local Lighting = game:GetService("Lighting")
local SoundService = game:GetService("SoundService")
local RunService = game:GetService("RunService")

-- --- Cấu hình Script ---
local placeId = game.PlaceId
local currentJobId = game.JobId

local DEFAULT_WAIT_MINUTES = 10
local minPlayerPercentage = 0.50
local maxPlayerPercentageLimit = 0.90
local waitTimeBetweenFullScans = 7
local waitTimeBetweenPageFetches = 0.75
local baseRetryDelay = 1
local maxRetryDelay = 16

local PLATFORM_VERTICAL_OFFSET = 0
local SERVER_HISTORY_FILENAME = "server_hop_history.txt"
local SERVER_HOP_GUI_NAME = "ServerHopStatusGUI"
local AFK_PLATFORM_NAME = "MySafeAFKPlatform"
local STATIC_HEAD_ANCHOR_PART_NAME = "AFK_HeadAnchor_StaticCam"
local STATIC_BLACK_SCREEN_PART_NAME = "AFK_BlackScreen_StaticCam"

local FIXED_TEXT_SIZE = 50

-- --- Setting (Cài đặt Tính năng) ---
local SETTINGS = {
    -- Cài đặt chính
    enableServerHopLogic = true,        -- true: Kích hoạt toàn bộ logic tìm và chuyển server. false: Script sẽ chỉ thực hiện các tác vụ AFK ban đầu rồi dừng.
    
    -- Cài đặt AFK & Tối ưu
    enableSafePlatform = true,          -- true: Tạo platform an toàn khi AFK. false: Không tạo.
    enableStaticAfkView = true,         -- true: Thiết lập camera tĩnh nhìn vào màn hình đen khi AFK. false: Không thay đổi camera.
    enableGraphicsOptimization = true,  -- true: Tối ưu hóa đồ họa (xóa vật thể, giảm chất lượng...). false: Không tối ưu.
    
    -- Cài đặt Giới hạn FPS
    enableFpsLimiter = true,            -- true: BẬT tính năng giới hạn FPS. false: TẮT, game sẽ chạy ở FPS mặc định.
    targetFps = 1,                      -- FPS mục tiêu NẾU `enableFpsLimiter` là true.

    -- Cài đặt Lịch sử Server
    enableFileHistory = true,           -- true: Sử dụng file để lưu và tránh các server đã vào. false: Không dùng file.
    enableJoinOldServer = false,        -- true: CHO PHÉP vào lại các server đã có trong lịch sử. false: TRÁNH các server đã có trong lịch sử.
    historyClearThreshold = 300,        -- Tự động xóa file lịch sử nếu có nhiều hơn số server này. Đặt là 0 để không bao giờ tự xóa.

    -- Cài đặt Game (Ví dụ: Pls Donate)
    enableDonateResetCountdown = true,  -- true: Reset thời gian đếm ngược khi có donate. false: Không reset.
}
-- --- Kết thúc Setting ---

-- --- Kiểm tra và gán hàm đọc/ghi file (NẾU CÓ và được Setting cho phép) ---
local canAccessFiles = false
local writefile_func, readfile_func

if SETTINGS.enableFileHistory then
    print("[FileIO] Tính năng lịch sử file được BẬT trong settings. Đang kiểm tra quyền...")
    pcall(function()
        if writefile and readfile then
            canAccessFiles = true
            writefile_func = writefile
            readfile_func = readfile
            print("[FileIO] Quyền writefile/readfile có sẵn.")
        else
            print("[FileIO] Quyền writefile/readfile KHÔNG có sẵn.")
        end
    end)
else
    print("[FileIO] Tính năng lịch sử file bị TẮT trong settings.")
end

if canAccessFiles then
    print("[ServerHop] writefile/readfile được kích hoạt (do setting BẬT và có quyền).")
else
    if SETTINGS.enableFileHistory then
        print("[ServerHop] writefile/readfile KHÔNG khả dụng (setting BẬT nhưng thiếu quyền hoặc hàm không tồn tại).")
    else
        print("[ServerHop] writefile/readfile KHÔNG khả dụng (do setting TẮT).")
    end
end

-- --- UI Chính (Thông báo trạng thái) ---
local playerGui = LocalPlayer:WaitForChild("PlayerGui")
local statusScreenGui = playerGui:FindFirstChild(SERVER_HOP_GUI_NAME)
if statusScreenGui then statusScreenGui:Destroy() end
statusScreenGui = Instance.new("ScreenGui")
statusScreenGui.Name = SERVER_HOP_GUI_NAME
statusScreenGui.ResetOnSpawn = false; statusScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
statusScreenGui.IgnoreGuiInset = true; statusScreenGui.Parent = playerGui
local statusTextLabel = Instance.new("TextLabel")
statusTextLabel.Name = "StatusLabel"; statusTextLabel.Size = UDim2.new(0.9,0,0,FIXED_TEXT_SIZE+20)
statusTextLabel.Position = UDim2.new(0.5,0,0.5,0); statusTextLabel.AnchorPoint = Vector2.new(0.5,0.5)
statusTextLabel.BackgroundTransparency = 1; statusTextLabel.TextColor3 = Color3.fromRGB(255,87,51)
statusTextLabel.Font = Enum.Font.SourceSansSemibold; statusTextLabel.TextScaled = false
statusTextLabel.TextSize = FIXED_TEXT_SIZE; statusTextLabel.TextXAlignment = Enum.TextXAlignment.Center
statusTextLabel.TextYAlignment = Enum.TextYAlignment.Center; statusTextLabel.TextWrapped = false
statusTextLabel.Parent = statusScreenGui; statusTextLabel.Text = "..."

local function updateStatus(message)
    local msgStr = "[UI] " .. tostring(message); print(msgStr)
    if statusTextLabel and statusTextLabel.Parent then statusTextLabel.Text = tostring(message) end
end

-- --- Hàm xử lý file cho LỊCH SỬ server ---
local serverHistoryCache = {}
local function loadServerHistory()
    print("[FileIO] loadServerHistory() BẮT ĐẦU.")
    if not canAccessFiles then print("[FileIO] Không có quyền truy cập file (do setting hoặc thiếu quyền)."); return {} end
    
    local historySet = {}; 
    local s, c = pcall(readfile_func, SERVER_HISTORY_FILENAME)
    
    if s and c then 
        local lineCount = 0
        for line in string.gmatch(c,"[^".."\r\n".."]+") do 
            local trimmedLine = line:match("^%s*(.-)%s*$") 
            if trimmedLine and #trimmedLine > 0 then 
                historySet[trimmedLine] = true;
                lineCount = lineCount + 1
            end 
        end 
        print("[FileIO] Đã tải "..lineCount.." server từ lịch sử.")

        if SETTINGS.historyClearThreshold > 0 and lineCount >= SETTINGS.historyClearThreshold then
            print(string.format("[FileIO] Lịch sử server (%d) đã đạt hoặc vượt ngưỡng (%d). Đang xóa...", lineCount, SETTINGS.historyClearThreshold))
            updateStatus("Xóa lịch sử server...")
            historySet = {} -- Xóa bộ nhớ đệm
            local clearSuccess, clearErr = pcall(writefile_func, SERVER_HISTORY_FILENAME, "") -- Xóa nội dung file
            if clearSuccess then
                print("[FileIO] Đã xóa thành công file lịch sử.")
            else
                warn("[FileIO] Lỗi khi xóa file lịch sử: " .. tostring(clearErr))
            end
        end

    else 
        print("[FileIO] Lỗi đọc/không có file lịch sử: "..tostring(c)) 
    end
    
    serverHistoryCache = historySet; 
    print("[FileIO] loadServerHistory() KẾT THÚC."); 
    return historySet
end

local function addJobIdToHistoryAndSave(jId)
    print("[FileIO] addJobIdToHistoryAndSave() JobId: "..tostring(jId))
    if not jId or not canAccessFiles then print("[FileIO] Không thêm JobId (không có JobId, setting tắt hoặc thiếu quyền).");return end
    
    serverHistoryCache[jId] = true; 
    local lines = {}; 
    for id in pairs(serverHistoryCache) do table.insert(lines, id) end
    
    local sS, eR = pcall(writefile_func, SERVER_HISTORY_FILENAME, table.concat(lines, "\n"))
    
    if sS then 
        print("[FileIO] Đã cập nhật lịch sử.") 
    else 
        print("[FileIO] Lỗi lưu: "..tostring(eR)) 
    end
    
    print("[FileIO] addJobIdToHistoryAndSave() KẾT THÚC.")
end

-- --- Hàm Tạo Platform An Toàn ---
local function createSafePlatform()
    print("[Platform] createSafePlatform() BẮT ĐẦU."); updateStatus("Đang tạo platform...")
    if game.Workspace:FindFirstChild(AFK_PLATFORM_NAME)then print("[Platform] Platform đã tồn tại.");updateStatus("Platform đã có.");return game.Workspace:FindFirstChild(AFK_PLATFORM_NAME)end
    print("[Platform] Đang tạo Part platform..."); local p=Instance.new("Part");p.Name=AFK_PLATFORM_NAME;p.Anchored=true;p.CanCollide=true;p.Size=Vector3.new(20000,40,20000);p.Color=Color3.fromRGB(50,50,50);p.Material=Enum.Material.Concrete;p.TopSurface=Enum.SurfaceType.Smooth;p.BottomSurface=Enum.SurfaceType.Smooth;p.Transparency=0
    local char=LocalPlayer.Character; local hum=char and char:FindFirstChildOfClass("Humanoid"); local hrp=char and char:FindFirstChild("HumanoidRootPart")
    if hum and hrp then
        local hrpP=hrp.Position;local hrpSY=hrp.Size.Y;local hipH=hum.HipHeight;local fCIY=hrpP.Y-(hrpSY/2)-hipH;local pTTY=fCIY-PLATFORM_VERTICAL_OFFSET;local pCY=pTTY-(p.Size.Y/2)
        p.Position=Vector3.new(hrpP.X,pCY,hrpP.Z)
    else
        p.Position=Vector3.new(0,-30-PLATFORM_VERTICAL_OFFSET,0)
    end
    p.Parent=game.Workspace;print("[Platform] Platform ĐÃ TẠO.");updateStatus("Platform đã tạo.");return p
end

-- --- Hàm Thiết Lập View AFK Tĩnh ---
local function setupStaticAfkView()
    print("[StaticView] Bắt đầu thiết lập view AFK tĩnh...")
    updateStatus("Thiết lập view AFK tĩnh...")
    local player = LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    if not character then print("[StaticView] KHÔNG THỂ LẤY NHÂN VẬT."); return end
    local head = character:WaitForChild("Head", 10)
    if not head then print("[StaticView] KHÔNG tìm thấy Head."); return end
    local camera = workspace.CurrentCamera
    if not camera then print("[StaticView] workspace.CurrentCamera không tồn tại."); return end
    local staticHeadAnchor = workspace:FindFirstChild(STATIC_HEAD_ANCHOR_PART_NAME) or Instance.new("Part")
    staticHeadAnchor.Name = STATIC_HEAD_ANCHOR_PART_NAME; staticHeadAnchor.Size = Vector3.new(0.1, 0.1, 0.1); staticHeadAnchor.Transparency = 1; staticHeadAnchor.CanCollide = false; staticHeadAnchor.Parent = workspace
    staticHeadAnchor.CFrame = CFrame.new(head.Position); staticHeadAnchor.Anchored = true
    local blackTarget = workspace:FindFirstChild(STATIC_BLACK_SCREEN_PART_NAME) or Instance.new("Part")
    blackTarget.Name = STATIC_BLACK_SCREEN_PART_NAME; blackTarget.Size = Vector3.new(2500, 2500, 10); blackTarget.Color = Color3.fromRGB(0, 0, 0); blackTarget.Material = Enum.Material.Plastic; blackTarget.Transparency = 0; blackTarget.CanCollide = false; blackTarget.Parent = workspace
    local eastPositionFromAnchor = staticHeadAnchor.Position + Vector3.new(150, 0, 0)
    blackTarget.CFrame = CFrame.new(eastPositionFromAnchor); blackTarget.Anchored = true
    camera.CameraType = Enum.CameraType.Scriptable; camera.CFrame = CFrame.new(staticHeadAnchor.Position, blackTarget.Position); camera.Focus = blackTarget.CFrame
    updateStatus("View AFK tĩnh đã thiết lập.")
end

-- --- Script Tối Ưu Hóa Đồ Họa ---
local function optimizeGraphics()
    print("[Optimizer] optimizeGraphics() BẮT ĐẦU."); updateStatus("Bắt đầu tối ưu đồ họa...")
    if SETTINGS.enableSafePlatform then createSafePlatform() end
    
    task.wait(0.1)
    pcall(function()
        local itemsToDel={};
        for _,item in pairs(game.Workspace:GetChildren()) do
            local keepItem = (LocalPlayer.Character and item.Name == LocalPlayer.Character.Name) or (item.Name == AFK_PLATFORM_NAME and SETTINGS.enableSafePlatform) or (item == workspace.CurrentCamera) or ((item.Name == STATIC_HEAD_ANCHOR_PART_NAME or item.Name == STATIC_BLACK_SCREEN_PART_NAME) and SETTINGS.enableStaticAfkView)
            if not keepItem then table.insert(itemsToDel, item) end
        end
        for _,item in ipairs(itemsToDel) do pcall(function() item:Destroy() end) end
        
        Lighting.GlobalShadows=false; Lighting.Brightness=0; Lighting.Ambient=Color3.new(0,0,0); Lighting.OutdoorAmbient=Color3.new(0,0,0)
        pcall(function() Lighting.Atmosphere:Destroy() end); pcall(function() Lighting.Sky:Destroy() end)
        
        for _,gui in pairs(LocalPlayer.PlayerGui:GetChildren()) do if gui.Name ~= SERVER_HOP_GUI_NAME then pcall(function() gui:Destroy() end) end end
        
        local settingsSvc = settings()
        if settingsSvc and settingsSvc.Rendering then settingsSvc.Rendering.QualityLevel = Enum.QualityLevel.Level01 end
        pcall(function() if RunService:IsClient() then RunService:Set3dRenderingEnabled(false) end end)
        
        SoundService.AmbientReverb=Enum.ReverbType.NoReverb
        for _,sound in pairs(game:GetDescendants()) do if sound:IsA("Sound") then pcall(function() sound.Volume=0; sound:Stop() end) end end
        updateStatus("Đồ họa đã được tối ưu.")
    end)
end

-- --- Hàm Thiết Lập Giới Hạn FPS ---
local function applyFpsCap()
    if SETTINGS.enableFpsLimiter and SETTINGS.targetFps and type(SETTINGS.targetFps) == "number" and SETTINGS.targetFps > 0 then
        print("[FPSManager] Kích hoạt vòng lặp giới hạn FPS. Mục tiêu: " .. SETTINGS.targetFps .. " FPS.")
        updateStatus("Khóa FPS ở mức: " .. SETTINGS.targetFps)

        task.spawn(function()
            local TargetFPS = SETTINGS.targetFps
            local desiredFrameTime = 1 / TargetFPS
            while true do
                local deltaTime = RunService.Heartbeat:Wait()
                local waitTime = desiredFrameTime - deltaTime
                if waitTime > 0 then task.wait(waitTime) end
            end
        end)
    else
        print("[FPSManager] Giới hạn FPS bị TẮT bởi setting hoặc FPS mục tiêu không hợp lệ.")
        updateStatus("FPS không giới hạn.")
    end
end

-- --- Logic Tìm Server (Dùng HttpGet) ---
local chosenServer = nil
local serversUrlBase = "https://games.roblox.com/v1/games/" .. placeId .. "/servers/Public?sortOrder=Asc&limit=100"
local serverHistoryToAvoid

local function listServers(cursor)
    local requestUrl = serversUrlBase .. (cursor and "&cursor="..cursor or "")
    local sC, res = pcall(function() return game:HttpGet(requestUrl, true) end)
    if not sC then return false, "HttpGet fail: "..tostring(res) end
    local sD, dRes = pcall(function() return HttpService:JSONDecode(res) end)
    if not sD then return false, "JSONDecode fail: "..tostring(dRes) end
    return true, dRes
end

function searchForServer()
    if not SETTINGS.enableFileHistory then
        serverHistoryCache = {}
    elseif not serverHistoryToAvoid then
         serverHistoryToAvoid = loadServerHistory()
    end

    local historyCount = 0; for _ in pairs(serverHistoryCache) do historyCount = historyCount + 1 end
    
    if not SETTINGS.enableJoinOldServer and SETTINGS.enableFileHistory then
        updateStatus(string.format("Tìm server (%.0f%%-%.0f%%). Tránh %d.", minPlayerPercentage*100, maxPlayerPercentageLimit*100, historyCount+1))
    else
        updateStatus(string.format("Tìm server (%.0f%%-%.0f%%).", minPlayerPercentage*100, maxPlayerPercentageLimit*100))
    end

    local sLActive = true
    while sLActive and not chosenServer do
        local nextCur=nil
        while not chosenServer and (nextCur or not allScanned) do
            local allScanned = nextCur == nil
            local s, d = listServers(nextCur)
            if s and d.data then
                local suitableServers = {}
                for _,sInf in ipairs(d.data) do 
                    local shouldAvoid = sInf.id == currentJobId or (serverHistoryCache[sInf.id] and not SETTINGS.enableJoinOldServer)
                    if not shouldAvoid and sInf.playing and sInf.maxPlayers and sInf.maxPlayers > 0 then 
                        local pR = sInf.playing/sInf.maxPlayers 
                        if pR >= minPlayerPercentage and pR < maxPlayerPercentageLimit and sInf.playing < sInf.maxPlayers then 
                            table.insert(suitableServers, sInf)
                        end 
                    end 
                end
                if #suitableServers > 0 then chosenServer = suitableServers[math.random(1, #suitableServers)] end
                nextCur = d.nextPageCursor
            else
                task.wait(baseRetryDelay) -- Wait on API error
            end
            if not nextCur then break end
            task.wait(waitTimeBetweenPageFetches)
        end
        if not chosenServer then task.wait(waitTimeBetweenFullScans) end
    end
    
    if chosenServer then 
        updateStatus("Đang dịch chuyển đến server mới...")
        addJobIdToHistoryAndSave(currentJobId)
        task.wait(1)
        pcall(TeleportService.TeleportToPlaceInstance, TeleportService, placeId, chosenServer.id, LocalPlayer)
    else
        updateStatus("Không tìm thấy server phù hợp. Dừng lại.")
    end
end

-- --- Quản lý Countdown và Donate ---
local countdownShouldReset = false
local currentCountdownThread = nil
local function performCountdownThenSearch(minutesToWait)
    if not minutesToWait or minutesToWait <= 0 then searchForServer(); return end
    for i = minutesToWait * 60, 0, -1 do
        if countdownShouldReset and SETTINGS.enableDonateResetCountdown then startInitialCountdown(); return end
        updateStatus(string.format("%02d:%02d", math.floor(i/60), i%60))
        task.wait(1)
    end
    searchForServer()
end

local function startInitialCountdown()
    if currentCountdownThread then pcall(coroutine.close, currentCountdownThread) end
    currentCountdownThread = coroutine.create(function() 
        pcall(performCountdownThenSearch, DEFAULT_WAIT_MINUTES)
    end)
    coroutine.resume(currentCountdownThread)
end

-- --- Khởi chạy Script ---
print("[MainInit] Script BẮT ĐẦU KHỞI CHẠY.")
updateStatus("Khởi tạo ServerHop...")

-- Áp dụng giới hạn FPS NGAY LẬP TỨC để giảm tải CPU trong lúc chờ.
applyFpsCap()

task.wait(0.2) -- Chờ một chút để các service khác có thể khởi tạo

-- [[ SỬA ĐỔI ]] Thay đổi thời gian chờ thành 10 giây
updateStatus("Chờ 10 giây cho game tải...")
print(string.format("[MainInit] Chờ 10s tối ưu hóa. Time: %s", os.date and os.date("%X") or "N/A"))
task.wait(10)
print(string.format("[MainInit] HẾT 10 GIÂY CHỜ. Time: %s", os.date and os.date("%X") or "N/A"))
updateStatus("Hết 10s chờ. Bắt đầu các thiết lập...")

if SETTINGS.enableSafePlatform then
    createSafePlatform()
end

if SETTINGS.enableStaticAfkView then
    setupStaticAfkView()
end

if SETTINGS.enableGraphicsOptimization then
    optimizeGraphics()
end

if SETTINGS.enableServerHopLogic then
    updateStatus("Chuẩn bị đếm ngược để tìm server...")
    task.wait(0.3)
    startInitialCountdown()

    if SETTINGS.enableDonateResetCountdown then
        local leaderstats = LocalPlayer:WaitForChild("leaderstats", 15)
        if leaderstats then
            local raised = leaderstats:WaitForChild("Raised", 15)
            if raised then
                local lastRaised = raised.Value
                raised.Changed:Connect(function(newRaised)
                    if newRaised > lastRaised then
                        lastRaised = newRaised
                        countdownShouldReset = true
                    end
                end)
            end
        end
    end
else
    updateStatus("Logic Server Hop TẮT. Script sẽ không tìm server mới.")
end

print("[MainInit] Script đã hoàn tất khởi chạy chính.")
