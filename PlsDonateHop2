local SETTINGS = {
    -- =================================================================
    -- CÀI ĐẶT PROXY (ĐÃ CẬP NHẬT)
    -- =================================================================
    ["EnableProxySystem"] = true, -- Bật/tắt toàn bộ hệ thống proxy.
    ["ProxyListURL"] = "https://raw.githubusercontent.com/AinsworthNecco/Lychkin/refs/heads/main/Proxy", -- URL PROXY MỚI CỦA BẠN

    -- =================================================================
    -- CÀI ĐẶT NÉ NGƯỜI CHƠI
    -- =================================================================
    ["EnableAvoidPlayers"] = true, -- Bật/tắt tính năng né tài khoản
    ["AVOID_PLAYERS"] = {
        "HelloPlayer1st",
        "Lychkin01", "Lychkin02", "Lychkin03", "Lychkin04", "Lychkin05",
        "YattaNeco1", "YattaNeco2", "YattaNeco3", "YattaNeco4", "YattaNeco5"
    },

    -- =================================================================
    -- CÀI ĐẶT CHỐNG BOT
    -- =================================================================
    ["EnableAntiBotScan"] = true,
    ["BOT_KEYWORDS"] = { "spin", "afk", "restaurant", "jump", "gift", "speed", "develop", "streaming", "live", "game", "#", "dream", "first", "mom", "big" },
    ["DETECTION_THRESHOLD"] = 3,

    -- =================================================================
    -- CÀI ĐẶT SERVER HOP & AFK
    -- =================================================================
    ["WaitMinutes"] = 10,
    ["MaxServerHistorySize"] = 500,
    ["EnablePlayerCountCheck"] = true,
    ["MinPlayerThreshold"] = 15,
    ["EnableServerHop"] = true,
    ["EnableSafePlatform"] = true,
    ["EnableStaticAfkView"] = true,
    ["EnableDonateReset"] = true,
    
    -- Cài đặt Thông Báo Donate qua Discord
    ["EnableDiscordWebhook"] = true,
    ["WebhookURL"] = "https://discord.com/api/webhooks/1397368466947969147/HbncMuT0ETe6_5q_kKGzkdd7guLfiGqvewr3WuBFfHAxKBJo3TA7R6ad2ex31YkBHo75",
    ["WebhookColor"] = 16738740,
    ["EnablePingOnDonate"] = true,
    ["PingAmount"] = 1000,
    ["PingUserID"] = "",

    -- Cài đặt Tự Động Trả Lời (Auto Reply)
    ["EnableAutoReply"] = false,
    ["ReplyRadius"] = 25,
    ["ReplyCooldown"] = 10,
    ["ReplyRules"] = {
        { keywords = { "hi", "hello", "hey", "sup", "yo", "wsg", "howdy", "greetings", "wassup", "heya" }, replies = { "Hello!", "Hi there", "Hey!", "Yo", "What's up?", "Heya", "Sup", "Heyo!", "What's good?", "Well hello there." } },
        { keywords = { "only","donate", "pls", "give me", "robux pls", "can i have", "spare", "some robux", "can u donate", "plz donate", "can you give", "i need robux" }, replies = { "Sorry, I'm saving up right now.", "I can't donate at the moment, sorry.", "My robux is pending, can't help sorry.", "Sry, saving for something specific.", "Maybe later, I'm trying to reach my own goal.", "Can't right now, good luck though!", "All my robux is tied up, sorry.", "Sorry, my wallet is on a diet.", "I wish I could, but I'm broke lol." } },
        { keywords = { "bot", "auto", "script", "scripter", "macro", "afk farm", "autoclicker", "you a bot?" }, replies = { "I'm not a bot :)", "lol no, I'm a real player.", "Just vibing, not a bot.", "Beep boop? Nah, just kidding.", "I'm a human, I promise!", "Not a script, just dedicated lol.", "Do I look like a bot to you? :P", "Last time I checked, I still need to sleep. So, not a bot.", "01001110 01101111. (That means 'No' in binary)." } },
        { keywords = { "scam", "fake", "report", "scammer", "this is a scam", "don't trust", "he's a scammer", "is this fake" }, replies = { "This is not a scam.", "I'm not a scammer.", "It's legit, no worries.", "100% legit, my friend.", "No scams here, just good vibes.", "I'm just here to play the game like you.", "Why would you think it's a scam?", "The only thing I'm scamming is time, by playing this game.", "You've got the wrong person, I'm just here to chill." } },
        { keywords = { "why are you", "how are you", "spinning", "jumping", "afk" }, replies = { "Just farming for my goal.", "It's part of the grind.", "Doing this for donations." } },
    },

    -- Cài đặt hiệu năng
    ["EnableGraphicsOptimization"] = true,
    ["EnableCpuOptimization"] = true,
    ["SetSimulationRadiusToZero"] = true,
    ["TargetFps"] = 7,

    -- Cài đặt khác
    ["EnableFileHistory"] = true,
    ["InitialWaitTime"] = 1,

    -- Cài đặt giao diện
    ["EnableCountdownText"] = true,
    ["EnableCountdownColor"] = true,
    ["CountdownFixedColorHex"] = "#000000",
}
-- --- KẾT THÚC CÀI ĐẶT ---

-- Nền tảng an toàn (Anti-Cheat Bypass)
local identifyexecutor = identifyexecutor or function() return 'Unknown' end
local cloneref = (identifyexecutor() ~= "Synapse Z" and not identifyexecutor():find("Codex") and cloneref) or function(o) return o end

-- Các service cần thiết
local TeleportService = cloneref(game:GetService("TeleportService"))
local HttpService = cloneref(game:GetService("HttpService"))
local Players = cloneref(game:GetService("Players"))
local TextChatService = cloneref(game:GetService("TextChatService"))
local Workspace = cloneref(game:GetService("Workspace"))
local Lighting = cloneref(game:GetService("Lighting"))
local SoundService = cloneref(game:GetService("SoundService"))
local RunService = cloneref(game:GetService("RunService"))
local CoreGui = cloneref(game:GetService("CoreGui"))
local rng = Random.new()

-- --- Cấu hình Script (Không nên thay đổi) ---
local placeId = game.PlaceId; local currentJobId = game.JobId; local PLATFORM_VERTICAL_OFFSET = 0; local SERVER_HISTORY_FILENAME = "server_hop_history.txt"; local SERVER_HOP_GUI_NAME = "ServerHopStatusGUI"; local AFK_PLATFORM_NAME = "MySafeAFKPlatform"; local STATIC_HEAD_ANCHOR_PART_NAME = "AFK_HeadAnchor_StaticCam"; local STATIC_BLACK_SCREEN_PART_NAME = "AFK_BlackScreen_StaticCam"; local NEON_COLORS = { GREEN = Color3.fromRGB(10, 255, 20), YELLOW = Color3.fromRGB(255, 255, 0), BLUE = Color3.fromRGB(0, 150, 255), RED = Color3.fromRGB(255, 20, 20) }

-- --- Biến toàn cục ---
local LocalPlayer = Players.LocalPlayer
local playerGui = LocalPlayer and LocalPlayer:WaitForChild("PlayerGui")
local statusScreenGui, statusTextLabel, statusFrame
local countdownShouldReset = false; local currentCountdownThread = nil; local playerMonitorThread = nil
local serverHistoryCache = {}
local isRateLimited = false

-- --- BIẾN TOÀN CỤC CHO PROXY (MỚI) ---
local proxyList = {}
local http_request_func = (syn and syn.request) or (http and http.request) or (fluxus and fluxus.request) or request

-- --- Kiểm tra và gán hàm đọc/ghi file ---
local canAccessFiles = false; local writefile_func, readfile_func; if SETTINGS.EnableFileHistory then pcall(function() if writefile and readfile then canAccessFiles, writefile_func, readfile_func = true, writefile, readfile; print("[FileIO] Quyền file có sẵn.") else print("[FileIO] Quyền file KHÔNG có sẵn.") end end) else print("[FileIO] Lịch sử file bị TẮT.") end

-- =================================================================
-- HỆ THỐNG GIAO DIỆN
-- =================================================================
local function createStatusGui() if playerGui:FindFirstChild(SERVER_HOP_GUI_NAME) then playerGui[SERVER_HOP_GUI_NAME]:Destroy() end; statusScreenGui = Instance.new("ScreenGui"); statusScreenGui.Name = SERVER_HOP_GUI_NAME; statusScreenGui.ResetOnSpawn, statusScreenGui.ZIndexBehavior, statusScreenGui.IgnoreGuiInset = false, Enum.ZIndexBehavior.Sibling, true; statusScreenGui.Parent = playerGui; statusFrame = Instance.new("Frame"); statusFrame.Name = "StatusFrame"; statusFrame.Size = UDim2.new(1, 0, 1, 0); statusFrame.BackgroundColor3, statusFrame.BorderSizePixel = NEON_COLORS.GREEN, 0; statusFrame.BackgroundTransparency = 1; statusFrame.ZIndex = 1; statusFrame.Parent = statusScreenGui; local FIXED_TEXT_SIZE = 50; statusTextLabel = Instance.new("TextLabel"); statusTextLabel.Name = "StatusLabel"; statusTextLabel.Size = UDim2.new(0.9, 0, 0, FIXED_TEXT_SIZE + 120); statusTextLabel.Position = UDim2.new(0.5, 0, 0.5, 0); statusTextLabel.AnchorPoint = Vector2.new(0.5, 0.5); statusTextLabel.BackgroundTransparency = 1; statusTextLabel.TextColor3 = Color3.new(1, 1, 1); statusTextLabel.Font = Enum.Font.SourceSansSemibold; statusTextLabel.TextScaled = false; statusTextLabel.TextSize = FIXED_TEXT_SIZE - 15; statusTextLabel.TextXAlignment, statusTextLabel.TextYAlignment = Enum.TextXAlignment.Center, Enum.TextYAlignment.Center; statusTextLabel.TextWrapped = true; statusTextLabel.Text = "..."; statusTextLabel.ZIndex = 2; statusTextLabel.Parent = statusScreenGui end
local function updateDisplay(state, message) task.spawn(function() print("[UI] " .. tostring(message)); if not statusTextLabel or not statusTextLabel.Parent then return end; local stateColor = NEON_COLORS.GREEN; if state == "ERROR" then stateColor = NEON_COLORS.YELLOW elseif state == "BOT_DETECTED" then stateColor = NEON_COLORS.RED end; statusTextLabel.Text = tostring(message); statusTextLabel.TextColor3 = stateColor; if SETTINGS.EnableCountdownColor then if statusFrame and statusFrame.Parent then if state == "SUCCESS" or state == "ERROR" or state == "BOT_DETECTED" then statusFrame.BackgroundColor3 = stateColor; statusFrame.BackgroundTransparency = 0.5 else statusFrame.BackgroundTransparency = 1 end end else if statusFrame then statusFrame.BackgroundTransparency = 1 end end end) end

-- --- Các hàm tiện ích (File, Platform, View, CPU, Graphics) ---
local function loadServerHistoryOnce() if not canAccessFiles then print("[History] Không có quyền truy cập file, lịch sử sẽ chỉ tồn tại trong phiên này."); serverHistoryCache = {}; return end; local historySet = {}; local success, content = pcall(readfile_func, SERVER_HISTORY_FILENAME); if success and content then for line in string.gmatch(content, "[^" .. "\r\n" .. "]+") do local trimmedLine = line:match("^%s*(.-)%s*$"); if trimmedLine and #trimmedLine > 0 then historySet[trimmedLine] = true end end end; local historySize = 0; for _ in pairs(historySet) do historySize = historySize + 1 end; local maxSize = SETTINGS.MaxServerHistorySize; if maxSize and maxSize > 0 and historySize >= maxSize then print(string.format("[History] Lịch sử đạt giới hạn (%d/%d). Đang xóa...", historySize, maxSize)); updateDisplay("INFO", "Lịch sử server đầy, đang reset..."); historySet = {}; pcall(writefile_func, SERVER_HISTORY_FILENAME, ""); print("[History] Lịch sử file đã được xóa."); task.wait(2) end; serverHistoryCache = historySet; print(string.format("[History] Đã tải %d server từ lịch sử vào bộ nhớ.", historySize)) end
local function saveServerHistoryToFile() if not canAccessFiles then return end; local serverIds = {}; for id in pairs(serverHistoryCache) do table.insert(serverIds, id) end; local success, err = pcall(writefile_func, SERVER_HISTORY_FILENAME, table.concat(serverIds, "\n")); if not success then print("[History] LỖI: Không thể ghi lịch sử ra file: " .. tostring(err)) else print("[History] Đã lưu lịch sử cập nhật ra file.") end end
local function createSafePlatform() updateDisplay("INFO", "Đang tạo platform..."); if game.Workspace:FindFirstChild(AFK_PLATFORM_NAME) then updateDisplay("INFO", "Platform đã có."); return end; local p=Instance.new("Part");p.Name=AFK_PLATFORM_NAME;p.Anchored=true;p.CanCollide=true;p.Size=Vector3.new(20000,40,20000);p.Color=Color3.fromRGB(50,50,50);p.Transparency=0; local char=LocalPlayer.Character; local hum=char and char:FindFirstChildOfClass("Humanoid"); local hrp=char and char:FindFirstChild("HumanoidRootPart"); if hum and hrp then local hrpP=hrp.Position;local hrpSY=hrp.Size.Y;local hipH=hum.HipHeight;local fCIY=hrpP.Y-(hrpSY/2)-hipH;local pTTY=fCIY-PLATFORM_VERTICAL_OFFSET;local pCY=pTTY-(p.Size.Y/2);p.Position=Vector3.new(hrpP.X,pCY,hrpP.Z); else p.Position=Vector3.new(0,-30-PLATFORM_VERTICAL_OFFSET,0); end; p.Parent=game.Workspace; updateDisplay("SUCCESS", "Platform đã tạo."); end
local function setupStaticAfkView() updateDisplay("INFO", "Thiết lập view AFK tĩnh..."); local player = LocalPlayer; local character = player.Character or player.CharacterAdded:Wait(); if not character then return end; local head = character:WaitForChild("Head", 10); if not head then return end; local camera = workspace.CurrentCamera; if not camera then return end; local staticHeadAnchor = workspace:FindFirstChild(STATIC_HEAD_ANCHOR_PART_NAME) or Instance.new("Part"); staticHeadAnchor.Name=STATIC_HEAD_ANCHOR_PART_NAME; staticHeadAnchor.Size=Vector3.new(0.1,0.1,0.1); staticHeadAnchor.Transparency=1; staticHeadAnchor.CanCollide=false; staticHeadAnchor.Parent=workspace; staticHeadAnchor.CFrame = CFrame.new(head.Position); staticHeadAnchor.Anchored = true; local blackTarget = workspace:FindFirstChild(STATIC_BLACK_SCREEN_PART_NAME) or Instance.new("Part"); blackTarget.Name=STATIC_BLACK_SCREEN_PART_NAME; blackTarget.Size=Vector3.new(2500,2500,10); blackTarget.Color=Color3.new(0,0,0); blackTarget.CanCollide=false; blackTarget.Parent=workspace; local eastPositionFromAnchor = staticHeadAnchor.Position + Vector3.new(150,0,0); blackTarget.CFrame=CFrame.new(eastPositionFromAnchor); blackTarget.Anchored=true; camera.CameraType=Enum.CameraType.Scriptable; camera.CFrame=CFrame.new(staticHeadAnchor.Position,blackTarget.Position); camera.Focus=blackTarget.CFrame; updateDisplay("SUCCESS", "View AFK tĩnh đã thiết lập.") end
local function optimizeForCpu() if not SETTINGS.EnableCpuOptimization then return end; updateDisplay("INFO", "Bắt đầu tối ưu hóa CPU..."); pcall(function() if type(setfpscap) == "function" and SETTINGS.TargetFps and SETTINGS.TargetFps > 0 then print("[CPU-Opt] Giới hạn FPS đang hoạt động ở mức: " .. tostring(SETTINGS.TargetFps)) end; if SETTINGS.SetSimulationRadiusToZero then if LocalPlayer then LocalPlayer.SimulationRadius = 0; print("[CPU-Opt] SimulationRadius đã được đặt về 0.") end end end); updateDisplay("SUCCESS", "Tối ưu hóa CPU hoàn tất.") end
local function optimizeGraphics() updateDisplay("INFO", "Bắt đầu tối ưu đồ họa..."); if SETTINGS.EnableSafePlatform then createSafePlatform(); end; task.wait(0.1); pcall(function() local itemsToDel={}; for _,item in pairs(game.Workspace:GetChildren()) do local keep=(LocalPlayer.Character and item.Name==LocalPlayer.Character.Name)or(item==workspace.CurrentCamera)or(SETTINGS.EnableSafePlatform and item.Name==AFK_PLATFORM_NAME)or(SETTINGS.EnableStaticAfkView and(item.Name==STATIC_HEAD_ANCHOR_PART_NAME or item.Name==STATIC_BLACK_SCREEN_PART_NAME));if not keep then table.insert(itemsToDel,item)end end; for _,item in ipairs(itemsToDel)do pcall(function()item:Destroy()end)end;Lighting.GlobalShadows,Lighting.Brightness,Lighting.Ambient,Lighting.OutdoorAmbient,Lighting.ExposureCompensation=false,0,Color3.new(0,0,0),Color3.new(0,0,0),-2;pcall(function()Lighting.Atmosphere:Destroy()end);pcall(function()Lighting.Sky:Destroy()end); if LocalPlayer.PlayerGui then for _,gui in pairs(LocalPlayer.PlayerGui:GetChildren())do if gui.Name~=SERVER_HOP_GUI_NAME then pcall(function()gui:Destroy()end)end end end;local sO=settings();if sO and sO.Rendering then sO.Rendering.QualityLevel=Enum.QualityLevel.Level01;pcall(function()if RunService:IsClient()then RunService:Set3dRenderingEnabled(false)end end)end;SoundService.RespectFilteringEnabled,SoundService.AmbientReverb=true,Enum.ReverbType.NoReverb;for _,sound in pairs(game:GetDescendants())do if sound:IsA("Sound")then sound.Volume=0;sound:Stop()end end; end); updateDisplay("SUCCESS", "Đồ họa đã được tối ưu."); end

-- =================================================================
-- HỆ THỐNG PROXY (ĐÃ NÂNG CẤP HỖ TRỢ ĐA ĐỊNH DẠNG)
-- =================================================================
local function fetchProxyList()
    if not SETTINGS.EnableProxySystem then
        print("[Proxy] Hệ thống proxy bị tắt.")
        return
    end

    if not SETTINGS.ProxyListURL or not string.find(SETTINGS.ProxyListURL, "http") then
        print("[Proxy] Lỗi: URL danh sách proxy không hợp lệ.")
        return
    end

    updateDisplay("INFO", "Đang tải danh sách proxy...")
    local success, response = pcall(game.HttpGet, game, SETTINGS.ProxyListURL)
    if success and response then
        local proxies = {}
        for line in string.gmatch(response, "[^\r\n]+") do
            local trimmed = line:match("^%s*(.-)%s*$")
            if #trimmed > 0 then
                local parts = {}
                for part in string.gmatch(trimmed, "[^:]+") do
                    table.insert(parts, part)
                end
                
                if #parts == 4 then -- Định dạng: ip:port:user:pass
                    table.insert(proxies, {
                        ip = parts[1], port = parts[2], user = parts[3], pass = parts[4], type = "auth"
                    })
                elseif #parts == 2 then -- Định dạng: ip:port
                    table.insert(proxies, {
                        ip = parts[1], port = parts[2], type = "no_auth"
                    })
                else
                    print("[Proxy] Bỏ qua dòng proxy không hợp lệ: " .. trimmed)
                end
            end
        end
        proxyList = proxies
        if #proxyList > 0 then
            updateDisplay("SUCCESS", "Tải thành công " .. #proxyList .. " proxy.")
            print("[Proxy] Tải thành công " .. #proxyList .. " proxy.")
        else
            updateDisplay("ERROR", "URL không chứa proxy hợp lệ.")
            print("[Proxy] Lỗi: URL không chứa proxy hợp lệ.")
        end
    else
        updateDisplay("ERROR", "Không thể tải danh sách proxy.")
        print("[Proxy] Lỗi: Không thể tải danh sách proxy. " .. tostring(response))
    end
end


-- --- Logic Tìm Server (Đã nâng cấp với Logic Thử Lại IP Gốc) ---
local candidateServers = {}
local nextServerCursor = nil
local tryNextServer -- Khai báo trước

local function persistentFetch(url)
    -- Bước 1: Thử kết nối trực tiếp
    updateDisplay("INFO", "Đang quét server (kết nối trực tiếp)...")
    local success, response = pcall(function() return HttpService:JSONDecode(game:HttpGet(url, true)) end)

    if success and response and response.data then
        isRateLimited = false
        return response
    end

    -- Bước 2: Xử lý lỗi, đặc biệt là rate limit
    local isRateLimitError = false
    if success and response and response.errors and response.errors[1] and response.errors[1].message and string.find(string.lower(response.errors[1].message), "too many requests") then
        isRateLimitError = true
    end

    if not isRateLimitError then
        updateDisplay("ERROR", "Lỗi quét không xác định. Thử lại sau 5s...")
        task.wait(5)
        return persistentFetch(url)
    end

    -- Bước 3: Bắt đầu chu trình proxy
    isRateLimited = true
    if not SETTINGS.EnableProxySystem or #proxyList == 0 then
        updateDisplay("ERROR", "Bị giới hạn! Không có proxy để sử dụng. Chờ 30s...")
        task.wait(30)
        return persistentFetch(url)
    end

    if not http_request_func then
        updateDisplay("ERROR", "Bị giới hạn! Executor không hỗ trợ http.request để dùng proxy. Chờ 30s...")
        task.wait(30)
        return persistentFetch(url)
    end

    updateDisplay("ERROR", "Bị giới hạn! Chuyển sang dùng proxy...")
    
    local availableProxies = {}
    for _, p in ipairs(proxyList) do
        table.insert(availableProxies, p)
    end

    while true do -- Vòng lặp thử lại chính
        -- Xáo trộn danh sách proxy cho mỗi chu kỳ
        for i = #availableProxies, 2, -1 do
            local j = rng:NextInteger(1, i)
            availableProxies[i], availableProxies[j] = availableProxies[j], availableProxies[i]
        end

        for i, proxyData in ipairs(availableProxies) do
            updateDisplay("INFO", string.format("Đang thử proxy ngẫu nhiên %d/%d...", i, #availableProxies))
            
            local proxyString
            if proxyData.type == "auth" then
                proxyString = string.format("http://%s:%s@%s:%s", proxyData.user, proxyData.pass, proxyData.ip, proxyData.port)
            else -- no_auth
                proxyString = string.format("http://%s:%s", proxyData.ip, proxyData.port)
            end
            
            local pcallSuccess, pcallResponse = pcall(http_request_func, { Url = url, Method = "GET", Proxy = proxyString })

            if pcallSuccess and pcallResponse and pcallResponse.Success and pcallResponse.Body then
                local decodeSuccess, decodedBody = pcall(HttpService.JSONDecode, HttpService, pcallResponse.Body)
                if decodeSuccess and decodedBody and decodedBody.data then
                    isRateLimited = false
                    updateDisplay("SUCCESS", "Kết nối thành công qua proxy!")
                    return decodedBody -- THÀNH CÔNG!
                end
            end

            updateDisplay("ERROR", string.format("Proxy %d/%d thất bại.", i, #availableProxies))
            task.wait(0.1)
        end
        
        -- Logic mới: Thử lại bằng IP gốc sau khi tất cả proxy thất bại
        updateDisplay("ERROR", "Tất cả proxy đều thất bại. Đợi 5s...")
        task.wait(5)

        updateDisplay("INFO", "Thử lại với IP gốc...")
        local directSuccess, directResponse = pcall(function() return HttpService:JSONDecode(game:HttpGet(url, true)) end)
        if directSuccess and directResponse and directResponse.data then
            updateDisplay("SUCCESS", "Kết nối IP gốc thành công!")
            isRateLimited = false
            return directResponse -- THÀNH CÔNG!
        end
        
        updateDisplay("ERROR", "IP gốc cũng thất bại. Bắt đầu lại vòng lặp proxy...")
    end
end

local function prepareToHop()
    print("[ServerHop] Preparing to hop servers...")
    if currentCountdownThread and coroutine.status(currentCountdownThread) ~= "dead" then pcall(coroutine.close, currentCountdownThread); currentCountdownThread = nil end
    if playerMonitorThread and coroutine.status(playerMonitorThread) ~= "dead" then pcall(coroutine.close, playerMonitorThread); playerMonitorThread = nil end
    serverHistoryCache[currentJobId] = true
    print(string.format("[History] JobId %s... đã thêm vào cache bộ nhớ.", string.sub(currentJobId, 1, 8)))
    saveServerHistoryToFile()
end

local function executeTeleport(jobId)
    updateDisplay("SUCCESS", string.format("Server được chọn!\nĐang vào: %s...", jobId:sub(1, 12)))
    task.wait(0.5)
    print(string.format("[Teleport] Bắt đầu dịch chuyển đến Job ID: %s", jobId))
    pcall(function() TeleportService:TeleportToPlaceInstance(game.PlaceId, jobId, Players.LocalPlayer) end)
end

local function fetchNextBatch()
    updateDisplay("INFO", "Bắt đầu quét loạt server mới...")
    
    local apiUrl = "https://games.roblox.com/v1/games/" .. placeId .. "/servers/Public?sortOrder=Desc&limit=100&excludeFullGames=true"
    if nextServerCursor then
        apiUrl = apiUrl .. "&cursor=" .. nextServerCursor
    end

    local response = persistentFetch(apiUrl)

    if response and response.data and #response.data > 0 then
        nextServerCursor = response.nextPageCursor
        
        local newCandidatesCount, ignoredHistoryCount = 0, 0
        for _, server in ipairs(response.data) do
            if not serverHistoryCache[server.id] then
                table.insert(candidateServers, server)
                newCandidatesCount = newCandidatesCount + 1
            else
                ignoredHistoryCount = ignoredHistoryCount + 1
            end
        end

        print(string.format("[ServerScan] Quét xong. Thêm %d server mới. Bỏ qua %d (lịch sử).", newCandidatesCount, ignoredHistoryCount))
        
        if newCandidatesCount > 0 then
            updateDisplay("SUCCESS", "Quét xong! Tìm thấy " .. newCandidatesCount .. " server hợp lệ.")
            for i = #candidateServers, 2, -1 do
                local j = rng:NextInteger(1, i)
                candidateServers[i], candidateServers[j] = candidateServers[j], candidateServers[i]
            end
            tryNextServer()
        else
            updateDisplay("INFO", "Trang này toàn server đã vào. Đang tìm trang tiếp...")
            fetchNextBatch()
        end
    else
        updateDisplay("ERROR", "Hết server hoặc lỗi API. Bắt đầu lại từ đầu sau 15s...")
        nextServerCursor = nil
        task.wait(15)
        fetchNextBatch()
    end
end

tryNextServer = function()
    if #candidateServers == 0 then
        fetchNextBatch()
    else
        local targetServer = table.remove(candidateServers, 1)
        executeTeleport(targetServer.id)
    end
end

function searchForServer()
    updateDisplay("INFO", "Bắt đầu tìm server...")
    candidateServers = {}
    nextServerCursor = nil
    prepareToHop()
    tryNextServer()
end

TeleportService.TeleportInitFailed:Connect(function(player, teleportResult, errorMessage)
    if not SETTINGS.EnableServerHop then return end
    local reason = "Lý do không xác định"
    if teleportResult == Enum.TeleportResult.GameFull then reason = "Server đầy!"
    elseif teleportResult == Enum.TeleportResult.Flooded then reason = "Thao tác quá nhanh!"
    else reason = errorMessage end
    
    updateDisplay("ERROR", "Dịch chuyển thất bại: " .. reason)
    updateDisplay("INFO", "Tìm server khác sau 0.5 giây...")
    task.wait(0.5)
    tryNextServer()
end)

-- --- Quản lý AFK (Countdown, Donate, Player Count) ---
function startInitialCountdown() updateDisplay("INFO", "Bắt đầu chu trình..."); if currentCountdownThread and coroutine.status(currentCountdownThread) ~= "dead" then pcall(coroutine.close, currentCountdownThread); currentCountdownThread = nil end; local function performCountdownThenSearch(minutesToWait) if not minutesToWait or minutesToWait <= 0 then updateDisplay("ERROR", "Thời gian chờ lỗi."); prepareToHop(); searchForServer(); return end; if not SETTINGS.EnableCountdownText then if statusTextLabel then statusTextLabel.Text = "" end end; if not SETTINGS.EnableCountdownColor then if statusFrame then statusFrame.BackgroundTransparency = 1 end end; local totalS = minutesToWait * 60; for i = totalS, 0, -1 do if countdownShouldReset and SETTINGS.EnableDonateReset then countdownShouldReset = false; if statusTextLabel then statusTextLabel.Text = "" end; if statusFrame then statusFrame.BackgroundTransparency = 1 end; updateDisplay("SUCCESS", "Donate! Reset thời gian."); startInitialCountdown(); return end; if SETTINGS.EnableCountdownText then if statusTextLabel and statusTextLabel.Parent then local currentPlayers = #Players:GetPlayers(); local maxPlayers = Players.MaxPlayers; local playerCountText = string.format("%d/%d", currentPlayers, maxPlayers); local timerText = string.format("%02d:%02d", math.floor(i/60), i%60); local jobIdText = "Server: " .. string.sub(currentJobId, 1, 12) .. "..."; statusTextLabel.Text = string.format("%s\n%s\n%s", timerText, playerCountText, jobIdText); statusTextLabel.TextColor3 = Color3.new(1,1,1) end end; if SETTINGS.EnableCountdownColor then if statusFrame and statusFrame.Parent then local success, color = pcall(Color3.fromHex, SETTINGS.CountdownFixedColorHex or "#FFFFFF"); if success then statusFrame.BackgroundColor3 = color else print("[UI] Lỗi mã hex không hợp lệ, sử dụng màu mặc định."); statusFrame.BackgroundColor3 = NEON_COLORS.BLUE end; statusFrame.BackgroundTransparency = 0.6 end end; task.wait(1) end; if statusTextLabel then statusTextLabel.Text = "" end; if statusFrame then statusFrame.BackgroundTransparency = 1 end; updateDisplay("SUCCESS", "Hết giờ! Bắt đầu tìm server..."); prepareToHop(); searchForServer() end; currentCountdownThread = coroutine.create(function() local s,e = pcall(performCountdownThenSearch, SETTINGS.WaitMinutes); if not s then updateDisplay("ERROR", "Lỗi Coroutine. Thử lại sau 5s..."); task.wait(5); if SETTINGS.EnableServerHop then startInitialCountdown() end end end); coroutine.resume(currentCountdownThread) end
local function startPlayerCountMonitor() if not SETTINGS.EnablePlayerCountCheck or (SETTINGS.MinPlayerThreshold or 0) <= 0 then return end; if playerMonitorThread and coroutine.status(playerMonitorThread) ~= "dead" then pcall(coroutine.close, playerMonitorThread); playerMonitorThread = nil end; playerMonitorThread = coroutine.create(function() while true do task.wait(20); if not SETTINGS.EnablePlayerCountCheck or not SETTINGS.EnableServerHop then break end; local currentPlayers = #Players:GetPlayers(); if currentPlayers < SETTINGS.MinPlayerThreshold then updateDisplay("ERROR", string.format("Server vắng! (%d/%d người)\nĐang tìm server mới...", currentPlayers, SETTINGS.MinPlayerThreshold)); task.wait(3); prepareToHop(); searchForServer(); break else print(string.format("[PlayerMonitor] Check OK: %d/%d players.", currentPlayers, SETTINGS.MinPlayerThreshold)) end end end); coroutine.resume(playerMonitorThread) end
local function checkAvoidPlayersOnce() if not SETTINGS.EnableAvoidPlayers or not SETTINGS.AVOID_PLAYERS or #SETTINGS.AVOID_PLAYERS == 0 then return false end; local avoidNamesSet = {}; for _, name in ipairs(SETTINGS.AVOID_PLAYERS) do avoidNamesSet[name] = true end; local playersInServer = Players:GetPlayers(); for _, player in ipairs(playersInServer) do if player.Name ~= LocalPlayer.Name and avoidNamesSet[player.Name] then updateDisplay("ERROR", string.format("Phát hiện tài khoản '%s'!\nĐang tìm server mới...", player.Name)); task.wait(3); prepareToHop(); searchForServer(); return true end end; print("[AvoidPlayerCheck] Quét 1 lần OK, không phát hiện tài khoản cần né."); return false end

-- --- Các hàm thiết lập (AutoReply, Webhook) ---
local function setupAutoReply() if not SETTINGS.EnableAutoReply then return end; local ChatChannel = TextChatService.TextChannels.RBXGeneral; local Cooldowns = {}; local function safeChat(msg) pcall(function() ChatChannel:SendAsync(msg) end) end; Players.PlayerChatted:Connect(function(_, player, message) if not SETTINGS.EnableAutoReply then return end; if player == LocalPlayer then return end; if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end; if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end; local distance = (player.Character.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude; if distance > SETTINGS.ReplyRadius then return end; if Cooldowns[player] and tick() - Cooldowns[player] < SETTINGS.ReplyCooldown then return end; local lowerMsg = string.lower(message); local replied = false; for _, rule in ipairs(SETTINGS.ReplyRules) do for _, keyword in ipairs(rule.keywords) do if string.find(lowerMsg, keyword) then local reply = rule.replies[math.random(1, #rule.replies)]; task.wait(math.random(1,3)); safeChat(reply); Cooldowns[player] = tick(); replied = true; break end end; if replied then break end end end); updateDisplay("SUCCESS", "Tính năng tự động trả lời đã được kích hoạt.") end
local function setupDiscordWebhook() if not SETTINGS.EnableDiscordWebhook or not SETTINGS.WebhookURL or SETTINGS.WebhookURL == "" then print("[Webhook] Tính năng webhook bị tắt hoặc URL không hợp lệ."); return end; local leaderstats = LocalPlayer:WaitForChild("leaderstats", 30); if not leaderstats then updateDisplay("ERROR", "[Webhook] Không tìm thấy leaderstats sau 30 giây."); return end; local raised = leaderstats:WaitForChild("Raised", 30); if not raised then updateDisplay("ERROR", "[Webhook] Không tìm thấy 'Raised' trong leaderstats."); return end; local lastRaised = raised.Value; local function sendWebhook(amount, total) local pingContent = nil; if SETTINGS.EnablePingOnDonate then if amount >= (SETTINGS.PingAmount or 0) then if SETTINGS.PingUserID and SETTINGS.PingUserID ~= "" then pingContent = string.format("<@%s>", SETTINGS.PingUserID) else pingContent = "@everyone" end end end; local embed = { description = string.format("**%s**\n# +%d\nTOTAL : %d", LocalPlayer.Name, amount, total), color = SETTINGS.WebhookColor }; local payloadData = { embeds = { embed } }; if pingContent then payloadData.content = pingContent end; local payload = HttpService:JSONEncode(payloadData); if http_request_func then pcall(function() http_request_func({ Url = SETTINGS.WebhookURL, Method = "POST", Headers = { ["Content-Type"] = "application/json" }, Body = payload }) end) else updateDisplay("ERROR", "[Webhook] Không tìm thấy hàm request để gửi webhook.") end end; raised.Changed:Connect(function(newRaisedValue) local difference = newRaisedValue - lastRaised; if difference > 0 then if SETTINGS.EnableDonateReset then countdownShouldReset = true end; sendWebhook(difference, newRaisedValue) end; lastRaised = newRaisedValue end); updateDisplay("SUCCESS", "Tính năng thông báo donate qua Discord đã được kích hoạt.") end

-- --- HÀM QUÉT BOT ---
local function scanForBots() updateDisplay("INFO", "Bắt đầu quét bot..."); task.wait(2); local _boothlocation; local suc, _shuffled = pcall(function() return Workspace:WaitForChild('MapUI', 5) end); if not suc or not _shuffled then local playerGuiMap = LocalPlayer:WaitForChild("PlayerGui"); if playerGuiMap then local mapUiContainer = playerGuiMap:WaitForChild('MapUIContainer', 5); if mapUiContainer then _boothlocation = mapUiContainer:WaitForChild('MapUI', 5) end end else _boothlocation = _shuffled end; if not _boothlocation then updateDisplay("ERROR", "LỖI: Không tìm thấy MapUI để quét bot."); return 0 end; local boothUI = _boothlocation:WaitForChild("BoothUI"); if not boothUI then updateDisplay("ERROR", "LỖI: Không tìm thấy BoothUI bên trong MapUI."); return 0 end; local currentBotCount = 0; for _, uiFrame in ipairs(boothUI:GetChildren()) do local success, err = pcall(function() local ownerName = uiFrame.Details.Owner.Text; if ownerName ~= "unclaimed" then local boothText = string.lower(uiFrame.Sign.TextLabel.Text); for _, keyword in ipairs(SETTINGS.BOT_KEYWORDS) do if string.find(boothText, keyword) then currentBotCount = currentBotCount + 1; local alertMessage = string.format("PHÁT HIỆN BOT #%d\n'%s'", currentBotCount, ownerName); updateDisplay("BOT_DETECTED", alertMessage); task.wait(2.5); break end end end end); if not success then print("[Anti-Bot] Lỗi khi quét gian hàng: " .. tostring(err)) end end; updateDisplay("INFO", "Quét xong. Phát hiện: " .. currentBotCount .. " bot."); task.wait(3); return currentBotCount end

-- =================================================================
-- LOGIC KHỞI CHẠY CHÍNH
-- =================================================================
task.spawn(function()
    pcall(createStatusGui)
    updateDisplay("INFO", "Đang khởi tạo...")
    task.wait(0.5)

    -- Tải lịch sử server và proxy
    loadServerHistoryOnce()
    fetchProxyList()

    if type(setfpscap) == "function" and SETTINGS.TargetFps and SETTINGS.TargetFps > 0 then task.spawn(function() while task.wait() do pcall(setfpscap, SETTINGS.TargetFps) end end) end
    if SETTINGS.EnableAutoReply then task.spawn(setupAutoReply) end

    updateDisplay("INFO", string.format("Chờ game tải trong %d giây...", SETTINGS.InitialWaitTime))
    task.wait(SETTINGS.InitialWaitTime)
    
    updateDisplay("INFO", "Bắt đầu luồng quyết định...")

    if SETTINGS.EnableServerHop then
        local botCount = 0
        if SETTINGS.EnableAntiBotScan then botCount = scanForBots() end

        if SETTINGS.EnableAntiBotScan and botCount >= SETTINGS.DETECTION_THRESHOLD then
            updateDisplay("ERROR", string.format("Phát hiện %d/%d bot!\nĐang tìm server mới...", botCount, SETTINGS.DETECTION_THRESHOLD))
            task.wait(3)
            searchForServer()
        else
            local willHopForAvoid = checkAvoidPlayersOnce()
            if not willHopForAvoid then
                if SETTINGS.EnableAntiBotScan then updateDisplay("SUCCESS", "Server sạch.\nBắt đầu AFK.") else updateDisplay("INFO", "Bỏ qua quét bot.\nBắt đầu AFK.") end
                task.wait(2)
                
                if SETTINGS.EnableSafePlatform then createSafePlatform() end
                if SETTINGS.EnableStaticAfkView then setupStaticAfkView() end
                if SETTINGS.EnableCpuOptimization then optimizeForCpu() end
                if SETTINGS.EnableGraphicsOptimization then optimizeGraphics() end
                task.spawn(setupDiscordWebhook)
                
                startInitialCountdown()
                startPlayerCountMonitor()
            end
        end
    else
        if SETTINGS.EnableSafePlatform then createSafePlatform() end
        if SETTINGS.EnableStaticAfkView then setupStaticAfkView() end
        if SETTINGS.EnableCpuOptimization then optimizeForCpu() end
        if SETTINGS.EnableGraphicsOptimization then optimizeGraphics() end
        task.spawn(setupDiscordWebhook)
        updateDisplay("INFO", "Server Hop TẮT.\nHoàn thành thiết lập.")
    end
    print("[MainInit] Script đã hoàn tất.")
end)

