--[[
    ================================================================================================
    SCRIPT CHUYỂN ĐỔI SANG CERBERUS UI BỞI GEMINI (GOOGLE AI)
    Dựa trên yêu cầu của người dùng và script Rayfield trước đó.
    Mục tiêu: Cung cấp trải nghiệm người dùng mới với thư viện Cerberus UI.
    URL Cerberus: https://raw.githubusercontent.com/AinsworthNecco/Lychkin/refs/heads/main/MainUICeberus
    ================================================================================================
]]

-- --- Tải Thư viện Cerberus UI (Theo URL người dùng cung cấp) ---
local Cerberus = loadstring(game:HttpGet('https://raw.githubusercontent.com/AinsworthNecco/Lychkin/refs/heads/main/MainUICeberus'))()

-- --- Các service cần thiết (Giữ nguyên) ---
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local SoundService = game:GetService("SoundService")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local placeId = game.PlaceId
local currentJobId = game.JobId

-- --- Các hằng số và tên định danh (Giữ nguyên) ---
local SERVER_HISTORY_FILENAME = "server_hop_history.txt"
local AFK_PLATFORM_NAME = "MySafeAFKPlatform"
local STATIC_HEAD_ANCHOR_PART_NAME = "AFK_HeadAnchor_StaticCam"
local STATIC_BLACK_SCREEN_PART_NAME = "AFK_BlackScreen_StaticCam"

-- --- Bảng Cấu hình mặc định cho UI ---
local Config = {
    -- Cài đặt Server Hop
    WaitMinutes = 10,
    MinPlayerPercentage = 0.50,
    MaxPlayerPercentage = 0.90,
    WaitBetweenScans = 7,
    WaitBetweenFetches = 0.75,
    -- Cài đặt Tính năng
    EnableHopLogic = false,
    EnableFileHistory = true,
    EnableDonateReset = true,
    EnableSafePlatform = true,
    EnableStaticAFK = true,
    EnableGraphicsOpt = true,
    TargetFPS = 7,
}

-- Biến cục bộ để quản lý trạng thái
local serverHistoryCache = {}
local chosenServer = nil
local countdownCoroutine = nil
local isHoppingProcessActive = false
local statusSectionRef -- Biến để tham chiếu đến Section chứa label trạng thái

-- --- [[ MỚI ]] Hàm hiển thị thông báo và cập nhật trạng thái qua Cerberus ---
local function ShowNotification(title, content)
    -- Cerberus có hệ thống notification đơn giản hơn
    Cerberus:Notification(title .. ": " .. content)
    print("[" .. title .. "] " .. content)
end

-- Hàm cập nhật label trạng thái (do Cerberus không có :Set())
local function updateStatusLabel(text)
    if statusSectionRef then
        statusSectionRef:Clear() -- Xóa tất cả thành phần cũ trong section
        statusSectionRef:CreateLabel(text) -- Tạo label mới với nội dung cập nhật
    end
end

-- --- Các hàm logic cốt lõi (Giữ nguyên, chỉ thay đổi cách gọi thông báo và cập nhật trạng thái) ---
-- (Các hàm xử lý file, tạo platform, AFK view, tối ưu đồ họa, tìm server, countdown... được giữ nguyên y hệt phiên bản Rayfield,
-- chỉ thay đổi các dòng `ShowNotification` và `statusLabelRef:Set` thành `updateStatusLabel`)

-- --- BẮT ĐẦU CÁC HÀM LOGIC ---

local canAccessFiles = false
local writefile_func, readfile_func
pcall(function()
    if writefile and readfile then canAccessFiles, writefile_func, readfile_func = true, writefile, readfile else print("[FileIO] Quyền file KHÔNG có sẵn.") end
end)

local function loadServerHistory()
    if not canAccessFiles or not Config.EnableFileHistory then return {} end
    local historySet = {}; local s, c = pcall(readfile_func, SERVER_HISTORY_FILENAME)
    if s and c then for line in string.gmatch(c,"[^".."\r\n".."]+") do local tL=line:match("^%s*(.-)%s*$") if tL and #tL>0 then historySet[tL]=true;end end end
    serverHistoryCache=historySet; return historySet
end

local function addJobIdToHistoryAndSave(jId)
    if not jId or not canAccessFiles or not Config.EnableFileHistory then return end; serverHistoryCache[jId]=true; local l={}; for id in pairs(serverHistoryCache)do table.insert(l,id)end
    pcall(writefile_func,SERVER_HISTORY_FILENAME,table.concat(l,"\n"))
end

function manageSafePlatform(enable)
    if enable then
        if workspace:FindFirstChild(AFK_PLATFORM_NAME) then ShowNotification("Thông tin", "Platform đã tồn tại."); return end
        ShowNotification("Platform", "Đang tạo platform an toàn...")
        local p=Instance.new("Part");p.Name=AFK_PLATFORM_NAME;p.Anchored=true;p.CanCollide=true;p.Size=Vector3.new(20000,40,20000);p.Color=Color3.fromRGB(50,50,50);p.Transparency=0.5;
        local char=LocalPlayer.Character; local hrp=char and char:FindFirstChild("HumanoidRootPart"); if hrp then p.Position=hrp.Position-Vector3.new(0,25,0) else p.Position=Vector3.new(0,-50,0) end
        p.Parent=workspace; ShowNotification("Thành công", "Platform đã được tạo.")
    else
        local platform = workspace:FindFirstChild(AFK_PLATFORM_NAME)
        if platform then platform:Destroy(); ShowNotification("Platform", "Đã xóa platform an toàn.") end
    end
end

function manageStaticAfkView(enable)
    local camera = workspace.CurrentCamera; if not camera then return end
    if enable then
        ShowNotification("AFK View", "Thiết lập view AFK tĩnh...")
        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait(); local head = character and character:WaitForChild("Head", 10)
        if not head then ShowNotification("Lỗi", "Không tìm thấy đầu của nhân vật."); return end
        local staticHeadAnchor=Instance.new("Part");staticHeadAnchor.Name=STATIC_HEAD_ANCHOR_PART_NAME;staticHeadAnchor.Size=Vector3.new(0.1,0.1,0.1);staticHeadAnchor.Transparency=1;staticHeadAnchor.CanCollide=false;staticHeadAnchor.Anchored=true;staticHeadAnchor.CFrame=CFrame.new(head.Position);staticHeadAnchor.Parent=workspace
        local blackTarget=Instance.new("Part");blackTarget.Name=STATIC_BLACK_SCREEN_PART_NAME;blackTarget.Size=Vector3.new(2500,2500,10);blackTarget.Color=Color3.new(0,0,0);blackTarget.CanCollide=false;blackTarget.Anchored=true;blackTarget.CFrame=CFrame.new(staticHeadAnchor.Position+Vector3.new(150,0,0));blackTarget.Parent=workspace
        camera.CameraType=Enum.CameraType.Scriptable;camera.CFrame=CFrame.new(staticHeadAnchor.Position,blackTarget.Position);camera.Focus=blackTarget.CFrame
        ShowNotification("Thành công", "View AFK tĩnh đã được thiết lập.")
    else
        camera.CameraType=Enum.CameraType.Custom
        local headAnchor=workspace:FindFirstChild(STATIC_HEAD_ANCHOR_PART_NAME);local blackScreen=workspace:FindFirstChild(STATIC_BLACK_SCREEN_PART_NAME)
        if headAnchor then headAnchor:Destroy() end; if blackScreen then blackScreen:Destroy() end
        ShowNotification("AFK View", "Đã tắt view AFK tĩnh.")
    end
end

function optimizeGraphics()
    ShowNotification("Tối ưu", "Bắt đầu tối ưu hóa đồ họa...")
    pcall(function()
        Lighting.GlobalShadows,Lighting.Brightness,Lighting.Ambient,Lighting.OutdoorAmbient,Lighting.ExposureCompensation=false,0,Color3.new(0,0,0),Color3.new(0,0,0),-2;pcall(function()Lighting.Atmosphere:Destroy()end);pcall(function()Lighting.Sky:Destroy()end)
        if LocalPlayer.PlayerGui then for _,gui in pairs(LocalPlayer.PlayerGui:GetChildren())do if gui~=Cerberus.GUI then pcall(function()gui:Destroy()end)end end end
        local sO=settings();if sO and sO.Rendering then sO.Rendering.QualityLevel=Enum.QualityLevel.Level01;pcall(function()if RunService:IsClient()then RunService:Set3dRenderingEnabled(false)end end)end
        SoundService.AmbientReverb=Enum.ReverbType.NoReverb;for _,sound in pairs(game:GetDescendants())do if sound:IsA("Sound")then sound.Volume=0;sound:Stop()end end
        ShowNotification("Thành công", "Đồ họa đã được tối ưu. Rejoin để hoàn tác.")
    end)
end

function searchForServer()
    if not isHoppingProcessActive then return end
    if Config.EnableFileHistory then loadServerHistory() end
    local historyCount = 0; for _ in pairs(serverHistoryCache) do historyCount = historyCount + 1 end
    updateStatusLabel("Trạng thái: Đang tìm server... (Tránh " .. tostring(historyCount + 1) .. " server)")
    ShowNotification("Server Hop", "Bắt đầu tìm kiếm server...")
    
    local serversUrlBase = "https://games.roblox.com/v1/games/" .. placeId .. "/servers/Public?sortOrder=Asc&limit=100"
    chosenServer = nil
    
    task.spawn(function()
        local searchLoopActive = true
        while searchLoopActive and not chosenServer and isHoppingProcessActive do
            local nextCursor=nil; local allScanned=false
            while not allScanned and not chosenServer and isHoppingProcessActive do
                local s,d=pcall(game.HttpGet,game,serversUrlBase..(nextCursor and "&cursor="..nextCursor or ""),true)
                if s then
                    local sListD=pcall(HttpService.JSONDecode, HttpService, d)
                    if sListD and type(sListD) == "table" and sListD.data then
                        local pSuitS={}; for _,sInf in ipairs(sListD.data)do if not(sInf.id==currentJobId or serverHistoryCache[sInf.id])then if sInf.playing and sInf.maxPlayers and sInf.maxPlayers>0 then local pR=sInf.playing/sInf.maxPlayers if pR>=Config.MinPlayerPercentage and pR<Config.MaxPlayerPercentage and sInf.playing<sInf.maxPlayers then table.insert(pSuitS,sInf)end end end end
                        if #pSuitS>0 then chosenServer=pSuitS[math.random(1,#pSuitS)];allScanned=true;break end
                        nextCursor=sListD.nextPageCursor;if not nextCursor then allScanned=true end
                    else ShowNotification("Lỗi API","Dữ liệu server không hợp lệ.") end
                else ShowNotification("Lỗi API","Không thể lấy danh sách server. Thử lại..."); task.wait(3) end
                if chosenServer or allScanned or not isHoppingProcessActive then break end; task.wait(Config.WaitBetweenFetches)
            end
            if chosenServer then
                updateStatusLabel("Trạng thái: ĐÃ TÌM THẤY SERVER!"); ShowNotification("Thành công", "Đã chọn server! Chuẩn bị dịch chuyển."); searchLoopActive=false
            elseif allScanned then updateStatusLabel("Trạng thái: Không tìm thấy. Chờ " .. Config.WaitBetweenScans .. "s."); task.wait(Config.WaitBetweenScans) end
        end
        if chosenServer and isHoppingProcessActive then
            addJobIdToHistoryAndSave(currentJobId); task.wait(1)
            local sTP,eTP=pcall(TeleportService.TeleportToPlaceInstance,TeleportService,placeId,chosenServer.id,LocalPlayer)
            if not sTP then ShowNotification("Lỗi dịch chuyển", "Lỗi: " .. tostring(eTP));serverHistoryCache[chosenServer.id]=true;chosenServer=nil;task.wait(5);searchForServer() end
        elseif isHoppingProcessActive then
            ShowNotification("Thất bại", "Không tìm thấy server phù hợp. Dừng lại."); updateStatusLabel("Trạng thái: Đã dừng. Không tìm thấy server."); Config.EnableHopLogic=false; isHoppingProcessActive=false
        end
    end)
end

function performCountdownThenSearch(minutesToWait)
    local totalSeconds = minutesToWait * 60; local countdownShouldReset = false
    local donateConnection = nil
    if Config.EnableDonateReset then
        local leaderstats=LocalPlayer:WaitForChild("leaderstats",15);if leaderstats then local raised=leaderstats:WaitForChild("Raised",15)
            if raised then local lastR=raised.Value;donateConnection=raised.Changed:Connect(function(nV)if nV>lastR then lastR=nV;countdownShouldReset=true;ShowNotification("Donate!", "Cảm ơn! Reset thời gian.")end end)end
        end
    end
    for i=totalSeconds,0,-1 do
        if not isHoppingProcessActive then break end
        if countdownShouldReset then if donateConnection then donateConnection:Disconnect() end; performCountdownThenSearch(Config.WaitMinutes); return end
        updateStatusLabel(string.format("Sẽ tìm server sau: %02d:%02d", math.floor(i/60), i%60)); task.wait(1)
    end
    if donateConnection then donateConnection:Disconnect() end
    if isHoppingProcessActive then updateStatusLabel("Trạng thái: Hết giờ! Bắt đầu tìm server..."); searchForServer() end
end

function startMainProcess()
    isHoppingProcessActive = true; updateStatusLabel("Trạng thái: Bắt đầu chu trình...")
    countdownCoroutine = task.spawn(function()
        local s,e=pcall(performCountdownThenSearch, Config.WaitMinutes)
        if not s then ShowNotification("Lỗi Coroutine", tostring(e)); isHoppingProcessActive=false; updateStatusLabel("Trạng thái: Lỗi Coroutine. Đã dừng.") end
    end)
end

function stopMainProcess()
    isHoppingProcessActive = false
    if countdownCoroutine then task.cancel(countdownCoroutine); countdownCoroutine=nil end
    updateStatusLabel("Trạng thái: Đã dừng bởi người dùng."); ShowNotification("Thông báo", "Chu trình Server Hop đã dừng.")
end

-- --- KẾT THÚC CÁC HÀM LOGIC ---


-- --- [[ GIAO DIỆN CERBERUS ]] ---
local Main = Cerberus:Create({
    Name = 'Advanced Server Hop by Gemini (Cerberus)',
    Size = UDim2.fromOffset(500, 420),
    Theme = 'Midnight', -- Các theme khác: 'Dark', 'Light', 'Grape'
    Transparency = 0.9,
})

-- Tab chính: Server Hop
local MainTab = Main:CreateTab({ Name = 'Server Hop', Icon = 'rbxassetid://282363387'})
local ControlSection = MainTab:CreateSection({ Name = 'Điều khiển chu trình' })
statusSectionRef = MainTab:CreateSection({ Name = 'Trạng thái hiện tại' })

ControlSection:CreateToggle({
    Name = 'Bắt đầu / Dừng Chu trình Server Hop',
    Callback = function(Value)
        Config.EnableHopLogic = Value
        if Value then startMainProcess() else stopMainProcess() end
    end,
    Enabled = Config.EnableHopLogic
})

ControlSection:CreateToggle({
    Name = 'Reset thời gian khi có Donate',
    Callback = function(Value)
        Config.EnableDonateReset = Value
        ShowNotification("Cài đặt", "Reset khi có donate: " .. (Value and "Bật" or "Tắt"))
    end,
    Enabled = Config.EnableDonateReset
})

-- Tab: AFK & Đồ họa
local AFKTab = Main:CreateTab({ Name = 'Tiện ích', Icon = 'rbxassetid://6031393359' })
local AFKSection = AFKTab:CreateSection({ Name = 'Tính năng AFK' })
local GraphicsSection = AFKTab:CreateSection({ Name = 'Tối ưu hóa' })

AFKSection:CreateToggle({
    Name = 'Tạo Platform An Toàn',
    Callback = function(Value) manageSafePlatform(Value) end,
    Enabled = Config.EnableSafePlatform
})

AFKSection:CreateToggle({
    Name = 'Bật View AFK Tĩnh (Màn hình đen)',
    Callback = function(Value) manageStaticAfkView(Value) end,
    Enabled = Config.EnableStaticAFK
})

GraphicsSection:CreateToggle({
    Name = 'Tối ưu hóa đồ họa (Giảm lag)',
    Callback = function(Value) if Value then optimizeGraphics() else ShowNotification("Thông báo", "Rejoin để hoàn tác tối ưu đồ họa.") end end,
    Enabled = Config.EnableGraphicsOpt
})

GraphicsSection:CreateTextBox({
    Name = 'Giới hạn FPS (0 = không giới hạn)',
    Placeholder = 'Nhập số...',
    Numbers = true,
    Callback = function(Value)
        local num = tonumber(Value)
        if num then Config.TargetFPS = num; ShowNotification("Cài đặt", "Đã đặt giới hạn FPS thành: " .. tostring(num)) end
    end,
    Default = tostring(Config.TargetFPS)
})

-- Tab: Cài đặt chi tiết
local SettingsTab = Main:CreateTab({ Name = 'Cài đặt', Icon = 'rbxassetid://3944111394' })
local ServerFindSection = SettingsTab:CreateSection({ Name = 'Cấu hình tìm server' })

ServerFindSection:CreateSlider({
    Name = 'Thời gian chờ trước khi tìm (phút)',
    Min = 1, Max = 60, Default = Config.WaitMinutes, Suffix = ' phút',
    Callback = function(Value)
        Config.WaitMinutes = math.floor(Value)
        ShowNotification("Cài đặt", "Thời gian chờ mới: " .. Config.WaitMinutes .. " phút")
    end
})

ServerFindSection:CreateSlider({
    Name = 'Tỉ lệ người chơi TỐI THIỂU (%)',
    Min = 0, Max = 100, Default = Config.MinPlayerPercentage * 100, Suffix = '%',
    Callback = function(Value)
        Config.MinPlayerPercentage = Value / 100
        ShowNotification("Cài đặt", string.format("Tỉ lệ tối thiểu: %.0f%%", Value))
    end
})

ServerFindSection:CreateSlider({
    Name = 'Tỉ lệ người chơi TỐI ĐA (%)',
    Min = 0, Max = 100, Default = Config.MaxPlayerPercentage * 100, Suffix = '%',
    Callback = function(Value)
        Config.MaxPlayerPercentage = Value / 100
        ShowNotification("Cài đặt", string.format("Tỉ lệ tối đa: %.0f%%", Value))
    end
})

ServerFindSection:CreateToggle({
    Name = 'Sử dụng lịch sử server (tránh server cũ)',
    Callback = function(Value)
        Config.EnableFileHistory = Value
        if not canAccessFiles and Value then ShowNotification("Lưu ý", "Tính năng này cần quyền đọc/ghi file.") end
    end,
    Enabled = Config.EnableFileHistory
})

-- Khởi tạo trạng thái ban đầu
updateStatusLabel("Trạng thái: Chưa hoạt động")

-- Khởi chạy các tác vụ nền
if type(setfpscap) == "function" then
    task.spawn(function()
        while task.wait() do if Config.TargetFPS and Config.TargetFPS > 0 then pcall(setfpscap, Config.TargetFPS) end end
    end)
end

ShowNotification("Hoàn tất", "Giao diện Cerberus đã sẵn sàng!")
print("[MainInit] Script Cerberus đã hoàn tất khởi chạy.")
