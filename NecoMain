-- Auto re-execute on teleport
local url = "https://raw.githubusercontent.com/AinsworthNecco/Lychkin/refs/heads/main/NecoMain"
local q = syn and syn.queue_on_teleport or queue_on_teleport

if q then
    q(("loadstring(game:HttpGet('%s'))()"):format(url))
end

-- NgƒÉn double execute trong c√πng 1 server
if getgenv().plsdonate_ran then return end
getgenv().plsdonate_ran = true

-- Code ch√≠nh c·ªßa b·∫°n b·∫Øt ƒë·∫ßu t·ª´ ƒë√¢y
print("NecoMain v2.2 (Upgraded) ƒë√£ ch·∫°y th√†nh c√¥ng trong server n√†y!")

local SETTINGS = {
    -- =================================================================
    -- [N√ÇNG C·∫§P] C√ÄI ƒê·∫∂T N√â NG∆Ø·ªúI CH∆†I
    -- =================================================================
    ["EnableAvoidPlayers"] = true, -- B·∫≠t/t·∫Øt t√≠nh nƒÉng n√© t√†i kho·∫£n
    ["AVOID_PLAYERS"] = {
        "HelloPlayer1st",
        "Lychkin01", 
        "Lychkin02",
        "Lychkin03",
        "Lychkin04",
        "Lychkin05"
    },

    -- =================================================================
    -- C√ÄI ƒê·∫∂T CH·ªêNG BOT
    -- =================================================================
    ["EnableAntiBotScan"] = true,
    ["BOT_KEYWORDS"] = { "spin", "afk", "restaurant", "jump", "gift", "speed", "develop", "streaming", "live", "game", "#", "dream" },
    ["DETECTION_THRESHOLD"] = 4,

    -- =================================================================
    -- C√ÄI ƒê·∫∂T SERVER HOP & AFK
    -- =================================================================
    ["WaitMinutes"] = 10,
    ["MinPlayerPercentage"] = 0.50,
    ["MaxPlayerPercentage"] = 0.99,
    ["MaxServerHistorySize"] = 500,
    ["EnableServerHop"] = true,
    ["EnableDonateReset"] = true,
    ["EnableAutoReconnect"] = true,

    -- [N√ÇNG C·∫§P] C√†i ƒë·∫∑t ki·ªÉm tra server v·∫Øng
    ["EnablePlayerCountCheck"] = true, -- B·∫≠t/t·∫Øt ki·ªÉm tra s·ªë ng∆∞·ªùi ch∆°i m·ªói ph√∫t.
    ["MinPlayerThreshold"] = 15,       -- N·∫øu ng∆∞·ªùi ch∆°i trong server √≠t h∆°n s·ªë n√†y, s·∫Ω b·∫Øt ƒë·∫ßu ƒë·∫øm ng∆∞·ª£c ƒë·ªÉ chuy·ªÉn.
    ["LowPlayerConsecutiveChecks"] = 1, -- [M·ªöI] S·ªë l·∫ßn ki·ªÉm tra li√™n ti·∫øp (m·ªói l·∫ßn c√°ch nhau 60s) m√† server v·∫Øng tr∆∞·ªõc khi quy·∫øt ƒë·ªãnh chuy·ªÉn. ƒê·∫∑t l√† 3 nghƒ©a l√† server ph·∫£i v·∫Øng trong 3 ph√∫t li√™n t·ª•c.

    -- =================================================================
    -- C√ÄI ƒê·∫∂T T√çNH NƒÇNG PH·ª§
    -- =================================================================
    ["EnableSafePlatform"] = true,
    ["EnableStaticAfkView"] = true,
    
    -- =================================================================
    -- C√ÄI ƒê·∫∂T TH√îNG B√ÅO DISCORD
    -- =================================================================
    ["EnableDiscordWebhook"] = true,
    ["WebhookURL"] = "https://discord.com/api/webhooks/1397368466947969147/HbncMuT0ETe6_5q_kKGzkdd7guLfiGqvewr3WuBFfHAxKBJo3TA7R6ad2ex31YkBHo75",
    ["WebhookColor"] = 16738740,
    ["EnablePingOnDonate"] = true,
    ["PingAmount"] = 1000,
    ["PingUserID"] = "",

    -- =================================================================
    -- C√ÄI ƒê·∫∂T T·ª∞ ƒê·ªòNG TR·∫¢ L·ªúI & CHAT
    -- =================================================================
    ["EnableAutoReply"] = true,
    ["ReplyRadius"] = 25,
    ["ReplyCooldown"] = 7,
    ["ReplyRules"] = {
        { keywords = { "hi", "hello", "hey", "sup", "yo", "wsg", "howdy", "greetings", "wassup", "heya" }, replies = { "Hello!", "Hi there", "Hey!", "Yo", "What's up?", "Heya", "Sup", "Heyo!", "What's good?", "Well hello there." } },
        { keywords = { "only","donate", "pls", "give me", "robux pls", "can i have", "spare", "some robux", "can u donate", "plz donate", "can you give", "i need robux" }, replies = { "Sorry, I'm saving up right now.", "I can't donate at the moment, sorry.", "My robux is pending, can't help sorry.", "Sry, saving for something specific.", "Maybe later, I'm trying to reach my own goal.", "Can't right now, good luck though!", "All my robux is tied up, sorry.", "Sorry, my wallet is on a diet.", "I wish I could, but I'm broke lol." } },
        { keywords = { "bot", "auto", "script", "scripter", "macro", "afk farm", "autoclicker", "you a bot?" }, replies = { "I'm not a bot :)", "lol no, I'm a real player.", "Just vibing, not a bot.", "Beep boop? Nah, just kidding.", "I'm a human, I promise!", "Not a script, just dedicated lol.", "Do I look like a bot to you? :P", "Last time I checked, I still need to sleep. So, not a bot.", "01001110 01101111. (That means 'No' in binary)." } },
        { keywords = { "scam", "fake", "report", "scammer", "this is a scam", "don't trust", "he's a scammer", "is this fake" }, replies = { "This is not a scam.", "I'm not a scammer.", "It's legit, no worries.", "100% legit, my friend.", "No scams here, just good vibes.", "I'm just here to play the game like you.", "Why would you think it's a scam?", "The only thing I'm scamming is time, by playing this game.", "You've got the wrong person, I'm just here to chill." } },
        { keywords = { "why are you", "how are you", "spinning", "jumping", "afk" }, replies = { "Just farming for my goal.", "It's part of the grind.", "Doing this for donations." } },
    },

    ["EnableAutoThank"] = true,
    ["ThankYouMessages"] = { "Thanks for the donation!", "Tysm!!", "Thank you so much!", "OMG THANKKK!", "THANKS", "TYSM!" },

    ["EnableAutoSpam"] = true,
    ["SpamInterval"] = 60,
    ["SpamMessages"] = { "Goal: MAX SPIN LEVEL 100üåÄ - 1 ROBUX = +1 SPEED!", "Goal: MAX SPIN LEVEL 100:cyclone: - 1 ROBUX = +1 SPEED!" },

    -- =================================================================
    -- C√ÄI ƒê·∫∂T BOOTH & SPIN
    -- =================================================================
    ["EnableBoothFeatures"] = true,
    ["boothTextFormat"] = "1 DONATE = 1 SPIN SPEED\nGOAL: $GOALK SPEED!",    
    ["hexBox"] = "#ffffff",     
    ["fontFace"] = "SciFi",     
    ["boothOffset"] = 3,     
    ["spinEnabled"] = true,     
    ["spinBaseSpeed"] = 0.25,     
    ["spinSpeedPerR"] = 0.1,     

    -- =================================================================
    -- C√ÄI ƒê·∫∂T HI·ªÜU NƒÇNG & KH√ÅC
    -- =================================================================
    ["EnableGraphicsOptimization"] = true,
    ["EnableCpuOptimization"] = true,
    ["SetSimulationRadiusToZero"] = true,
    ["TargetFps"] = 7,
    ["EnableFileHistory"] = true,
    ["InitialWaitTime"] = 1,
    ["EnableCountdownText"] = true,
    ["EnableCountdownColor"] = true,
}
-- --- K·∫æT TH√öC C√ÄI ƒê·∫∂T ---

-- N·ªÅn t·∫£ng an to√†n (Anti-Cheat Bypass)
local identifyexecutor = identifyexecutor or function() return 'Unknown' end
local cloneref = (identifyexecutor() ~= "Synapse Z" and not identifyexecutor():find("Codex") and cloneref) or function(o) return o end

-- C√°c service c·∫ßn thi·∫øt
local Players = cloneref(game:GetService("Players"))
local TeleportService = cloneref(game:GetService("TeleportService"))
local HttpService = cloneref(game:GetService("HttpService"))
local TextChatService = cloneref(game:GetService("TextChatService"))
local Workspace = cloneref(game:GetService("Workspace"))
local Lighting = cloneref(game:GetService("Lighting"))
local SoundService = cloneref(game:GetService("SoundService"))
local RunService = cloneref(game:GetService("RunService"))
local CoreGui = cloneref(game:GetService("CoreGui"))
local ReplicatedStorage = cloneref(game:GetService("ReplicatedStorage"))
local LocalPlayer = Players.LocalPlayer

-- --- C·∫•u h√¨nh Script (Kh√¥ng n√™n thay ƒë·ªïi) ---
local placeId = game.PlaceId; local currentJobId = game.JobId; local waitTimeBetweenFullScans = 7; local waitTimeBetweenPageFetches = 0.75; local baseRetryDelay = 1; local maxRetryDelay = 16; local PLATFORM_VERTICAL_OFFSET = 0; local SERVER_HISTORY_FILENAME = "server_hop_history.txt"; local SERVER_HOP_GUI_NAME = "ServerHopStatusGUI"; local AFK_PLATFORM_NAME = "MySafeAFKPlatform"; local STATIC_HEAD_ANCHOR_PART_NAME = "AFK_HeadAnchor_StaticCam"; local STATIC_BLACK_SCREEN_PART_NAME = "AFK_BlackScreen_StaticCam"; local NEON_COLORS = { GREEN = Color3.fromRGB(10, 255, 20), YELLOW = Color3.fromRGB(255, 255, 0), BLUE = Color3.fromRGB(0, 150, 255), RED = Color3.fromRGB(255, 20, 20) }

-- --- Bi·∫øn to√†n c·ª•c ---
local playerGui = LocalPlayer and LocalPlayer:WaitForChild("PlayerGui")
local statusScreenGui, infoTextLabel, clockTextLabel, dateTextLabel, statusFrame
local countdownShouldReset = false; local currentCountdownThread = nil; local playerMonitorThread = nil
local Remotes = nil; local spinVelocity = SETTINGS.spinBaseSpeed or 0.25

-- --- Ki·ªÉm tra v√† g√°n h√†m ƒë·ªçc/ghi file ---
local canAccessFiles = false; local writefile_func, readfile_func; if SETTINGS.EnableFileHistory then pcall(function() if writefile and readfile then canAccessFiles, writefile_func, readfile_func = true, writefile, readfile; print("[FileIO] Quy·ªÅn file c√≥ s·∫µn.") else print("[FileIO] Quy·ªÅn file KH√îNG c√≥ s·∫µn.") end end) else print("[FileIO] L·ªãch s·ª≠ file b·ªã T·∫ÆT.") end

-- =================================================================
-- H·ªÜ TH·ªêNG GIAO DI·ªÜN
-- =================================================================
local function createStatusGui()
    if playerGui:FindFirstChild(SERVER_HOP_GUI_NAME) then playerGui[SERVER_HOP_GUI_NAME]:Destroy() end
    statusScreenGui = Instance.new("ScreenGui")
    statusScreenGui.Name = SERVER_HOP_GUI_NAME
    statusScreenGui.ResetOnSpawn, statusScreenGui.ZIndexBehavior, statusScreenGui.IgnoreGuiInset = false, Enum.ZIndexBehavior.Sibling, true
    statusScreenGui.Parent = playerGui

    local backgroundFrame = Instance.new("Frame")
    backgroundFrame.Name = "Background"
    backgroundFrame.Size = UDim2.new(1, 0, 1, 0)
    backgroundFrame.BackgroundColor3 = Color3.new(0, 0, 0)
    backgroundFrame.BorderSizePixel = 0
    backgroundFrame.ZIndex = 1
    backgroundFrame.Parent = statusScreenGui

    statusFrame = Instance.new("Frame")
    statusFrame.Name = "StatusFrame"
    statusFrame.Size = UDim2.new(1, 0, 1, 0)
    statusFrame.BackgroundColor3, statusFrame.BorderSizePixel = NEON_COLORS.GREEN, 0
    statusFrame.BackgroundTransparency = 1
    statusFrame.ZIndex = 2
    statusFrame.Parent = statusScreenGui

    clockTextLabel = Instance.new("TextLabel")
    clockTextLabel.Name = "ClockLabel"
    clockTextLabel.Size = UDim2.new(1, 0, 0, 120)
    clockTextLabel.Position = UDim2.new(0.5, 0, 0.45, 0)
    clockTextLabel.AnchorPoint = Vector2.new(0.5, 0.5)
    clockTextLabel.BackgroundTransparency = 1
    clockTextLabel.TextColor3 = Color3.new(1, 1, 1)
    clockTextLabel.Font = Enum.Font.SciFi
    clockTextLabel.TextScaled = false
    clockTextLabel.TextSize = 110
    clockTextLabel.Text = "00:00:00"
    clockTextLabel.ZIndex = 3
    clockTextLabel.Parent = statusScreenGui

    dateTextLabel = Instance.new("TextLabel")
    dateTextLabel.Name = "DateLabel"
    dateTextLabel.Size = UDim2.new(1, 0, 0, 50)
    dateTextLabel.Position = UDim2.new(0.5, 0, 0.56, 0)
    dateTextLabel.AnchorPoint = Vector2.new(0.5, 0.5)
    dateTextLabel.BackgroundTransparency = 1
    dateTextLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    dateTextLabel.Font = Enum.Font.SourceSansSemibold
    dateTextLabel.TextScaled = false
    dateTextLabel.TextSize = 28
    dateTextLabel.Text = "..."
    dateTextLabel.ZIndex = 3
    dateTextLabel.Parent = statusScreenGui

    infoTextLabel = Instance.new("TextLabel")
    infoTextLabel.Name = "InfoLabel"
    infoTextLabel.Size = UDim2.new(0.9, 0, 0, 60)
    infoTextLabel.Position = UDim2.new(0.5, 0, 1, -10)
    infoTextLabel.AnchorPoint = Vector2.new(0.5, 1)
    infoTextLabel.BackgroundTransparency = 1
    infoTextLabel.TextColor3 = Color3.new(1, 1, 1)
    infoTextLabel.Font = Enum.Font.SourceSans
    infoTextLabel.TextScaled = false
    infoTextLabel.TextSize = 22
    infoTextLabel.TextXAlignment, infoTextLabel.TextYAlignment = Enum.TextXAlignment.Center, Enum.TextYAlignment.Center
    infoTextLabel.TextWrapped = true
    infoTextLabel.Text = "..."
    infoTextLabel.ZIndex = 3
    infoTextLabel.Parent = statusScreenGui
end

local function updateDisplay(state, message)
    task.spawn(function()
        print("[UI] " .. tostring(message))
        if not infoTextLabel or not infoTextLabel.Parent then return end
        local stateColor = NEON_COLORS.GREEN
        if state == "ERROR" then stateColor = NEON_COLORS.YELLOW elseif state == "BOT_DETECTED" then stateColor = NEON_COLORS.RED end
        infoTextLabel.Text = tostring(message)
        infoTextLabel.TextColor3 = stateColor
        if SETTINGS.EnableCountdownColor then
            if statusFrame and statusFrame.Parent then
                if state == "SUCCESS" or state == "ERROR" or state == "BOT_DETECTED" then
                    statusFrame.BackgroundColor3 = stateColor
                    statusFrame.BackgroundTransparency = 0.85
                else
                    statusFrame.BackgroundTransparency = 1
                end
            end
        else
            if statusFrame then statusFrame.BackgroundTransparency = 1 end
        end
    end)
end

local vietnameseDays = { ["Sunday"] = "Ch·ªß Nh·∫≠t", ["Monday"] = "Th·ª© Hai", ["Tuesday"] = "Th·ª© Ba", ["Wednesday"] = "Th·ª© T∆∞", ["Thursday"] = "Th·ª© NƒÉm", ["Friday"] = "Th·ª© S√°u", ["Saturday"] = "Th·ª© B·∫£y" }
local function getVietnameseDateString()
    local dateTable = os.date("*t"); local dayOfWeekEn = os.date("%A"); local dayOfWeekVn = vietnameseDays[dayOfWeekEn] or dayOfWeekEn
    return string.format("%s, ng√†y %02d th√°ng %02d nƒÉm %d", dayOfWeekVn, dateTable.day, dateTable.month, dateTable.year)
end

local function startClock()
    task.spawn(function()
        while task.wait(1) do
            if clockTextLabel and clockTextLabel.Parent then clockTextLabel.Text = os.date("%H:%M:%S") else break end
            if dateTextLabel and dateTextLabel.Parent then dateTextLabel.Text = getVietnameseDateString() end
        end
    end)
end

-- =================================================================
-- C√ÅC H√ÄM TI·ªÜN √çCH
-- =================================================================
local serverHistoryCache = {}; local function loadServerHistory() if not canAccessFiles then return {} end; local historySet = {}; local s, c = pcall(readfile_func, SERVER_HISTORY_FILENAME); if s and c then for line in string.gmatch(c,"[^".."\r\n".."]+") do local tL=line:match("^%s*(.-)%s*$") if tL and #tL>0 then historySet[tL]=true;end end end; local hS=0;for _ in pairs(historySet)do hS=hS+1 end; local mS=SETTINGS.MaxServerHistorySize; if mS and mS>0 and hS>=mS then print(string.format("[FileIO] L·ªãch s·ª≠ server ƒë·∫°t gi·ªõi h·∫°n (%d/%d). ƒêang x√≥a...",hS,mS));if updateDisplay then updateDisplay("INFO","L·ªãch s·ª≠ server ƒë·∫ßy, ƒëang reset...")end;historySet={};pcall(writefile_func,SERVER_HISTORY_FILENAME,"");print("[FileIO] L·ªãch s·ª≠ server ƒë√£ ƒë∆∞·ª£c x√≥a.");task.wait(2)end; serverHistoryCache=historySet;return historySet end
local function addJobIdToHistoryAndSave(jId) if not jId or not canAccessFiles then return end; serverHistoryCache[jId]=true; local l={}; for id in pairs(serverHistoryCache)do table.insert(l,id)end; pcall(writefile_func,SERVER_HISTORY_FILENAME,table.concat(l,"\n")) end
local function createSafePlatform() updateDisplay("INFO", "ƒêang t·∫°o platform..."); if game.Workspace:FindFirstChild(AFK_PLATFORM_NAME) then updateDisplay("INFO", "Platform ƒë√£ c√≥."); return end; local p=Instance.new("Part");p.Name=AFK_PLATFORM_NAME;p.Anchored=true;p.CanCollide=true;p.Size=Vector3.new(20000,40,20000);p.Color=Color3.fromRGB(50,50,50);p.Transparency=0; local char=LocalPlayer.Character; local hum=char and char:FindFirstChildOfClass("Humanoid"); local hrp=char and char:FindFirstChild("HumanoidRootPart"); if hum and hrp then local hrpP=hrp.Position;local hrpSY=hrp.Size.Y;local hipH=hum.HipHeight;local fCIY=hrpP.Y-(hrpSY/2)-hipH;local pTTY=fCIY-PLATFORM_VERTICAL_OFFSET;local pCY=pTTY-(p.Size.Y/2);p.Position=Vector3.new(hrpP.X,pCY,hrpP.Z); else p.Position=Vector3.new(0,-30-PLATFORM_VERTICAL_OFFSET,0); end; p.Parent=game.Workspace; updateDisplay("SUCCESS", "Platform ƒë√£ t·∫°o."); end
local function setupStaticAfkView() updateDisplay("INFO", "Thi·∫øt l·∫≠p view AFK tƒ©nh..."); local player = LocalPlayer; local character = player.Character or player.CharacterAdded:Wait(); if not character then return end; local head = character:WaitForChild("Head", 10); if not head then return end; local camera = workspace.CurrentCamera; if not camera then return end; local staticHeadAnchor = workspace:FindFirstChild(STATIC_HEAD_ANCHOR_PART_NAME) or Instance.new("Part"); staticHeadAnchor.Name=STATIC_HEAD_ANCHOR_PART_NAME; staticHeadAnchor.Size=Vector3.new(0.1,0.1,0.1); staticHeadAnchor.Transparency=1; staticHeadAnchor.CanCollide=false; staticHeadAnchor.Parent=workspace; staticHeadAnchor.CFrame = CFrame.new(head.Position); staticHeadAnchor.Anchored = true; local blackTarget = workspace:FindFirstChild(STATIC_BLACK_SCREEN_PART_NAME) or Instance.new("Part"); blackTarget.Name=STATIC_BLACK_SCREEN_PART_NAME; blackTarget.Size=Vector3.new(2500,2500,10); blackTarget.Color=Color3.new(0,0,0); blackTarget.CanCollide=false; blackTarget.Parent=workspace; local eastPositionFromAnchor = staticHeadAnchor.Position + Vector3.new(150,0,0); blackTarget.CFrame=CFrame.new(eastPositionFromAnchor); blackTarget.Anchored=true; camera.CameraType=Enum.CameraType.Scriptable; camera.CFrame=CFrame.new(staticHeadAnchor.Position,blackTarget.Position); camera.Focus=blackTarget.CFrame; updateDisplay("SUCCESS", "View AFK tƒ©nh ƒë√£ thi·∫øt l·∫≠p.") end
local function optimizeForCpu() if not SETTINGS.EnableCpuOptimization then return end; updateDisplay("INFO", "B·∫Øt ƒë·∫ßu t·ªëi ∆∞u h√≥a CPU..."); pcall(function() if type(setfpscap) == "function" and SETTINGS.TargetFps and SETTINGS.TargetFps > 0 then print("[CPU-Opt] Gi·ªõi h·∫°n FPS ƒëang ho·∫°t ƒë·ªông ·ªü m·ª©c: " .. tostring(SETTINGS.TargetFps)) end; if SETTINGS.SetSimulationRadiusToZero then if LocalPlayer then LocalPlayer.SimulationRadius = 0; print("[CPU-Opt] SimulationRadius ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t v·ªÅ 0.") end end end); updateDisplay("SUCCESS", "T·ªëi ∆∞u h√≥a CPU ho√†n t·∫•t.") end
local function optimizeGraphics() updateDisplay("INFO", "B·∫Øt ƒë·∫ßu t·ªëi ∆∞u ƒë·ªì h·ªça..."); if SETTINGS.EnableSafePlatform then createSafePlatform(); end; task.wait(0.1); pcall(function() local itemsToDel={}; for _,item in pairs(game.Workspace:GetChildren()) do local keep=(LocalPlayer.Character and item.Name==LocalPlayer.Character.Name)or(item==workspace.CurrentCamera)or(SETTINGS.EnableSafePlatform and item.Name==AFK_PLATFORM_NAME)or(SETTINGS.EnableStaticAfkView and(item.Name==STATIC_HEAD_ANCHOR_PART_NAME or item.Name==STATIC_BLACK_SCREEN_PART_NAME));if not keep then table.insert(itemsToDel,item)end end; for _,item in ipairs(itemsToDel)do pcall(function()item:Destroy()end)end;Lighting.GlobalShadows,Lighting.Brightness,Lighting.Ambient,Lighting.OutdoorAmbient,Lighting.ExposureCompensation=false,0,Color3.new(0,0,0),Color3.new(0,0,0),-2;pcall(function()Lighting.Atmosphere:Destroy()end);pcall(function()Lighting.Sky:Destroy()end); if LocalPlayer.PlayerGui then for _,gui in pairs(LocalPlayer.PlayerGui:GetChildren())do if gui.Name~=SERVER_HOP_GUI_NAME then pcall(function()gui:Destroy()end)end end end;local sO=settings();if sO and sO.Rendering then sO.Rendering.QualityLevel=Enum.QualityLevel.Level01;pcall(function()if RunService:IsClient()then RunService:Set3dRenderingEnabled(false)end end)end;SoundService.RespectFilteringEnabled,SoundService.AmbientReverb=true,Enum.ReverbType.NoReverb;for _,sound in pairs(game:GetDescendants())do if sound:IsA("Sound")then sound.Volume=0;sound:Stop()end end; end); updateDisplay("SUCCESS", "ƒê·ªì h·ªça ƒë√£ ƒë∆∞·ª£c t·ªëi ∆∞u."); end
local function rgb(hex) hex = hex:gsub("#", ""); local r = tonumber("0x" .. hex:sub(1, 2)) or 255; local g = tonumber("0x" .. hex:sub(3, 4)) or 255; local b = tonumber("0x" .. hex:sub(5, 6)) or 255; return Color3.fromRGB(r, g, b) end

-- =================================================================
-- LOGIC T√åM SERVER
-- =================================================================
local chosenServer = nil; local serversUrlBase = "https://games.roblox.com/v1/games/" .. placeId .. "/servers/Public?sortOrder=Asc&limit=100"
function searchForServer() if not SETTINGS.EnableFileHistory then serverHistoryCache = {} else loadServerHistory() end; local histC=0;for _ in pairs(serverHistoryCache)do histC=histC+1 end; updateDisplay("INFO", string.format("B·∫Øt ƒë·∫ßu t√¨m server... (Tr√°nh %d)",histC+1)); local sLActive=true; chosenServer=nil; while sLActive and not chosenServer do local nextCur=nil; updateDisplay("INFO", "ƒêang qu√©t server..."); local allScanned=false; while not allScanned and not chosenServer do local pAtt=0;local maxAtt=4;local pFetched=false;local curRetry=baseRetryDelay; while not pFetched and pAtt<maxAtt do pAtt=pAtt+1;if pAtt>1 then updateDisplay("INFO", string.format("Th·ª≠ l·∫°i (%d/%d)...",pAtt,maxAtt));task.wait(curRetry);curRetry=math.min(curRetry*2,maxRetryDelay) end; local s,d=pcall(game.HttpGet,game,serversUrlBase..(nextCur and "&cursor="..nextCur or ""),true);if s then pFetched=true;local sListD=HttpService:JSONDecode(d);if sListD and sListD.data then local pSuitS={}; for _,sInf in ipairs(sListD.data)do if not(sInf.id==currentJobId or serverHistoryCache[sInf.id])then if sInf.playing and sInf.maxPlayers and sInf.maxPlayers>0 then local pR=sInf.playing/sInf.maxPlayers if pR>=SETTINGS.MinPlayerPercentage and pR<SETTINGS.MaxPlayerPercentage and sInf.playing<sInf.maxPlayers then table.insert(pSuitS,sInf)end end end end; if #pSuitS>0 then chosenServer=pSuitS[math.random(1,#pSuitS)];allScanned=true;break end; nextCur=sListD.nextPageCursor;if not nextCur then allScanned=true;end else updateDisplay("ERROR","D·ªØ li·ªáu server l·ªói.")end else updateDisplay("ERROR","L·ªói API.");if pAtt>=maxAtt then allScanned=true end end end;if chosenServer or allScanned then break end;task.wait(waitTimeBetweenPageFetches) end; if chosenServer then updateDisplay("SUCCESS", "ƒê√É CH·ªåN SERVER!");sLActive=false elseif allScanned then updateDisplay("INFO", string.format("Kh√¥ng t√¨m th·∫•y. Ch·ªù %ds.",waitTimeBetweenFullScans));task.wait(waitTimeBetweenFullScans)end end; if chosenServer then updateDisplay("SUCCESS", "Chu·∫©n b·ªã d·ªãch chuy·ªÉn..."); addJobIdToHistoryAndSave(currentJobId); task.wait(1); local sTP,eTP=pcall(TeleportService.TeleportToPlaceInstance,TeleportService,placeId,chosenServer.id,LocalPlayer); if not sTP then updateDisplay("ERROR", "L·ªói d·ªãch chuy·ªÉn! Th·ª≠ l·∫°i..."); serverHistoryCache[chosenServer.id]=true;chosenServer=nil;task.wait(5);searchForServer() end else updateDisplay("ERROR", "Kh√¥ng th·ªÉ t√¨m th·∫•y server. D·ª´ng l·∫°i.") end end

-- =================================================================
-- H·ªÜ TH·ªêNG BOOTH & SPIN
-- =================================================================
local function findRemotes()
    if Remotes then return true end
    updateDisplay("INFO", "ƒêang t√¨m Remotes...")
    for _, v in next, ReplicatedStorage:GetChildren() do
        if v:IsA("ModuleScript") and v.Name:find("Remote") then
            local ok = pcall(function() require(v).Event("PromotionBlimpGiftbux"):FireServer() end)
            if ok then
                Remotes = require(v)
                updateDisplay("SUCCESS", "ƒê√£ t√¨m th·∫•y Remotes.")
                return true
            end
        end
    end
    updateDisplay("ERROR", "Kh√¥ng t√¨m th·∫•y Remotes module.")
    return false
end

local function updateBoothText()
    if not SETTINGS.EnableBoothFeatures or not Remotes then return end
    local stats = LocalPlayer:FindFirstChild("leaderstats"); local raisedObj = stats and stats:FindFirstChild("Raised"); if not raisedObj then return end
    local raised = raisedObj.Value; local goal = math.floor(raised / 1000) + 1; local text = SETTINGS.boothTextFormat:gsub("%$GOAL", tostring(goal))
    local payload = { text = text, textFont = Enum.Font[SETTINGS.fontFace], richText = true, strokeColor = Color3.new(0, 0, 0), strokeOpacity = 0, textColor = rgb(SETTINGS.hexBox), buttonStrokeColor = Color3.new(0, 0, 0), buttonTextColor = Color3.new(1, 1, 1), buttonColor = Color3.fromRGB(98, 255, 0), buttonHoverColor = Color3.fromRGB(98, 255, 0), buttonLayout = "" }
    Remotes.Event("SetCustomization"):FireServer(payload, "booth")
    print("[Booth] VƒÉn b·∫£n ƒë√£ c·∫≠p nh·∫≠t:", text)
end

local function updateSpinSpeed()
    if not SETTINGS.EnableBoothFeatures or not SETTINGS.spinEnabled then return end
    local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart"); local spin = root and root:FindFirstChild("Spin")
    if spin then spin.AngularVelocity = Vector3.new(0, spinVelocity, 0) end
end

local function startSpin()
    if not SETTINGS.EnableBoothFeatures or not SETTINGS.spinEnabled then return end
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait(); local root = char:WaitForChild("HumanoidRootPart")
    if root:FindFirstChild("Spin") then root:FindFirstChild("Spin"):Destroy() end
    local spin = Instance.new("BodyAngularVelocity"); spin.Name = "Spin"; spin.MaxTorque = Vector3.new(0, math.huge, 0); spin.AngularVelocity = Vector3.new(0, spinVelocity, 0); spin.P = 1250; spin.Parent = root
end

local function claimAndSetupBooth(boothIdOverride)
    if not SETTINGS.EnableBoothFeatures then updateDisplay("INFO", "T√≠nh nƒÉng Booth b·ªã t·∫Øt."); return end
    if not Remotes then updateDisplay("ERROR", "Remotes ch∆∞a s·∫µn s√†ng, kh√¥ng th·ªÉ claim booth."); return end
    updateDisplay("INFO", "ƒêang t√¨m MapUI...")
    local boothUI; local ok, result = pcall(function() return Workspace:WaitForChild("MapUI", 5) end); if ok and result then boothUI = result else local gui = LocalPlayer:FindFirstChild("PlayerGui"); boothUI = gui and gui:FindFirstChild("MapUIContainer") and gui.MapUIContainer:FindFirstChild("MapUI") end
    if not boothUI then updateDisplay("ERROR", "Kh√¥ng t√¨m th·∫•y MapUI ƒë·ªÉ claim booth."); return end
    updateDisplay("SUCCESS", "ƒê√£ t√¨m th·∫•y MapUI.")
    local boothFrames = boothUI:WaitForChild("BoothUI"); local interactions = Workspace:WaitForChild("BoothInteractions"); local mainCheckPosition = Vector3.new(165.161, 0, 311.636);
    local chosen
    if boothIdOverride then
        updateDisplay("INFO", "ƒêang th·ª≠ claim booth ID: " .. boothIdOverride); chosen = boothIdOverride
    else
        updateDisplay("INFO", "ƒêang t√¨m booth tr·ªëng t·ª± ƒë·ªông..."); local unclaimed = {}
        for _, frame in ipairs(boothFrames:GetChildren()) do
            if frame:FindFirstChild("Details") and frame.Details.Owner.Text == "unclaimed" then
                local id = tonumber(frame.Name:match("%d+")); if id then for _, inter in ipairs(interactions:GetChildren()) do if inter:GetAttribute("BoothSlot") == id then if (Vector3.new(inter.Position.X, 0, inter.Position.Z) - mainCheckPosition).Magnitude < 92 then table.insert(unclaimed, id); break end end end end
            end
        end
        if #unclaimed == 0 then updateDisplay("ERROR", "Kh√¥ng c√≥ booth tr·ªëng."); return end
        chosen = unclaimed[1]
    end
    local success = pcall(function() Remotes.Event("ClaimBooth"):InvokeServer(chosen); task.wait(0.5); local b = boothFrames:FindFirstChild("BoothUI" .. chosen); if not b or not string.find(b.Details.Owner.Text, LocalPlayer.DisplayName) then error("Claim kh√¥ng th√†nh c√¥ng ho·∫∑c booth ƒë√£ b·ªã ng∆∞·ªùi kh√°c l·∫•y.") end end)
    if not success then updateDisplay("ERROR", "Claim booth #" .. chosen .. " th·∫•t b·∫°i."); return end
    for _, booth in ipairs(interactions:GetChildren()) do
        if booth:GetAttribute("BoothSlot") == chosen then
            local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait(); local root = char:WaitForChild("HumanoidRootPart"); local lookAt = Vector3.new(mainCheckPosition.X, root.Position.Y, mainCheckPosition.Z); local target = booth.CFrame * CFrame.new(0, 0, SETTINGS.boothOffset); root.CFrame = CFrame.new(target.Position, lookAt)
            updateDisplay("SUCCESS", "ƒê√£ claim booth #" .. chosen); task.wait(0.2); updateBoothText(); if SETTINGS.spinEnabled then startSpin() end; break
        end
    end
end

-- =================================================================
-- QU·∫¢N L√ù AFK & C√ÅC B·ªò L·∫ÆNG NGHE
-- =================================================================
local function safeChat(msg)
    local ChatChannel = TextChatService and TextChatService.TextChannels and TextChatService.TextChannels.RBXGeneral
    if ChatChannel then pcall(function() ChatChannel:SendAsync(msg) end) else print("[Chat] Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn, k√™nh chat kh√¥ng t·ªìn t·∫°i.") end
end

function startInitialCountdown()
    updateDisplay("INFO", "B·∫Øt ƒë·∫ßu chu tr√¨nh AFK...");
    if currentCountdownThread and coroutine.status(currentCountdownThread) ~= "dead" then pcall(coroutine.close, currentCountdownThread); currentCountdownThread = nil end
    local function performCountdownThenSearch(minutesToWait)
        if not minutesToWait or minutesToWait <= 0 then updateDisplay("ERROR", "Th·ªùi gian ch·ªù l·ªói."); searchForServer(); return end
        if not SETTINGS.EnableCountdownText then if infoTextLabel then infoTextLabel.Text = "" end end
        if not SETTINGS.EnableCountdownColor then if statusFrame then statusFrame.BackgroundTransparency = 1 end end
        local totalS = minutesToWait * 60
        for i = totalS, 0, -1 do
            if countdownShouldReset and SETTINGS.EnableDonateReset then
                countdownShouldReset = false; if infoTextLabel then infoTextLabel.Text = "" end; if statusFrame then statusFrame.BackgroundTransparency = 1 end
                updateDisplay("SUCCESS", "Donate! Reset th·ªùi gian."); startInitialCountdown(); return
            end
            if SETTINGS.EnableCountdownText then
                if infoTextLabel and infoTextLabel.Parent then
                    local currentPlayers = #Players:GetPlayers(); local maxPlayers = Players.MaxPlayers
                    local playerCountText = string.format("Players: %d/%d", currentPlayers, maxPlayers)
                    local timerText = string.format("Next hop: %02d:%02d", math.floor(i/60), i%60)
                    infoTextLabel.Text = string.format("%s\n%s", timerText, playerCountText); infoTextLabel.TextColor3 = Color3.new(1,1,1)
                end
            end
            if SETTINGS.EnableCountdownColor then
                if statusFrame and statusFrame.Parent then
                    statusFrame.BackgroundColor3 = Color3.new(0, 0, 0); statusFrame.BackgroundTransparency = 0.8
                end
            end
            task.wait(1)
        end
        if infoTextLabel then infoTextLabel.Text = "" end; if statusFrame then statusFrame.BackgroundTransparency = 1 end
        updateDisplay("SUCCESS", "H·∫øt gi·ªù! B·∫Øt ƒë·∫ßu t√¨m server..."); searchForServer()
    end
    currentCountdownThread = coroutine.create(function()
        local s,e = pcall(performCountdownThenSearch, SETTINGS.WaitMinutes); if not s then updateDisplay("ERROR", "L·ªói Coroutine. Th·ª≠ l·∫°i sau 5s..."); task.wait(5); if SETTINGS.EnableServerHop then startInitialCountdown() end end
    end); coroutine.resume(currentCountdownThread)
end

-- [ƒê√É N√ÇNG C·∫§P] H√†m ki·ªÉm tra s·ªë ng∆∞·ªùi ch∆°i th√¥ng minh h∆°n
local function startPlayerCountMonitor()
    if not SETTINGS.EnablePlayerCountCheck or (SETTINGS.MinPlayerThreshold or 0) <= 0 then return end
    if playerMonitorThread and coroutine.status(playerMonitorThread) ~= "dead" then pcall(coroutine.close, playerMonitorThread); playerMonitorThread = nil end

    playerMonitorThread = coroutine.create(function()
        local lowPlayerCountChecks = 0
        local maxChecks = SETTINGS.LowPlayerConsecutiveChecks or 3

        while true do
            task.wait(60) -- Ki·ªÉm tra m·ªói 60 gi√¢y
            if not SETTINGS.EnablePlayerCountCheck or not SETTINGS.EnableServerHop then break end

            local currentPlayers = #Players:GetPlayers()
            
            if currentPlayers < SETTINGS.MinPlayerThreshold then
                lowPlayerCountChecks = lowPlayerCountChecks + 1
                updateDisplay("ERROR", string.format("Server v·∫Øng! (%d/%d ng∆∞·ªùi)\nKi·ªÉm tra l·∫°i (%d/%d)...", currentPlayers, SETTINGS.MinPlayerThreshold, lowPlayerCountChecks, maxChecks))
                
                if lowPlayerCountChecks >= maxChecks then
                    updateDisplay("ERROR", string.format("Server v·∫Øng qu√° l√¢u! ƒêang t√¨m server m·ªõi..."))
                    
                    if currentCountdownThread and coroutine.status(currentCountdownThread) ~= "dead" then pcall(coroutine.close, currentCountdownThread); currentCountdownThread = nil end
                    if playerMonitorThread and coroutine.status(playerMonitorThread) ~= "dead" then pcall(coroutine.close, playerMonitorThread); playerMonitorThread = nil end
                    
                    task.wait(3)
                    searchForServer()
                    break 
                end
            else
                if lowPlayerCountChecks > 0 then
                    updateDisplay("SUCCESS", "S·ªë ng∆∞·ªùi ch∆°i ƒë√£ ·ªïn ƒë·ªãnh l·∫°i.")
                    lowPlayerCountChecks = 0
                end
                print(string.format("[PlayerMonitor] Check OK: %d/%d players.", currentPlayers, SETTINGS.MinPlayerThreshold))
            end
        end
    end)
    coroutine.resume(playerMonitorThread)
end

-- =================================================================
-- [N√ÇNG C·∫§P] H√ÄM KI·ªÇM TRA T√ÄI KHO·∫¢N C·∫¶N N√â (CH·ªà 1 L·∫¶N)
-- =================================================================
local function checkAvoidPlayersOnce()
    if not SETTINGS.EnableAvoidPlayers or not SETTINGS.AVOID_PLAYERS or #SETTINGS.AVOID_PLAYERS == 0 then
        return false -- Tr·∫£ v·ªÅ false n·∫øu t√≠nh nƒÉng b·ªã t·∫Øt ho·∫∑c danh s√°ch tr·ªëng
    end

    -- T·∫°o m·ªôt set ƒë·ªÉ tra c·ª©u t√™n ng∆∞·ªùi ch∆°i nhanh h∆°n
    local avoidNamesSet = {}
    for _, name in ipairs(SETTINGS.AVOID_PLAYERS) do
        avoidNamesSet[name] = true
    end

    local playersInServer = Players:GetPlayers()
    for _, player in ipairs(playersInServer) do
        -- Quan tr·ªçng: Kh√¥ng ki·ªÉm tra ch√≠nh m√¨nh
        if player.Name ~= LocalPlayer.Name and avoidNamesSet[player.Name] then
            updateDisplay("ERROR", string.format("Ph√°t hi·ªán t√†i kho·∫£n '%s'!\nƒêang t√¨m server m·ªõi...", player.Name))
            
            task.wait(3)
            searchForServer()
            return true -- Tr·∫£ v·ªÅ true ƒë·ªÉ b√°o hi·ªáu r·∫±ng ƒë√£ b·∫Øt ƒë·∫ßu hop
        end
    end

    print("[AvoidPlayerCheck] Qu√©t 1 l·∫ßn OK, kh√¥ng ph√°t hi·ªán t√†i kho·∫£n c·∫ßn n√©.")
    return false -- Tr·∫£ v·ªÅ false n·∫øu kh√¥ng t√¨m th·∫•y ai
end

local function setupAutoReconnect() pcall(function() local promptOverlay = game.CoreGui:WaitForChild('RobloxPromptGui'):WaitForChild('promptOverlay'); promptOverlay.ChildAdded:Connect(function(child) if child.Name == 'ErrorPrompt' and child:IsA('Frame') then updateDisplay("ERROR", "Ph√°t hi·ªán l·ªói! ƒêang th·ª≠ k·∫øt n·ªëi l·∫°i..."); local success, err = pcall(function() TeleportService:Teleport(placeId, LocalPlayer) end); if not success then task.wait(2); repeat TeleportService:Teleport(placeId, LocalPlayer); task.wait(5) until false end end end); updateDisplay("SUCCESS", "T·ª± ƒë·ªông k·∫øt n·ªëi l·∫°i ƒë√£ k√≠ch ho·∫°t.") end) end
local function setupAutoReply() if not SETTINGS.EnableAutoReply then return end; local Cooldowns = {}; Players.PlayerChatted:Connect(function(_, player, message) if not SETTINGS.EnableAutoReply then return end; if player == LocalPlayer then return end; if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end; if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end; local distance = (player.Character.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude; if distance > SETTINGS.ReplyRadius then return end; if Cooldowns[player] and tick() - Cooldowns[player] < SETTINGS.ReplyCooldown then return end; local lowerMsg = string.lower(message); local replied = false; for _, rule in ipairs(SETTINGS.ReplyRules) do for _, keyword in ipairs(rule.keywords) do if string.find(lowerMsg, keyword) then local reply = rule.replies[math.random(1, #rule.replies)]; task.wait(math.random(1,3)); safeChat(reply); Cooldowns[player] = tick(); replied = true; break end end; if replied then break end end end); updateDisplay("SUCCESS", "T·ª± ƒë·ªông tr·∫£ l·ªùi ƒë√£ k√≠ch ho·∫°t.") end

local function setupAutoSpam()
    if not SETTINGS.EnableAutoSpam or not SETTINGS.SpamMessages or #SETTINGS.SpamMessages == 0 then return end
    task.spawn(function()
        updateDisplay("SUCCESS", "T√≠nh nƒÉng AutoSpam ƒë√£ k√≠ch ho·∫°t.")
        while task.wait(SETTINGS.SpamInterval) do
            if not SETTINGS.EnableAutoSpam then break end
            local message = SETTINGS.SpamMessages[math.random(1, #SETTINGS.SpamMessages)]
            safeChat(message); print("[AutoSpam] ƒê√£ g·ª≠i: " .. message)
        end
    end)
end

local function setupUnifiedDonationListener()
    if not Remotes then updateDisplay("ERROR", "Remotes ch∆∞a s·∫µn s√†ng, kh√¥ng th·ªÉ l·∫Øng nghe donate."); return end
    local leaderstats = LocalPlayer:WaitForChild("leaderstats", 30); if not leaderstats then updateDisplay("ERROR", "Kh√¥ng t√¨m th·∫•y leaderstats sau 30 gi√¢y."); return end
    local raised = leaderstats:WaitForChild("Raised", 30); if not raised then updateDisplay("ERROR", "Kh√¥ng t√¨m th·∫•y 'Raised' trong leaderstats."); return end
    local lastRaised = raised.Value
    local function sendWebhook(amount, total)
        if not SETTINGS.EnableDiscordWebhook or not SETTINGS.WebhookURL or SETTINGS.WebhookURL == "" then return end
        local pingContent = nil; if SETTINGS.EnablePingOnDonate and amount >= (SETTINGS.PingAmount or 0) then if SETTINGS.PingUserID and SETTINGS.PingUserID ~= "" then pingContent = string.format("<@%s>", SETTINGS.PingUserID) else pingContent = "@everyone" end end
        local embed = { description = string.format("**%s**\n# +%d\nTOTAL : %d", LocalPlayer.Name, amount, total), color = SETTINGS.WebhookColor }; local payloadData = { embeds = { embed } }; if pingContent then payloadData.content = pingContent end
        local payload = HttpService:JSONEncode(payloadData); local req = (syn and syn.request) or (http and http.request) or (fluxus and fluxus.request) or request
        if req then pcall(function() req({ Url = SETTINGS.WebhookURL, Method = "POST", Headers = { ["Content-Type"] = "application/json" }, Body = payload }) end) else updateDisplay("ERROR", "[Webhook] Kh√¥ng t√¨m th·∫•y h√†m request.") end
    end
    raised.Changed:Connect(function(newRaisedValue)
        local difference = newRaisedValue - lastRaised
        if difference > 0 then
            sendWebhook(difference, newRaisedValue)
            if SETTINGS.EnableDonateReset then countdownShouldReset = true end
            if SETTINGS.EnableBoothFeatures and SETTINGS.spinEnabled then
                spinVelocity += difference * SETTINGS.spinSpeedPerR; updateSpinSpeed(); print("üéâ Nh·∫≠n " .. difference .. " R$ ‚Üí Spin speed: " .. string.format("%.2f", spinVelocity))
            end
            if SETTINGS.EnableBoothFeatures then task.wait(0.1); updateBoothText() end
            if SETTINGS.EnableAutoThank and SETTINGS.ThankYouMessages and #SETTINGS.ThankYouMessages > 0 then
                task.wait(math.random(1, 2)); local message = SETTINGS.ThankYouMessages[math.random(1, #SETTINGS.ThankYouMessages)]; safeChat(message); print("[AutoThank] ƒê√£ c·∫£m ∆°n: " .. message)
            end
        end
        lastRaised = newRaisedValue
    end)
    updateDisplay("SUCCESS", "B·ªô l·∫Øng nghe donate h·ª£p nh·∫•t ƒë√£ k√≠ch ho·∫°t.")
end

-- =================================================================
-- H√ÄM QU√âT BOT
-- =================================================================
local function scanForBots() updateDisplay("INFO", "B·∫Øt ƒë·∫ßu qu√©t bot..."); task.wait(2); local _boothlocation; local suc, _shuffled = pcall(function() return Workspace:WaitForChild('MapUI', 5) end); if not suc or not _shuffled then local playerGuiMap = LocalPlayer:WaitForChild("PlayerGui"); if playerGuiMap then local mapUiContainer = playerGuiMap:WaitForChild('MapUIContainer', 5); if mapUiContainer then _boothlocation = mapUiContainer:WaitForChild('MapUI', 5) end end else _boothlocation = _shuffled end; if not _boothlocation then updateDisplay("ERROR", "L·ªñI: Kh√¥ng t√¨m th·∫•y MapUI ƒë·ªÉ qu√©t bot."); return 0 end; local boothUI = _boothlocation:WaitForChild("BoothUI"); if not boothUI then updateDisplay("ERROR", "L·ªñI: Kh√¥ng t√¨m th·∫•y BoothUI b√™n trong MapUI."); return 0 end; local currentBotCount = 0; for _, uiFrame in ipairs(boothUI:GetChildren()) do local success, err = pcall(function() local ownerName = uiFrame.Details.Owner.Text; if ownerName ~= "unclaimed" then local boothText = string.lower(uiFrame.Sign.TextLabel.Text); for _, keyword in ipairs(SETTINGS.BOT_KEYWORDS) do if string.find(boothText, keyword) then currentBotCount = currentBotCount + 1; local alertMessage = string.format("PH√ÅT HI·ªÜN BOT #%d\n'%s'", currentBotCount, ownerName); updateDisplay("BOT_DETECTED", alertMessage); task.wait(2.5); break end end end end); if not success then print("[Anti-Bot] L·ªói khi qu√©t gian h√†ng: " .. tostring(err)) end end; updateDisplay("INFO", "Qu√©t xong. Ph√°t hi·ªán: " .. currentBotCount .. " bot."); task.wait(3); return currentBotCount end

-- =================================================================
-- LOGIC KH·ªûI CH·∫†Y CH√çNH
-- =================================================================
task.spawn(function()
    pcall(createStatusGui)
    startClock()
    updateDisplay("INFO", "ƒêang kh·ªüi t·∫°o...")
    task.wait(0.5)

    if type(setfpscap) == "function" and SETTINGS.TargetFps and SETTINGS.TargetFps > 0 then task.spawn(function() while task.wait() do pcall(setfpscap, SETTINGS.TargetFps) end end) end
    if SETTINGS.EnableAutoReconnect then task.spawn(setupAutoReconnect) end
    if SETTINGS.EnableAutoReply then task.spawn(setupAutoReply) end
    if SETTINGS.EnableAutoSpam then task.spawn(setupAutoSpam) end
    
    LocalPlayer.CharacterAdded:Connect(function(character)
        task.wait(1)
        if SETTINGS.EnableBoothFeatures and SETTINGS.spinEnabled and Remotes then
            startSpin(); updateSpinSpeed()
        end
    end)

    updateDisplay("INFO", string.format("Ch·ªù game t·∫£i trong %d gi√¢y...", SETTINGS.InitialWaitTime))
    task.wait(SETTINGS.InitialWaitTime)
    
    local remotesFound = findRemotes()
    if remotesFound then
        updateDisplay("SUCCESS", "Remotes ƒë√£ s·∫µn s√†ng. B·∫Øt ƒë·∫ßu thi·∫øt l·∫≠p c√°c t√≠nh nƒÉng.")
        task.spawn(setupUnifiedDonationListener)
        task.spawn(claimAndSetupBooth) 
    else
        updateDisplay("ERROR", "Kh√¥ng t√¨m th·∫•y Remotes. C√°c t√≠nh nƒÉng Booth/Spin s·∫Ω kh√¥ng ho·∫°t ƒë·ªông.")
    end
    
    updateDisplay("INFO", "B·∫Øt ƒë·∫ßu lu·ªìng quy·∫øt ƒë·ªãnh ch√≠nh...")
    task.wait(2)

    if SETTINGS.EnableServerHop then
        -- B∆∞·ªõc 1: Qu√©t bot
        local botCount = 0
        if SETTINGS.EnableAntiBotScan then botCount = scanForBots() end

        if SETTINGS.EnableAntiBotScan and botCount >= SETTINGS.DETECTION_THRESHOLD then
            updateDisplay("ERROR", string.format("Ph√°t hi·ªán %d/%d bot!\nƒêang t√¨m server m·ªõi...", botCount, SETTINGS.DETECTION_THRESHOLD))
            task.wait(3)
            searchForServer()
        else
            -- B∆∞·ªõc 2: Qu√©t t√†i kho·∫£n c·∫ßn n√© (ch·ªâ 1 l·∫ßn)
            local willHopForAvoid = checkAvoidPlayersOnce()

            -- B∆∞·ªõc 3: N·∫øu kh√¥ng hop v√¨ l√Ω do n√†o ·ªü tr√™n, b·∫Øt ƒë·∫ßu AFK
            if not willHopForAvoid then
                if SETTINGS.EnableAntiBotScan then updateDisplay("SUCCESS", "Server s·∫°ch.\nB·∫Øt ƒë·∫ßu AFK.") else updateDisplay("INFO", "B·ªè qua qu√©t bot.\nB·∫Øt ƒë·∫ßu AFK.") end
                task.wait(2)
                
                if SETTINGS.EnableSafePlatform then createSafePlatform() end
                if SETTINGS.EnableStaticAfkView then setupStaticAfkView() end
                if SETTINGS.EnableCpuOptimization then optimizeForCpu() end
                if SETTINGS.EnableGraphicsOptimization then optimizeGraphics() end
                
                startInitialCountdown()
                startPlayerCountMonitor()
            end
        end
    else
        if SETTINGS.EnableSafePlatform then createSafePlatform() end
        if SETTINGS.EnableStaticAfkView then setupStaticAfkView() end
        if SETTINGS.EnableCpuOptimization then optimizeForCpu() end
        if SETTINGS.EnableGraphicsOptimization then optimizeGraphics() end
        updateDisplay("INFO", "Server Hop T·∫ÆT.\nHo√†n th√†nh thi·∫øt l·∫≠p.")
    end
    print("[MainInit] Script ƒë√£ ho√†n t·∫•t.")
end)
