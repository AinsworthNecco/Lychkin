-- ===================================================================
-- SCRIPT G·ªòP: LYCHKIN'S PLSDONATE HELPER V2 (FLUENT UI)
-- T√°c gi·∫£: Lychkin & Gemini (Chuy·ªÉn th·ªÉ v√† t√°i c·∫•u tr√∫c)
-- Ch·ª©c nƒÉng: Giao di·ªán Fluent UI v·ªõi ƒë·∫ßy ƒë·ªß t√≠nh nƒÉng autofarm, hop server, v√† t√πy ch·ªânh.
-- C·∫•u tr√∫c: D·ª±a tr√™n s∆∞·ªùn script do ng∆∞·ªùi d√πng cung c·∫•p.
-- ===================================================================

-- Ch·ªù game t·∫£i xong ho√†n to√†n
repeat task.wait() until game:IsLoaded()

-- Ch·ªâ ch·∫°y trong game PLS DONATE ho·∫∑c PLS DONATE üîä (VOICE) ƒë·ªÉ tr√°nh l·ªói
if game.PlaceId ~= 8737602449 and game.PlaceId ~= 8943844393 then return end

--[[---------------------------------------------------------------------------]]
--[                                  SERVICES                                   ]
--[[---------------------------------------------------------------------------]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local CoreGui = game:GetService("CoreGui")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local TextChatService = game:GetService("TextChatService")
local VoiceChatService = game:GetService("VoiceChatService")

--[[---------------------------------------------------------------------------]]
--[                                  PLAYER                                     ]
--[[---------------------------------------------------------------------------]]

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local leaderstats = LocalPlayer:WaitForChild("leaderstats")
local raisedStat = leaderstats:WaitForChild("Raised")

--[[---------------------------------------------------------------------------]]
--[                                  BI·∫æN C·ª§C B·ªò                                 ]
--[[---------------------------------------------------------------------------]]

local Remotes
local unclaimedBooth = {}
local currentBoothNumber = nil
local mainCheckPosition = Vector3.new(165.161, 0, 311.636)
local hopTimer, beggingSpam, lastRaisedValue
local isVoiceChatEnabled = false
local boothLocationUI

-- Map path coordinates
local LAP_PATH = {
    {166.584, 3.47699, 371.398}, {228.765, 3.57067, 332.55},
    {225.878, 3.57066, 274.96}, {169.654, 4.11481, 232.826},
    {102.625, 3.57066, 274.941}, {109.353, 3.57066, 351.28},
    {166.584, 3.47699, 371.399}
}

--[[---------------------------------------------------------------------------]]
--[                              KH·ªûI T·∫†O FLUENT                                ]
--[[---------------------------------------------------------------------------]]

local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local Window = Fluent:CreateWindow({
    Title = "Lychkin's PlsDonate v2.0",
    SubTitle = "b·ªüi Lychkin & Gemini",
    TabWidth = 160,
    Size = UDim2.fromOffset(600, 500),
    Acrylic = true,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.RightControl
})

local Tabs = {
    AutoFarm = Window:AddTab({ Title = "T·ª± ƒê·ªông Farm", Icon = "rbxassetid://10433222234" }),
    Hop = Window:AddTab({ Title = "Hop Server", Icon = "rbxassetid://8922329397" }),
    Settings = Window:AddTab({ Title = "C√†i ƒê·∫∑t", Icon = "rbxassetid://10433212871" }),
    Credits = Window:AddTab({ Title = "Th√¥ng Tin", Icon = "rbxassetid://4602928399"})
}

-- C·∫•u h√¨nh Options ƒë·ªÉ l∆∞u c√†i ƒë·∫∑t
local Options = Fluent.Options

--[[---------------------------------------------------------------------------]]
--[                                 C√ÄI ƒê·∫∂T OPTIONS                             ]
--[[---------------------------------------------------------------------------]]

-- Tab AutoFarm > Booth
Options.TextUpdate = Fluent:AddToggle("TextUpdate", { Title = "T·ª± ƒë·ªông c·∫≠p nh·∫≠t booth", Default = true })
Options.TextUpdateDelay = Fluent:AddSlider("TextUpdateDelay", { Title = "ƒê·ªô tr·ªÖ c·∫≠p nh·∫≠t (gi√¢y)", Default = 30, Min = 1, Max = 300, Rounding = 0 })
Options.CustomBoothText = Fluent:AddTextbox("CustomBoothText", { Title = "N·ªôi dung booth", Default = "C·∫£m ∆°n ƒë√£ donate! ($C/$G)" })
Options.RobuxGoal = Fluent:AddTextbox("RobuxGoal", { Title = "M·ª•c ti√™u Robux c·ªông th√™m", Default = "100" })
Options.TextColorHex = Fluent:AddTextbox("TextColorHex", { Title = "M√†u ch·ªØ (HEX)", Default = "#32CD32" })
Options.BoothFont = Fluent:AddDropdown("BoothFont", {
    Title = "Font ch·ªØ booth",
    Default = "SciFi",
    Values = {"AmaticSC", "Antique", "Arcade", "Arial", "Bangers", "Bodoni", "Cartoon", "Code", "Creepster", "DenkOne", "Fantasy", "Fondamento", "FredokaOne", "Garamond", "Gotham", "GrenzeGotisch", "Highway", "IndieFlower", "JosefinSans", "Jura", "Kalam", "Legacy", "LuckiestGuy", "Merriweather", "Michroma", "Nunito", "Oswald", "PatrickHand", "PermanentMarker", "Roboto", "Sarpanch", "SciFi", "SourceSans", "SpecialElite", "TitilliumWeb", "Ubuntu"}
})
Options.StandingPosition = Fluent:AddDropdown("StandingPosition", { Title = "V·ªã tr√≠ ƒë·ª©ng", Default = "Tr∆∞·ªõc booth", Values = {"Tr∆∞·ªõc booth", "Sau booth", "B√™n tr√°i", "B√™n ph·∫£i"} })

-- Tab AutoFarm > Chat
Options.AutoThanks = Fluent:AddToggle("AutoThanks", { Title = "T·ª± ƒë·ªông c·∫£m ∆°n", Default = true })
Options.ThanksDelay = Fluent:AddSlider("ThanksDelay", { Title = "ƒê·ªô tr·ªÖ c·∫£m ∆°n (gi√¢y)", Default = 3, Min = 0, Max = 60, Rounding = 1 })
Options.ThanksMessages = Fluent:AddTextbox("ThanksMessages", { Title = "Tin nh·∫Øn c·∫£m ∆°n (m·ªói d√≤ng 1 tin)", Default = "C·∫£m ∆°n b·∫°n nhi·ªÅu!\nTysm!\nTy :)"})
Options.AutoBeg = Fluent:AddToggle("AutoBeg", { Title = "T·ª± ƒë·ªông xin donate", Default = false })
Options.BegDelay = Fluent:AddSlider("BegDelay", { Title = "ƒê·ªô tr·ªÖ xin donate (gi√¢y)", Default = 300, Min = 30, Max = 1000, Rounding = 0 })
Options.BegMessages = Fluent:AddTextbox("BegMessages", { Title = "Tin nh·∫Øn xin donate (m·ªói d√≤ng 1 tin)", Default = "Xin h√£y donate, m√¨nh ƒëang c·∫ßn R$!\n1 R$ = 1 ƒë·ªông l·ª±c" })

-- Tab AutoFarm > Donation Effects
Options.DanceChoice = Fluent:AddDropdown("DanceChoice", { Title = "ƒêi·ªáu nh·∫£y", Default = "Dance 1", Values = {"T·∫Øt", "Dance 1", "Dance 2", "Dance 3"} })
Options.DonationJump = Fluent:AddToggle("DonationJump", { Title = "Nh·∫£y khi ƒë∆∞·ª£c donate", Default = false })
Options.JumpsPerRobux = Fluent:AddSlider("JumpsPerRobux", { Title = "S·ªë l·∫ßn nh·∫£y / 1 R$", Default = 1, Min = 1, Max = 10, Rounding = 0 })
Options.SpinOnDonate = Fluent:AddToggle("SpinOnDonate", { Title = "Xoay khi ƒë∆∞·ª£c donate (1R$ = +t·ªëc ƒë·ªô)", Default = true })
Options.SpinSpeedMultiplier = Fluent:AddSlider("SpinSpeedMultiplier", { Title = "H·ªá s·ªë nh√¢n t·ªëc ƒë·ªô xoay", Default = 1, Min = 0.1, Max = 10, Rounding = 1 })
Options.JumpBoostOnDonate = Fluent:AddToggle("JumpBoostOnDonate", { Title = "TƒÉng s·ª©c nh·∫£y (1R$ = +1 power)", Default = false })
Options.GravityChangeOnDonate = Fluent:AddToggle("GravityChangeOnDonate", { Title = "Gi·∫£m tr·ªçng l·ª±c (1R$ = -1 gravity)", Default = false })
Options.HelicopterOnDonate = Fluent:AddToggle("HelicopterOnDonate", { Title = "Hi·ªáu ·ª©ng tr·ª±c thƒÉng", Default = false })
Options.RunLapOnDonate = Fluent:AddToggle("RunLapOnDonate", { Title = "Ch·∫°y 1 v√≤ng map / 1 R$", Default = false })

-- Tab Hop
Options.AutoHop = Fluent:AddToggle("AutoHop", { Title = "T·ª± ƒë·ªông hop server", Default = true })
Options.HopDelay = Fluent:AddSlider("HopDelay", { Title = "ƒê·ªô tr·ªÖ hop (ph√∫t)", Default = 15, Min = 5, Max = 120, Rounding = 0 })
Options.HopToVC = Fluent:AddToggle("HopToVC", { Title = "∆Øu ti√™n server Voice Chat", Default = false })
Options.RandomHopType = Fluent:AddToggle("RandomHopType", { Title = "Hop ng·∫´u nhi√™n (Th∆∞·ªùng/VC)", Default = false })
Options.HopOnDonate = Fluent:AddToggle("HopOnDonate", { Title = "Hop sau khi ƒë∆∞·ª£c donate", Default = false })
Options.MinDonateToHop = Fluent:AddSlider("MinDonateToHop", { Title = "R$ donate t·ªëi thi·ªÉu ƒë·ªÉ hop", Default = 0, Min = 0, Max = 10000, Rounding = 0 })
Options.HopOnGoal = Fluent:AddToggle("HopOnGoal", { Title = "Hop khi ƒë·∫°t m·ª•c ti√™u R$ trong server", Default = false })
Options.HopGoalAmount = Fluent:AddSlider("HopGoalAmount", { Title = "M·ª•c ti√™u R$ ƒë·ªÉ hop", Default = 1000, Min = 10, Max = 50000, Rounding = 0 })
Options.HopOnFriendJoin = Fluent:AddToggle("HopOnFriendJoin", { Title = "Hop khi b·∫°n b√® v√†o server", Default = true })
Options.AntiBotHop = Fluent:AddToggle("AntiBotHop", { Title = "Hop kh·ªèi server c√≥ nhi·ªÅu bot", Default = true })

-- Tab Settings > General
Options.DisableRendering = Fluent:AddToggle("DisableRendering", { Title = "T·∫Øt render (TƒÉng FPS)", Default = false })
Options.FpsLimit = Fluent:AddSlider("FpsLimit", { Title = "Gi·ªõi h·∫°n FPS", Default = 60, Min = 5, Max = 240, Rounding = 0 })
Options.AnonymousMode = Fluent:AddToggle("AnonymousMode", { Title = "Ch·∫ø ƒë·ªô ·∫©n danh", Default = false })

-- Tab Settings > Webhook
Options.WebhookToggle = Fluent:AddToggle("WebhookToggle", { Title = "B·∫≠t th√¥ng b√°o Discord Webhook", Default = false })
Options.WebhookURL = Fluent:AddTextbox("WebhookURL", { Title = "URL Webhook", Default = ""})
Options.WebhookType = Fluent:AddDropdown("WebhookType", { Title = "Ki·ªÉu Webhook", Default = "M·ªõi (Embed)", Values = {"M·ªõi (Embed)", "C≈© (Text)"} })
Options.NotifyOnHop = Fluent:AddToggle("NotifyOnHop", { Title = "Th√¥ng b√°o khi hop server", Default = false })
Options.PingOnHighDonation = Fluent:AddToggle("PingOnHighDonation", { Title = "Ping @everyone khi donate cao", Default = false })
Options.MinDonationToPing = Fluent:AddSlider("MinDonationToPing", { Title = "R$ t·ªëi thi·ªÉu ƒë·ªÉ ping", Default = 1000, Min = 1, Max = 100000, Rounding = 0 })


--[[---------------------------------------------------------------------------]]
--[                             QU·∫¢N L√ù L∆ØU & GIAO DI·ªÜN                         ]
--[[---------------------------------------------------------------------------]]

SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings, {
    Title = "Qu·∫£n l√Ω C√†i ƒë·∫∑t"
})

--[[---------------------------------------------------------------------------]]
--[                              C√ÅC H√ÄM CH·ª®C NƒÇNG                              ]
--[[---------------------------------------------------------------------------]]

-- T√¨m Remotes
task.spawn(function()
    for i, v in next, ReplicatedStorage:GetChildren() do
        if v.Name:find('Remote') and v:IsA('ModuleScript') then
            local success, _ = pcall(function()
                require(v).Event('PromotionBlimpGiftbux'):FireServer()
            end)
            if success then 
                Remotes = require(v)
                break
            end
        end
        task.wait()
    end
end)

-- Ch·ªëng AFK
task.spawn(function()
    local VirtualUser = game:GetService("VirtualUser")
    LocalPlayer.Idled:Connect(function()
        VirtualUser:CaptureController()
        VirtualUser:ClickButton2(Vector2.new())
    end)
end)

-- Chuy·ªÉn ƒë·ªïi m√†u Hex sang Color3
local function hexToRgb(hex)
    hex = hex:gsub("#", "")
    local r = tonumber("0x" .. hex:sub(1, 2))
    local g = tonumber("0x" .. hex:sub(3, 4))
    local b = tonumber("0x" .. hex:sub(5, 6))
    return Color3.fromRGB(r, g, b)
end

-- ƒê·ªãnh d·∫°ng s·ªë
local function formatNumber(n)
    if n >= 10000 then return string.format("%.1fk", n / 1000)
    elseif n >= 1000 then return string.format("%.2fk", n / 1000)
    else return tostring(n) end
end

-- H√†m g·ª≠i webhook
local function sendWebhook(raised, donor)
    local url = Options.WebhookURL.Value
    if not Options.WebhookToggle.Value or url:gsub(" ", "") == "" then return end

    local webhookType = Options.WebhookType.Value
    local playerDisplayName = LocalPlayer.DisplayName
    local totalRaised = raisedStat.Value
    local afterTax = math.floor(raised * 0.6)
    
    local http_request = httprequest or (syn and syn.request) or http.request

    if not http_request then return end

    if webhookType == "M·ªõi (Embed)" then
        local embed = {
            title = playerDisplayName .. " üí∏ v·ª´a ƒë∆∞·ª£c donate!",
            description = string.format(
                "**%d R$** b·ªüi **%s**\n‚Ä¢ Sau thu·∫ø: %d R$\n‚Ä¢ T·ªïng c·ªông: %d R$",
                raised, donor, afterTax, totalRaised
            ),
            color = 3066993, -- Green
            thumbnail = {
                url = ("https://www.roblox.com/headshot-thumbnail/image?userId=%d&width=256&height=256&format=png"):format(LocalPlayer.UserId)
            },
            timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
        }
        local payload = HttpService:JSONEncode({ embeds = { embed } })
        http_request({ Url = url, Method = "POST", Headers = { ["Content-Type"] = "application/json" }, Body = payload })
    else -- C≈© (Text)
        local msg = string.format(
            "%s | Donate: %d R$ | Sau thu·∫ø: %d R$ | T·ªïng: %d R$ | Ng∆∞·ªùi donate: %s",
            playerDisplayName, raised, afterTax, totalRaised, donor
        )
        local payload = HttpService:JSONEncode({ content = msg })
        http_request({ Url = url, Method = "POST", Headers = { ["Content-Type"] = "application/json" }, Body = payload })
    end

    if Options.PingOnHighDonation.Value and raised >= Options.MinDonationToPing.Value then
        local pingPayload = HttpService:JSONEncode({ content = "@everyone" })
        http_request({ Url = url, Method = "POST", Headers = { ["Content-Type"] = "application/json" }, Body = pingPayload })
    end
end

-- H√†m Hop Server
local function serverHop()
    if Options.NotifyOnHop.Value then
        local name = LocalPlayer.DisplayName ~= LocalPlayer.Name and
            string.format('%s (@%s)', LocalPlayer.DisplayName, LocalPlayer.Name) or
            '@' .. LocalPlayer.Name
        sendWebhook(0, name .. " ƒë√£ hop server.")
    end

    local placeId
    if isVoiceChatEnabled and Options.HopToVC.Value then
        placeId = 8943844393 -- Voice chat server
    elseif Options.RandomHopType.Value then
        placeId = (math.random() < 0.5) and 8943844393 or 8737602449
    else
        placeId = 8737602449 -- Normal server
    end

    local http_request = httprequest or (syn and syn.request) or http.request
    if not http_request then
        TeleportService:Teleport(placeId)
        return
    end

    local req = http_request({
        Url = string.format("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Desc&limit=100", placeId)
    })
    local body = HttpService:JSONDecode(req.Body)

    if body and body.data then
        local servers = {}
        for _, server in ipairs(body.data) do
            if type(server) == "table" and server.playing < server.maxPlayers and server.id ~= game.JobId then
                table.insert(servers, server.id)
            end
        end
        if #servers > 0 then
            local randomServer = servers[math.random(1, #servers)]
            TeleportService:TeleportToPlaceInstance(placeId, randomServer, LocalPlayer)
        else
            TeleportService:Teleport(placeId) -- fallback
        end
    else
        TeleportService:Teleport(placeId) -- fallback
    end
end

-- H√†m h·∫πn gi·ªù hop server
local function scheduleHop()
    if hopTimer then task.cancel(hopTimer) end
    if Options.AutoHop.Value then
        hopTimer = task.spawn(function()
            task.wait(Options.HopDelay.Value * 60)
            serverHop()
        end)
    end
end

-- C·∫≠p nh·∫≠t n·ªôi dung booth
function updateBoothText()
    if not Options.TextUpdate.Value or not currentBoothNumber then return end

    local currentRaw = tonumber(raisedStat.Value)
    local goalRaw = currentRaw + (tonumber(Options.RobuxGoal.Value) or 100)
    
    local text = Options.CustomBoothText.Value
        :gsub("%$C", formatNumber(currentRaw))
        :gsub("%$G", formatNumber(goalRaw))
        :gsub("%$JPR", tostring(Options.JumpsPerRobux.Value))

    if Remotes then
        local payload = {
            text = text,
            textFont = Enum.Font[Options.BoothFont.Value],
            textColor = hexToRgb(Options.TextColorHex.Value),
            richText = true,
            strokeColor = Color3.new(0, 0, 0),
            strokeOpacity = 0,
            buttonStrokeColor = Color3.new(0, 0, 0),
            buttonTextColor = Color3.new(1, 1, 1),
            buttonColor = Color3.new(98, 255, 0),
            buttonHoverColor = Color3.new(98, 255, 0),
            buttonLayout = ""
        }
        Remotes.Event("SetCustomization"):FireServer(payload, "booth")
    end
end

-- G·ª≠i tin nh·∫Øn chat
local function sendChatMessage(msg)
    TextChatService.TextChannels.RBXGeneral:SendAsync(msg)
end

-- H√†m t·ª± ƒë·ªông xin donate
local function autoBeg()
    while Options.AutoBeg.Value do
        local messages = {}
        for s in Options.BegMessages.Value:gmatch("[^\r\n]+") do
            table.insert(messages, s)
        end
        if #messages > 0 then
            sendChatMessage(messages[math.random(#messages)])
        end
        task.wait(Options.BegDelay.Value)
    end
end

-- T√¨m ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t
local function getNearestPlayer()
    local nearestPlayer, minDist = nil, math.huge
    local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return nil end

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local targetRoot = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
            if targetRoot then
                local dist = (myRoot.Position - targetRoot.Position).Magnitude
                if dist < minDist then
                    minDist = dist
                    nearestPlayer = player
                end
            end
        end
    end
    return nearestPlayer
end

-- T√¨m booth tr·ªëng
local function findUnclaimedBooths()
    unclaimedBooth = {}
    boothLocationUI = Workspace:FindFirstChild("MapUI") or PlayerGui:WaitForChild("MapUIContainer"):WaitForChild("MapUI")
    if not boothLocationUI then return end
    
    local boothUIs = boothLocationUI:WaitForChild("BoothUI")
    local interactions = Workspace:WaitForChild("BoothInteractions")

    for _, uiFrame in ipairs(boothUIs:GetChildren()) do
        if uiFrame.Details.Owner.Text == "unclaimed" then
            local boothNum = tonumber(uiFrame.Name:match("%d+"))
            if boothNum then
                for _, interact in ipairs(interactions:GetChildren()) do
                    if interact:GetAttribute("BoothSlot") == boothNum then
                        -- Ch·ªâ nh·∫≠n booth ·ªü khu v·ª±c trung t√¢m ƒë·ªÉ tr√°nh ƒëi qu√° xa
                        if (interact.Position - mainCheckPosition).Magnitude < 95 then
                            table.insert(unclaimedBooth, boothNum)
                        end
                        break
                    end
                end
            end
        end
    end
end

-- Nh·∫≠n booth
local function claimBooth()
    if #unclaimedBooth == 0 then
        Fluent:Notify({ Title = "L·ªói", Content = "Kh√¥ng t√¨m th·∫•y booth tr·ªëng, ƒëang hop server...", Duration = 5 })
        task.wait(5)
        serverHop()
        return false
    end
    
    currentBoothNumber = unclaimedBooth[math.random(#unclaimedBooth)]
    local success, result = pcall(function()
        Remotes.Event("ClaimBooth"):InvokeServer(currentBoothNumber)
    end)
    
    if not success or not boothLocationUI.BoothUI:FindFirstChild("BoothUI" .. currentBoothNumber).Details.Owner.Text:find(LocalPlayer.DisplayName) then
        Fluent:Notify({ Title = "Th·∫•t b·∫°i", Content = "Kh√¥ng th·ªÉ nh·∫≠n booth. Th·ª≠ l·∫°i...", Duration = 3 })
        currentBoothNumber = nil
        return false
    end

    Fluent:Notify({ Title = "Th√†nh c√¥ng", Content = "ƒê√£ nh·∫≠n booth #" .. currentBoothNumber, Duration = 5 })
    return true
end

-- ƒêi ƒë·∫øn booth
local function walkToBooth()
    if not currentBoothNumber then return end
    
    local boothInteraction
    for _, v in ipairs(Workspace.BoothInteractions:GetChildren()) do
        if v:GetAttribute("BoothSlot") == currentBoothNumber then
            boothInteraction = v
            break
        end
    end
    
    if not boothInteraction then return end
    
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoid = character:WaitForChild("Humanoid")
    local rootPart = character:WaitForChild("HumanoidRootPart")
    
    local positionOffset
    local standPos = Options.StandingPosition.Value
    if standPos == "Tr∆∞·ªõc booth" then positionOffset = CFrame.new(0, 0, 3)
    elseif standPos == "Sau booth" then positionOffset = CFrame.new(0, 0, -5.5)
    elseif standPos == "B√™n tr√°i" then positionOffset = CFrame.new(-6, 0, 0)
    else positionOffset = CFrame.new(6, 0, 0) end

    local targetCFrame = boothInteraction.CFrame * positionOffset
    
    humanoid:MoveTo(targetCFrame.Position)
    humanoid.MoveToFinished:Wait()

    rootPart.CFrame = CFrame.new(targetCFrame.Position, boothInteraction.Position)
    task.wait(0.5)
    
    -- K√≠ch ho·∫°t ƒëi·ªáu nh·∫£y
    local dance = Options.DanceChoice.Value
    if dance ~= "T·∫Øt" then
        local danceNum = dance:match("%d") or ""
        sendChatMessage("/e dance" .. danceNum)
    end
end

--[[---------------------------------------------------------------------------]]
--[                             S·ª∞ KI·ªÜN & CALLBACKS                             ]
--[[---------------------------------------------------------------------------]]

-- Callbacks cho c√°c toggle
Options.DisableRendering:OnChanged(function()
    RunService:Set3dRenderingEnabled(not Options.DisableRendering.Value)
end)

Options.FpsLimit:OnChanged(function()
    if setfpscap then
        setfpscap(Options.FpsLimit.Value)
    end
end)

Options.AnonymousMode:OnChanged(function()
    if Remotes then
        Remotes.Event('SetAnonymousLive'):FireServer(Options.AnonymousMode.Value)
    end
end)

Options.AutoBeg:OnChanged(function()
    if beggingSpam then task.cancel(beggingSpam) end
    if Options.AutoBeg.Value then
        beggingSpam = task.spawn(autoBeg)
    end
end)

Options.AutoHop:OnChanged(scheduleHop)
Options.HopDelay:OnChanged(scheduleHop)

-- N√∫t hop server th·ªß c√¥ng
Tabs.Hop:AddButton({
    Title = "Hop Server Ngay",
    Description = "T√¨m v√† d·ªãch chuy·ªÉn ƒë·∫øn m·ªôt server ng·∫´u nhi√™n kh√°c.",
    Callback = serverHop
})

-- N√∫t c·∫≠p nh·∫≠t booth
Tabs.AutoFarm:AddButton({
    Title = "C·∫≠p nh·∫≠t n·ªôi dung Booth",
    Description = "√Åp d·ª•ng c√°c thay ƒë·ªïi v·ªÅ n·ªôi dung, m√†u s·∫Øc, font ch·ªØ...",
    Callback = updateBoothText
})

-- Tab Credits
Tabs.Credits:AddParagraph({ Title = "Gi·ªõi thi·ªáu", Content = "Script n√†y ƒë∆∞·ª£c chuy·ªÉn th·ªÉ v√† n√¢ng c·∫•p b·ªüi Lychkin v·ªõi s·ª± tr·ª£ gi√∫p c·ªßa Gemini AI, d·ª±a tr√™n script g·ªëc c·ªßa t√°c gi·∫£ szze." })
Tabs.Credits:AddParagraph({ Title = "H·ªó tr·ª£", Content = "N·∫øu b·∫°n th·∫•y script h·ªØu √≠ch, b·∫°n c√≥ th·ªÉ ·ªßng h·ªô t√°c gi·∫£ b·∫±ng c√°ch donate Robux. M·ªçi s·ª± ·ªßng h·ªô ƒë·ªÅu ƒë√°ng qu√Ω!" })
Tabs.Credits:AddButton({
    Title = "Teleport ƒë·∫øn game ·ªßng h·ªô",
    Callback = function() TeleportService:Teleport(13461969417) end
})


-- S·ª± ki·ªán ƒë∆∞·ª£c donate
local totalRaisedInServer = 0
lastRaisedValue = raisedStat.Value

raisedStat.Changed:Connect(function(newRaised)
    local amountRaised = newRaised - lastRaisedValue
    if amountRaised <= 0 then return end
    
    totalRaisedInServer = totalRaisedInServer + amountRaised
    lastRaisedValue = newRaised
    
    -- T√¨m ng∆∞·ªùi donate & g·ª≠i webhook
    task.spawn(function()
        local donor = getNearestPlayer()
        local donorName = (donor and donor.DisplayName) or "M·ªôt ng∆∞·ªùi h·∫£o t√¢m"
        sendWebhook(amountRaised, donorName)
    end)
    
    -- Reset h·∫πn gi·ªù hop
    scheduleHop()
    
    -- X·ª≠ l√Ω hi·ªáu ·ª©ng
    local char = LocalPlayer.Character
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    if not hum then return end
    
    if Options.DonationJump.Value then
        task.spawn(function()
            for i = 1, amountRaised * Options.JumpsPerRobux.Value do
                hum:ChangeState("Jumping")
                task.wait(0.5)
            end
        end)
    end
    
    if Options.SpinOnDonate.Value then
        local root = hum.RootPart
        local spin = root:FindFirstChild("SpinVelocity") or Instance.new("BodyAngularVelocity", root)
        spin.Name = "SpinVelocity"
        spin.MaxTorque = Vector3.new(0, math.huge, 0)
        spin.AngularVelocity = Vector3.new(0, spin.AngularVelocity.Y + (amountRaised * Options.SpinSpeedMultiplier.Value), 0)
    end
    
    if Options.JumpBoostOnDonate.Value then
        hum.JumpPower = hum.JumpPower + amountRaised
    end
    
    if Options.GravityChangeOnDonate.Value then
        Workspace.Gravity = Workspace.Gravity - amountRaised
    end
    
    if Options.RunLapOnDonate.Value then
        task.spawn(function()
            local originalWalkSpeed = hum.WalkSpeed
            hum.WalkSpeed = 50
            for lap = 1, amountRaised do
                for _, posData in ipairs(LAP_PATH) do
                    hum:MoveTo(Vector3.new(unpack(posData)))
                    hum.MoveToFinished:Wait()
                end
            end
            hum.WalkSpeed = originalWalkSpeed
            walkToBooth() -- Quay l·∫°i booth sau khi ch·∫°y xong
        end)
    end
    
    if Options.HelicopterOnDonate.Value then
        -- (Logic hi·ªáu ·ª©ng tr·ª±c thƒÉng ph·ª©c t·∫°p c√≥ th·ªÉ th√™m v√†o ƒë√¢y)
        sendChatMessage("Hi·ªáu ·ª©ng tr·ª±c thƒÉng ƒëang ƒë∆∞·ª£c k√≠ch ho·∫°t!")
    end

    -- C·∫£m ∆°n
    if Options.AutoThanks.Value then
        task.spawn(function()
            task.wait(Options.ThanksDelay.Value)
            local messages = {}
            for s in Options.ThanksMessages.Value:gmatch("[^\r\n]+") do table.insert(messages, s) end
            if #messages > 0 then sendChatMessage(messages[math.random(#messages)]) end
        end)
    end
    
    -- Check c√°c ƒëi·ªÅu ki·ªán hop
    if Options.HopOnDonate.Value and amountRaised >= Options.MinDonateToHop.Value then
        serverHop()
    end
    
    if Options.HopOnGoal.Value and totalRaisedInServer >= Options.HopGoalAmount.Value then
        serverHop()
    end
    
    -- C·∫≠p nh·∫≠t booth sau khi donate
    task.wait(Options.TextUpdateDelay.Value)
    updateBoothText()
end)

-- S·ª± ki·ªán ng∆∞·ªùi ch∆°i kh√°c v√†o game
Players.PlayerAdded:Connect(function(player)
    if Options.HopOnFriendJoin.Value and player:IsFriendsWith(LocalPlayer.UserId) then
        Fluent:Notify({ Title = "B·∫°n b√® ƒë√£ v√†o!", Content = "ƒêang hop server kh√°c...", Duration = 5 })
        task.wait(3)
        serverHop()
    end
end)


--[[---------------------------------------------------------------------------]]
--[                                 KH·ªûI ƒê·ªòNG SCRIPT                            ]
--[[---------------------------------------------------------------------------]]

local function Initialize()
    -- Ch·ªù Remotes s·∫µn s√†ng
    repeat task.wait() until Remotes
    
    -- T·∫£i v√† √°p d·ª•ng c√†i ƒë·∫∑t
    SaveManager:Load()
    Fluent:Notify({ Title = "Lychkin's Helper", Content = "ƒê√£ t·∫£i c√†i ƒë·∫∑t th√†nh c√¥ng!", Duration = 5 })
    
    -- √Åp d·ª•ng c√°c c√†i ƒë·∫∑t t·ª©c th√¨
    RunService:Set3dRenderingEnabled(not Options.DisableRendering.Value)
    if setfpscap then setfpscap(Options.FpsLimit.Value) end
    if Options.AnonymousMode.Value then Remotes.Event('SetAnonymousLive'):FireServer(true) end

    -- Ki·ªÉm tra Voice Chat
    local success, enabled = pcall(function() return VoiceChatService:IsVoiceEnabledForUserIdAsync(LocalPlayer.UserId) end)
    isVoiceChatEnabled = success and enabled
    if not isVoiceChatEnabled then Tabs.Hop.Toggles.HopToVC:SetValue(false) end
    
    -- B·∫Øt ƒë·∫ßu logic ch√≠nh
    findUnclaimedBooths()
    if claimBooth() then
        lastRaisedValue = raisedStat.Value -- Kh·ªüi t·∫°o gi√° tr·ªã raised
        walkToBooth()
        task.wait(1)
        updateBoothText() -- C·∫≠p nh·∫≠t l·∫ßn ƒë·∫ßu
        if Options.AutoBeg.Value then
            beggingSpam = task.spawn(autoBeg)
        end
        scheduleHop()
    else
        -- N·∫øu kh√¥ng nh·∫≠n ƒë∆∞·ª£c booth, th·ª≠ l·∫°i sau khi hop
        serverHop()
    end
end

Initialize()
