#!/data/data/com.termux/files/usr/bin/python
# -*- coding: utf-8 -*-

import subprocess
import time
import requests
import os
import sys
import argparse
import re
import threading
import json
import random # Th√™m th∆∞ vi·ªán random cho vi·ªác ch·ªçn proxy
from datetime import datetime

# ==============================================================================
# SCRIPT K·∫æT H·ª¢P: Lychkins's Task Runner v1.2 (Modified Logic: Skip if Online)
#
# C·∫¨P NH·∫¨T M·ªöI:
# 1. Logic Launch: N·∫øu t√†i kho·∫£n ƒëang ONLINE -> Ch·ªâ Skip qua acc kh√°c, KH√îNG Refresh.
# 2. Gi·ªØ nguy√™n c∆° ch·∫ø Proxy Double Check v√† Retry.
# ==============================================================================

# ---------------------------------------------------
# -- URL C·∫§U H√åNH --
# ---------------------------------------------------
CONFIG_URL = "https://raw.githubusercontent.com/AinsworthNecco/Lychkin/refs/heads/main/config2"

# ---------------------------------------------------
# -- BI·∫æN TO√ÄN C·ª§C --
# ---------------------------------------------------
proxy_index = 0
failed_proxy_count = 0
current_proxies = []
file_lock = threading.Lock()
current_executor_id = None # Bi·∫øn l∆∞u ID executor hi·ªán t·∫°i ƒë·ªÉ check logic Delta

# ==============================================================================
# -- C√ÅC H√ÄM TI·ªÜN √çCH & KI·ªÇM TRA ROOT --
# ==============================================================================

def check_root_access():
    """Ki·ªÉm tra quy·ªÅn root."""
    print("[MAIN] ƒêang ki·ªÉm tra quy·ªÅn root...")
    try:
        process = subprocess.run(["su", "-c", "whoami"], capture_output=True, text=True, timeout=10)
        if process.stdout.strip() == "root":
            print("[MAIN] ‚úÖ Quy·ªÅn root ƒë√£ ƒë∆∞·ª£c c·∫•p.")
            return True
        else:
            print(f"[MAIN] ‚ùå L·ªói: Kh√¥ng c√≥ quy·ªÅn root (k·∫øt qu·∫£: {process.stdout.strip()}).")
            return False
    except Exception as e:
        print(f"[MAIN] ‚ùå L·ªói ki·ªÉm tra root: {e}")
        return False

def fetch_and_load_config(url):
    """
    T·∫£i c·∫•u h√¨nh t·ª´ xa v√† x·ª≠ l√Ω logic ƒë∆∞·ªùng d·∫´n ƒë·ªông.
    """
    global current_executor_id
    try:
        response = requests.get(url, timeout=20)
        response.raise_for_status()
        
        config = {}
        pattern = re.compile(r'^\s*([A-Za-z_][A-Za-z0-9_]*)\s*=\s*(["\'])(.*?)\2', re.DOTALL | re.MULTILINE)
        
        for key, _, value in pattern.findall(response.text):
            value = value.strip()
            if key in ["SCAN_INTERVAL_SECONDS", "LAUNCH_INTERVAL_SECONDS", "CONNECTION_TIMEOUT", "REBOOT_INTERVAL_MINUTES", "LAUNCH_DELAY_SECONDS", "KEY_CHECK_INTERVAL_MINUTES"]:
                config[key] = int(value)
            elif key in ["MIN_PLAYER_PERCENTAGE", "MAX_PLAYER_PERCENTAGE"]:
                config[key] = float(value)
            elif key == "ACCOUNT_SUFFIXES":
                accounts = []
                for item in value.split(','):
                    item = item.strip()
                    if ':' in item:
                        parts = item.split(':', 1)
                        if len(parts) == 2 and parts[0].strip() and parts[1].strip().isdigit():
                            accounts.append({'suffix': parts[0].strip(), 'id': parts[1].strip()})
                config[key] = accounts
            elif key == "PROXY_LIST":
                config[key] = [item.strip() for item in value.splitlines() if item.strip()]
            else:
                config[key] = value
        
        # --- X·ª¨ L√ù LOGIC EXECUTOR T·ª∞ ƒê·ªòNG ---
        if "SELECTED_EXECUTOR" in config:
            selected_id = config["SELECTED_EXECUTOR"]
            current_executor_id = selected_id
            target_path_key = f"EXECUTOR_PATH_{selected_id}"
            
            if target_path_key in config:
                config["OUTPUT_FILE_PATH"] = config[target_path_key]
            else:
                print(f"[CONFIG] ‚ö†Ô∏è L·ªói: ƒê√£ ch·ªçn Executor {selected_id} nh∆∞ng kh√¥ng t√¨m th·∫•y '{target_path_key}'.")
                sys.exit(1)
        
        if "OUTPUT_FILE_PATH" not in config:
            print("[CONFIG] ‚ùå L·ªói: Thi·∫øu OUTPUT_FILE_PATH.")
            sys.exit(1)

        if "PLACE_ID" not in config:
            print("[CONFIG] ‚ùå L·ªói: Thi·∫øu PLACE_ID.")
            sys.exit(1)

        return config

    except requests.exceptions.RequestException as e:
        print(f"\n[CONFIG] ‚ùå L·ªñI M·∫†NG: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"\n[CONFIG] ‚ùå L·ªñI X·ª¨ L√ù: {e}")
        sys.exit(1)

def format_proxies(proxy_list):
    """Chuy·ªÉn ƒë·ªïi danh s√°ch proxy string sang ƒë·ªãnh d·∫°ng requests."""
    formatted = []
    if not proxy_list: return []
    for proxy_string in proxy_list:
        if not proxy_string: continue
        parts = proxy_string.split(':')
        proxy_url = ""
        if len(parts) == 2: proxy_url = f"http://{parts[0]}:{parts[1]}"
        elif len(parts) == 4: proxy_url = f"http://{parts[2]}:{parts[3]}@{parts[0]}:{parts[1]}"
        if proxy_url: formatted.append({"http": proxy_url, "https": proxy_url})
    return formatted

def countdown(seconds, thread_name="MAIN"):
    for i in range(seconds, 0, -1):
        print(f"[{thread_name}] Th·ªùi gian ch·ªù c√≤n l·∫°i: {i} gi√¢y    ", end='\r')
        sys.stdout.flush()
        time.sleep(1)
    print(f"[{thread_name}] B·∫Øt ƒë·∫ßu chu k·ª≥ m·ªõi.                                  ")

# ==============================================================================
# -- C√ÅC H√ÄM K·∫æT N·ªêI API --
# ==============================================================================

def execute_api_request_with_proxy(method, url, config, thread_name, json_data=None):
    """Th·ª±c hi·ªán request v·ªõi logic xoay v√≤ng (rotation) proxy cho Scanner."""
    global proxy_index, failed_proxy_count, current_proxies
    timeout = config.get("CONNECTION_TIMEOUT", 15)
    num_proxies = len(current_proxies)
    
    while True:
        if num_proxies > 0 and failed_proxy_count >= num_proxies:
            print(f"\n[{thread_name}] [!] T·∫•t c·∫£ proxies l·ªói. Ngh·ªâ 5 gi√¢y...")
            time.sleep(5)
            failed_proxy_count = 0; proxy_index = 0
        
        proxy, proxy_status = (current_proxies[proxy_index], f"Proxy {proxy_index + 1}/{num_proxies}") if num_proxies > 0 else (None, "IP G·ªëc")
        
        try:
            print(f"\r[{thread_name}] [*] K·∫øt n·ªëi API... | {proxy_status}", end="")
            sys.stdout.flush()
            if method.upper() == 'GET': response = requests.get(url, proxies=proxy, timeout=timeout)
            elif method.upper() == 'POST': response = requests.post(url, json=json_data, proxies=proxy, timeout=timeout)
            else: raise ValueError(f"Method l·∫°: {method}")
            
            if response.status_code == 200:
                failed_proxy_count = 0
                return response.json()
            
            error_reason = "Rate Limit" if response.status_code == 429 else f"Code {response.status_code}"
            raise requests.exceptions.HTTPError(error_reason)
            
        except (requests.exceptions.RequestException, requests.exceptions.HTTPError, ValueError) as e:
            if num_proxies > 0:
                print(f"\n[{thread_name}] [!] Proxy {proxy_index + 1} l·ªói ({e}). ƒê·ªïi proxy...")
                failed_proxy_count += 1
                proxy_index = (proxy_index + 1) % num_proxies
                time.sleep(1)
            else:
                print(f"\n[{thread_name}] [!] IP G·ªëc l·ªói ({e}). Ngh·ªâ 60 gi√¢y...")
                time.sleep(60)

def execute_api_request_simple(method, url, config, thread_name, json_data=None, proxy=None):
    """Th·ª±c hi·ªán request ƒë∆°n gi·∫£n, d√πng proxy ch·ªâ ƒë·ªãnh (KH√îNG c√≥ rotation)."""
    timeout = config.get("CONNECTION_TIMEOUT", 15)
    proxies = proxy if proxy else None
    
    try:
        if method.upper() == 'GET': response = requests.get(url, proxies=proxies, timeout=timeout)
        elif method.upper() == 'POST': response = requests.post(url, json=json_data, proxies=proxies, timeout=timeout)
        else: raise ValueError(f"Method l·∫°: {method}")
        
        if response.status_code == 200: return response.json()
        
    except Exception:
        # B·ªè qua l·ªói k·∫øt n·ªëi proxy/m·∫°ng v√† tr·∫£ v·ªÅ None
        pass 
        
    return None

def check_roblox_presence_single(account_id, config, thread_name, proxy_list, initial_proxy_index, check_info="Check"):
    """
    Ki·ªÉm tra tr·∫°ng th√°i online c·ªßa M·ªòT t√†i kho·∫£n.
    T·ª± ƒë·ªông retry 3 l·∫ßn v·ªõi proxy ng·∫´u nhi√™n kh√°c n·∫øu k·∫øt n·ªëi th·∫•t b·∫°i.
    """
    user_ids = [int(account_id)]
    api_url = "https://presence.roblox.com/v1/presence/users"
    payload = {"userIds": user_ids}
    
    formatted_proxies = proxy_list
    num_proxies = len(formatted_proxies)
    
    max_retries = 3
    
    for attempt in range(max_retries):
        
        # --- CH·ªåN PROXY CHO L·∫¶N TH·ª¨ N√ÄY ---
        idx = -1
        proxy = None
        
        if num_proxies > 0:
            if attempt == 0:
                # L·∫ßn ƒë·∫ßu ti√™n, d√πng proxy ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh t·ª´ b√™n ngo√†i (L1 ho·∫∑c L2)
                idx = initial_proxy_index
            else:
                # C√°c l·∫ßn sau, ch·ªçn ng·∫´u nhi√™n
                idx = random.randint(0, num_proxies - 1)
            
            proxy = formatted_proxies[idx]
        
        proxy_info = f"{check_info} (P#{idx + 1})" if idx != -1 else f"{check_info} (IP G·ªëc)"
        
        # D√πng \r ƒë·ªÉ in ƒë√®, tr·ª´ l·∫ßn in cu·ªëi c√πng
        print(f"[{thread_name}] [{account_id}] ƒêang th·ª≠ {proxy_info} (L·∫ßn {attempt + 1}/{max_retries})...", end='\r')
        sys.stdout.flush()

        # Th·ª±c hi·ªán request ƒë∆°n gi·∫£n
        response = execute_api_request_simple('POST', api_url, config, thread_name, json_data=payload, proxy=proxy)

        if response is not None:
            # Th√†nh c√¥ng k·∫øt n·ªëi v√† nh·∫≠n ƒë∆∞·ª£c response
            is_online = False
            if 'userPresences' in response:
                for p in response['userPresences']:
                    if p.get('userPresenceType') == 2 and str(p.get('userId')) == str(account_id):
                        is_online = True
            
            status = "ONLINE" if is_online else "OFFLINE"
            print(f"[{thread_name}] [{account_id}] {proxy_info}: {status}") # In k·∫øt qu·∫£ cu·ªëi c√πng ra d√≤ng m·ªõi
            return is_online
        
        # N·∫øu response l√† None, proxy/k·∫øt n·ªëi th·∫•t b·∫°i -> Ch·ªù 1s v√† th·ª≠ l·∫°i
        time.sleep(1) # ƒê·ª£i 1 gi√¢y tr∆∞·ªõc khi th·ª≠ l·∫°i

    # Th·∫•t b·∫°i sau max_retries
    print(f"[{thread_name}] [{account_id}] Th·ª≠ l·∫°i th·∫•t b·∫°i sau {max_retries} l·∫ßn.")
    return False


# ==============================================================================
# -- LOGIC M·ªöI: DELTA KEY MANAGER --
# ==============================================================================

def delta_key_monitor_loop():
    """
    Lu·ªìng ki·ªÉm tra v√† c·∫≠p nh·∫≠t Key Delta.
    Ch·ªâ ch·∫°y n·∫øu Executor = 1.
    """
    thread_name = "DELTA-KEY"
    print(f"[{thread_name}] ƒêang kh·ªüi ƒë·ªông tr√¨nh qu·∫£n l√Ω Key cho Delta...")
    
    # ƒê∆∞·ªùng d·∫´n file license c·ªßa Delta (C·ªë ƒë·ªãnh)
    LOCAL_KEY_PATH = "/storage/emulated/0/Delta/Internals/Cache/license"

    while True:
        # T·∫£i config m·ªõi nh·∫•t ƒë·ªÉ l·∫•y URL v√† Interval
        config = fetch_and_load_config(CONFIG_URL)
        
        # Ki·ªÉm tra xem c√≥ ph·∫£i ƒëang d√πng Delta kh√¥ng (SELECTED_EXECUTOR="1")
        if str(config.get("SELECTED_EXECUTOR")) != "1":
            print(f"[{thread_name}] Kh√¥ng ph·∫£i ch·∫ø ƒë·ªô Delta. Lu·ªìng s·∫Ω ng·ªß ƒë√¥ng d√†i h·∫°n.")
            time.sleep(3600)
            continue

        key_url = config.get("DELTA_KEY_URL")
        interval = config.get("KEY_CHECK_INTERVAL_MINUTES", 30)

        if not key_url:
            print(f"[{thread_name}] ‚ö†Ô∏è C·∫£nh b√°o: Ch∆∞a c·∫•u h√¨nh DELTA_KEY_URL trong config online.")
        else:
            try:
                # 1. L·∫•y Key t·ª´ Github
                print(f"[{thread_name}] ƒêang ki·ªÉm tra Key m·ªõi t·ª´ GitHub...")
                response = requests.get(key_url, timeout=15)
                if response.status_code == 200:
                    remote_key = response.text.strip()
                    
                    # 2. ƒê·ªçc Key hi·ªán t·∫°i trong m√°y
                    local_key = ""
                    if os.path.exists(LOCAL_KEY_PATH):
                        try:
                            with open(LOCAL_KEY_PATH, "r") as f:
                                local_key = f.read().strip()
                        except: pass
                    
                    # 3. So s√°nh
                    if remote_key == local_key:
                        print(f"[{thread_name}] ‚úÖ Key tr√πng kh·ªõp. Kh√¥ng c·∫ßn c·∫≠p nh·∫≠t.")
                    else:
                        print(f"[{thread_name}] ‚ö†Ô∏è PH√ÅT HI·ªÜN KEY M·ªöI! Ti·∫øn h√†nh c·∫≠p nh·∫≠t...")
                        
                        # ƒê·∫£m b·∫£o th∆∞ m·ª•c t·ªìn t·∫°i
                        os.makedirs(os.path.dirname(LOCAL_KEY_PATH), exist_ok=True)
                        
                        # Ghi ƒë√® file
                        with open(LOCAL_KEY_PATH, "w") as f:
                            f.write(remote_key)
                        
                        print(f"[{thread_name}] ‚úÖ ƒê√£ ghi key m·ªõi th√†nh c√¥ng.")
                        print(f"[{thread_name}] üõë REBOOT H·ªÜ TH·ªêNG TRONG 5 GI√ÇY ƒê·ªÇ √ÅP D·ª§NG...")
                        time.sleep(5)
                        subprocess.run(["su", "-c", "reboot"])
                else:
                    print(f"[{thread_name}] L·ªói t·∫£i Key: HTTP {response.status_code}")
            except Exception as e:
                print(f"[{thread_name}] L·ªói qu√° tr√¨nh check Key: {e}")

        # Ch·ªù ƒë·∫øn l·∫ßn check ti·∫øp theo
        time.sleep(interval * 60)

# ==============================================================================
# -- LOGIC CH√çNH: SCAN & LAUNCH --
# ==============================================================================

def run_scanner(config, thread_name="SCAN"):
    global current_proxies
    print(f"[{thread_name}] ƒêang qu√©t server...")
    
    current_proxies = format_proxies(config.get("PROXY_LIST", []))
    min_ratio = config.get("MIN_PLAYER_PERCENTAGE", 0) / 100.0
    max_ratio = config.get("MAX_PLAYER_PERCENTAGE", 100) / 100.0
    place_id = config["PLACE_ID"]
    
    collected_ids, next_cursor = [], ""
    while True:
        api_url = f"https://games.roblox.com/v1/games/{place_id}/servers/Public?sortOrder=Desc&limit=100"
        if next_cursor and next_cursor != "null": api_url += f"&cursor={next_cursor}"
        
        # D√πng h√†m rotation cho scanner
        data = execute_api_request_with_proxy('GET', api_url, config, thread_name) 
        if not data: continue
        
        servers = data.get("data", [])
        next_cursor = data.get("nextPageCursor")
        
        if not servers:
            print(f"\n[{thread_name}] [i] H·∫øt danh s√°ch server.")
            break
            
        total_ratio = sum((s.get("playing", 0) / s.get("maxPlayers", 1)) for s in servers if s.get("maxPlayers", 0) > 0)
        
        for s in servers:
            if s.get("maxPlayers", 0) > 0:
                ratio = s.get("playing", 0) / s.get("maxPlayers")
                if min_ratio <= ratio <= max_ratio:
                    sid = s.get("id")
                    if sid and sid not in collected_ids: collected_ids.append(sid)
        
        avg_ratio = (total_ratio / len(servers)) if servers else 0
        print(f"\r[{thread_name}] Qu√©t... | T·ªâ l·ªá trang: {avg_ratio * 100:5.1f}% | ƒê√£ t√¨m: {len(collected_ids):<5}", end="")
        
        if 0 < avg_ratio < min_ratio or not next_cursor or next_cursor == "null":
            print(f"\n[{thread_name}] [i] ƒê·∫°t gi·ªõi h·∫°n d∆∞·ªõi ho·∫∑c h·∫øt trang.")
            break
            
    output_path = config["OUTPUT_FILE_PATH"]
    
    output_dir = os.path.dirname(output_path)
    if output_dir and not os.path.exists(output_dir):
        try: os.makedirs(output_dir)
        except: pass

    with file_lock:
        try:
            with open(output_path, "w") as f:
                for sid in collected_ids: f.write(f"{sid}\n")
            print(f"[{thread_name}] ‚úÖ ƒê√£ l∆∞u {len(collected_ids)} ID v√†o: {output_path}")
        except Exception as e:
            print(f"\n[{thread_name}] ‚ùå L·ªói ghi file: {e}")
            
    return True

def launch_roblox_instances(config, launch_mode, thread_name="LAUNCH"):
    accounts = config.get("ACCOUNT_SUFFIXES", [])
    if not accounts:
        print(f"[{thread_name}] L·ªói: Ch∆∞a c·∫•u h√¨nh t√†i kho·∫£n.")
        return
    
    server_ids = []
    if launch_mode == 'scan':
        with file_lock:
            try:
                with open(config['OUTPUT_FILE_PATH'], 'r') as f:
                    server_ids = [line.strip() for line in f if line.strip()]
            except: pass
        if not server_ids:
            print(f"[{thread_name}] Ch∆∞a c√≥ server ƒë·ªÉ join. Ch·ªù qu√©t...")
            return

    base_pkg = config.get("BASE_PACKAGE_NAME", "com.roblox.clien")
    
    # L·∫•y danh s√°ch proxies ƒë√£ format
    formatted_proxies = format_proxies(config.get("PROXY_LIST", []))
    num_proxies = len(formatted_proxies)
    
    for i, acc in enumerate(accounts):
        suffix, uid = acc['suffix'], acc['id']
        pkg_name = f"{base_pkg}{suffix}"
        
        print(f"\n[{thread_name}] ---- B·∫ÆT ƒê·∫¶U CHECK: {suffix} (ID: {uid}) ----")
        
        # --- CH·ªåN PROXY CHO L·∫¶N 1 ---
        idx_1 = random.randint(0, num_proxies - 1) if num_proxies > 0 else -1
        
        # 1. Ki·ªÉm tra API l·∫ßn 1 (C√≥ retry n·ªôi b·ªô)
        is_online_l1 = check_roblox_presence_single(
            uid, config, thread_name, formatted_proxies, idx_1, check_info="Check L1"
        )
        
        is_online_final = is_online_l1 # Gi·∫£ ƒë·ªãnh ban ƒë·∫ßu l√† k·∫øt qu·∫£ L1

        # 2. Logic Double Check (N·∫øu API b√°o Offline)
        if not is_online_l1:
            print(f"[{thread_name}] ‚ö†Ô∏è [{suffix}] API b√°o Offline (L1). Ch·ªù 10s ƒë·ªÉ Double Check...")
            time.sleep(10)

            # --- CH·ªåN PROXY CHO L·∫¶N 2 (Kh√°c L·∫ßn 1 n·∫øu c√≥ th·ªÉ) ---
            idx_2 = -1
            if num_proxies > 0:
                if num_proxies > 1:
                    # Ch·ªçn index ng·∫´u nhi√™n kh√°c index 1
                    available_indices = [j for j in range(num_proxies) if j != idx_1]
                    idx_2 = random.choice(available_indices)
                else:
                    # Ch·ªâ c√≥ 1 proxy, d√πng l·∫°i
                    idx_2 = idx_1
            
            # 3. Ki·ªÉm tra API l·∫ßn 2 (C√≥ retry n·ªôi b·ªô)
            is_online_l2 = check_roblox_presence_single(
                uid, config, thread_name, formatted_proxies, idx_2, check_info="Check L2"
            )
            
            is_online_final = is_online_l2 # K·∫øt qu·∫£ L2 l√† k·∫øt qu·∫£ cu·ªëi c√πng

        # ======================================================================
        # 4. QUY·∫æT ƒê·ªäNH & TH·ª∞C THI (Logic S·ª≠a ƒë·ªïi)
        # N·∫øu ONLINE -> Skip ngay l·∫≠p t·ª©c.
        # N·∫øu OFFLINE -> Kill & Start.
        # ======================================================================
        
        if is_online_final:
            print(f"[{thread_name}] [QUY·∫æT ƒê·ªäNH] '{suffix}' ƒêANG ONLINE. -> B·ªè qua (Skip), KH√îNG l√†m m·ªõi.")
            # S·ª≠ d·ª•ng continue ƒë·ªÉ nh·∫£y sang t√†i kho·∫£n k·∫ø ti·∫øp ngay l·∫≠p t·ª©c
            continue 

        # N·∫øu code ch·∫°y xu·ªëng ƒë√¢y, nghƒ©a l√† is_online_final == False (OFFLINE)
        print(f"[{thread_name}] [QUY·∫æT ƒê·ªäNH] '{suffix}' OFFLINE. Ti·∫øn h√†nh Kill & Start.")
        
        # Kill logic (Ch·ªâ ch·∫°y khi Offline)
        try:
            cmd_kill = f"PID=$(ps -ef | grep {pkg_name} | grep -v grep | awk '{{print $2}}'); if [ ! -z \"$PID\" ]; then kill -9 $PID; fi"
            subprocess.run(["su", "-c", cmd_kill], capture_output=True, timeout=10)
            time.sleep(3) # Ch·ªù process ch·∫øt h·∫≥n
        except: pass

        # 5. T·∫°o l·ªánh Start (Ch·ªâ ch·∫°y khi Offline v√¨ l·ªánh continue ·ªü tr√™n ƒë√£ ch·∫∑n case Online)
        target_url = ""
        if launch_mode == 'scan':
            if server_ids:
                target_url = f"roblox://placeId={config['PLACE_ID']}&gameId={server_ids[i % len(server_ids)]}"
            else:
                print(f"[{thread_name}] [-] Kh√¥ng c√≥ server h·ª£p l·ªá ƒë·ªÉ join cho '{suffix}'. B·ªè qua start.")
                continue
        elif launch_mode == 'vip':
            target_url = config.get('VIP_SERVER_URL', "")
            
        if target_url:
            subprocess.run(["am", "start", "-a", "android.intent.action.VIEW", "-d", target_url, "-p", pkg_name], capture_output=True)
            print(f"[{thread_name}] -> ƒê√£ g·ªçi l·ªánh start cho {pkg_name}")
            
        # Ngh·ªâ gi·ªØa c√°c l·∫ßn kh·ªüi ƒë·ªông acc (Ch·ªâ √°p d·ª•ng khi c√≥ th·ª±c hi·ªán start)
        delay = config.get("LAUNCH_DELAY_SECONDS", 10)
        if i < len(accounts) - 1:
            print(f"[{thread_name}] ƒê·ª£i {delay}s tr∆∞·ªõc khi qua acc ti·∫øp theo...")
            time.sleep(delay)

# ==============================================================================
# -- V√íNG L·∫∂P & MAIN --
# ==============================================================================

def scanner_loop():
    print("[SCAN] B·∫Øt ƒë·∫ßu...")
    config = fetch_and_load_config(CONFIG_URL)
    while True:
        run_scanner(config, "SCAN")
        countdown(config.get("SCAN_INTERVAL_SECONDS", 300), "SCAN")

def launcher_loop(mode):
    print(f"[LAUNCH] B·∫Øt ƒë·∫ßu ch·∫ø ƒë·ªô {mode}...")
    config = fetch_and_load_config(CONFIG_URL)
    while True:
        launch_roblox_instances(config, mode, "LAUNCH")
        countdown(config.get("LAUNCH_INTERVAL_SECONDS", 300), "LAUNCH")

def reboot_loop():
    print("[REBOOT] Ki·ªÉm tra l·ªãch...")
    config = fetch_and_load_config(CONFIG_URL)
    if config.get("REBOOT_ENABLED", "off").lower() == "on":
        mins = config.get("REBOOT_INTERVAL_MINUTES", 1200)
        print(f"[REBOOT] H·∫πn gi·ªù: {mins} ph√∫t.")
        time.sleep(mins * 60)
        print("[REBOOT] ƒêang kh·ªüi ƒë·ªông l·∫°i...")
        try: subprocess.run(["su", "-c", "reboot"])
        except: pass

if __name__ == "__main__":
    os.system("termux-wake-lock")
    if not check_root_access(): sys.exit(1)
    
    threading.Thread(target=reboot_loop, daemon=True).start()
    threading.Thread(target=delta_key_monitor_loop, daemon=True).start()

    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(dest='command')
    subparsers.add_parser('parallel')
    subparsers.add_parser('scan')
    lp = subparsers.add_parser('launch')
    lp.add_argument('--mode', choices=['scan', 'vip'], default='scan')
    
    args = parser.parse_args()
    cmd = args.command if args.command else 'parallel'

    try:
        if cmd == 'scan': scanner_loop()
        elif cmd == 'launch': launcher_loop(args.mode)
        elif cmd == 'parallel':
            threading.Thread(target=scanner_loop, daemon=True).start()
            time.sleep(3)
            threading.Thread(target=launcher_loop, args=('vip',), daemon=True).start()
            while True: time.sleep(1)
    except KeyboardInterrupt:
        print("\n[MAIN] D·ª´ng.")
