#!/data/data/com.termux/files/usr/bin/python
# -*- coding: utf-8 -*-

import subprocess
import time
import requests
import os
import sys
import argparse
import re
import threading
import json
import random
from datetime import datetime

# ==============================================================================
# SCRIPT: Lychkins's Task Runner v1.8 (Full Features + Session Pool)
#
# C·∫¨P NH·∫¨T (v1.8):
# 1. Gi·ªØ nguy√™n: Check Root, Proxy Rotation (Smart Random), Delta Key Monitor, Reboot Loop.
# 2. Th√™m m·ªõi: C∆° ch·∫ø "Treo Ng·∫´u Nhi√™n" (Account Pool).
#    - ƒê·ªçc POOL_FILE v√† RANDOM_ACCOUNT_COUNT t·ª´ config.
#    - Ch·ªçn N t√†i kho·∫£n ng·∫´u nhi√™n khi b·∫Øt ƒë·∫ßu Launcher v√† d√πng c·ªë ƒë·ªãnh cho phi√™n ƒë√≥.
#    - X√≥a c√°c t√†i kho·∫£n ƒë√£ ch·ªçn kh·ªèi pool ƒë·ªÉ xoay v√≤ng to√†n b·ªô danh s√°ch.
# ==============================================================================

# ---------------------------------------------------
# -- URL C·∫§U H√åNH --
# ---------------------------------------------------
CONFIG_URL = "https://raw.githubusercontent.com/AinsworthNecco/Lychkin/refs/heads/main/config2"

# ---------------------------------------------------
# -- BI·∫æN TO√ÄN C·ª§C --
# ---------------------------------------------------
proxy_index = 0
failed_proxy_count = 0
current_proxies = []
file_lock = threading.Lock()
current_executor_id = None 

# ==============================================================================
# -- C√ÅC H√ÄM TI·ªÜN √çCH & KI·ªÇM TRA ROOT (GI·ªÆ NGUY√äN) --
# ==============================================================================

def check_root_access():
    """Ki·ªÉm tra quy·ªÅn root."""
    print("[MAIN] ƒêang ki·ªÉm tra quy·ªÅn root...")
    try:
        process = subprocess.run(["su", "-c", "whoami"], capture_output=True, text=True, timeout=10)
        if process.stdout.strip() == "root":
            print("[MAIN] ‚úÖ Quy·ªÅn root ƒë√£ ƒë∆∞·ª£c c·∫•p.")
            return True
        else:
            print(f"[MAIN] ‚ùå L·ªói: Kh√¥ng c√≥ quy·ªÅn root.")
            return False
    except Exception as e:
        print(f"[MAIN] ‚ùå L·ªói ki·ªÉm tra root: {e}")
        return False

def check_process_running(pkg_name):
    """Ki·ªÉm tra process package."""
    try:
        cmd = f"ps -ef | grep {pkg_name} | grep -v grep"
        result = subprocess.run(["su", "-c", cmd], capture_output=True, text=True, timeout=5)
        return bool(result.stdout.strip())
    except Exception:
        return False

def fetch_and_load_config(url):
    """T·∫£i c·∫•u h√¨nh t·ª´ xa v√† x·ª≠ l√Ω logic ƒë∆∞·ªùng d·∫´n ƒë·ªông."""
    global current_executor_id
    try:
        response = requests.get(url, timeout=20)
        response.raise_for_status()
        
        config = {}
        pattern = re.compile(r'^\s*([A-Za-z_][A-Za-z0-9_]*)\s*=\s*(["\'])(.*?)\2', re.DOTALL | re.MULTILINE)
        
        for key, _, value in pattern.findall(response.text):
            value = value.strip()
            if key in ["SCAN_INTERVAL_SECONDS", "LAUNCH_INTERVAL_SECONDS", "CONNECTION_TIMEOUT", 
                      "REBOOT_INTERVAL_MINUTES", "LAUNCH_DELAY_SECONDS", "KEY_CHECK_INTERVAL_MINUTES",
                      "RANDOM_ACCOUNT_COUNT"]:
                config[key] = int(value)
            elif key in ["MIN_PLAYER_PERCENTAGE", "MAX_PLAYER_PERCENTAGE"]:
                config[key] = float(value)
            elif key == "ACCOUNT_SUFFIXES":
                accounts = []
                for item in value.split(','):
                    item = item.strip()
                    if ':' in item:
                        parts = item.split(':', 1)
                        if len(parts) == 2 and parts[0].strip() and parts[1].strip().isdigit():
                            accounts.append({'suffix': parts[0].strip(), 'id': parts[1].strip()})
                config[key] = accounts
            elif key == "PROXY_LIST":
                config[key] = [item.strip() for item in value.splitlines() if item.strip()]
            else:
                config[key] = value
        
        # X·ª≠ l√Ω logic Executor
        if "SELECTED_EXECUTOR" in config:
            selected_id = config["SELECTED_EXECUTOR"]
            current_executor_id = selected_id
            target_path_key = f"EXECUTOR_PATH_{selected_id}"
            if target_path_key in config:
                config["OUTPUT_FILE_PATH"] = config[target_path_key]
        
        return config
    except Exception as e:
        print(f"\n[CONFIG] ‚ùå L·ªñI T·∫¢I C·∫§U H√åNH: {e}")
        sys.exit(1)

# ==============================================================================
# -- C∆† CH·∫æ M·ªöI: QU·∫¢N L√ù POOL T√ÄI KHO·∫¢N (RANDOM SELECTION) --
# ==============================================================================

def get_session_account_subset(config):
    """
    Logic v1.8: Ch·ªçn t√†i kho·∫£n ng·∫´u nhi√™n t·ª´ Pool v√† kh√≥a cho c·∫£ phi√™n ch·∫°y.
    """
    all_accounts = config.get("ACCOUNT_SUFFIXES", [])
    if not all_accounts:
        print("[POOL] ‚ùå Kh√¥ng t√¨m th·∫•y danh s√°ch t√†i kho·∫£n trong config.")
        return []

    pool_file = config.get("POOL_FILE", "random_pool.txt")
    n_to_pick = config.get("RANDOM_ACCOUNT_COUNT", 5)
    
    available_suffixes = []
    
    # 1. ƒê·ªçc pool hi·ªán t·∫°i
    if os.path.exists(pool_file):
        with open(pool_file, "r") as f:
            available_suffixes = [line.strip() for line in f if line.strip()]

    # 2. N·∫øu pool tr·ªëng -> N·∫°p l·∫°i t·ª´ ƒë·∫ßu
    if not available_suffixes:
        print(f"[POOL] üîÑ Pool tr·ªëng. N·∫°p l·∫°i {len(all_accounts)} t√†i kho·∫£n v√†o {pool_file}...")
        available_suffixes = [acc['suffix'] for acc in all_accounts]
        random.shuffle(available_suffixes)
    
    # 3. L·∫•y ra N t√†i kho·∫£n
    picked_suffixes = available_suffixes[:n_to_pick]
    remaining_suffixes = available_suffixes[n_to_pick:]
    
    # 4. L∆∞u l·∫°i ph·∫ßn c√≤n l·∫°i v√†o file ngay l·∫≠p t·ª©c
    with open(pool_file, "w") as f:
        for s in remaining_suffixes:
            f.write(f"{s}\n")
            
    # 5. Kh·ªõp suffix v·ªõi ID t√†i kho·∫£n
    selected_accounts = []
    for suffix in picked_suffixes:
        for acc in all_accounts:
            if acc['suffix'] == suffix:
                selected_accounts.append(acc)
                break
                
    print(f"[POOL] üé∞ ƒê√£ ch·ªçn {len(selected_accounts)} t√†i kho·∫£n cho phi√™n n√†y. (C√≤n l·∫°i: {len(remaining_suffixes)})")
    return selected_accounts

# ==============================================================================
# -- C√ÅC H√ÄM TI·ªÜN √çCH API & PROXY (GI·ªÆ NGUY√äN LOGIC G·ªêC) --
# ==============================================================================

def format_proxies(proxy_list):
    formatted = []
    for proxy_string in proxy_list:
        parts = proxy_string.split(':')
        proxy_url = ""
        if len(parts) == 2: proxy_url = f"http://{parts[0]}:{parts[1]}"
        elif len(parts) == 4: proxy_url = f"http://{parts[2]}:{parts[3]}@{parts[0]}:{parts[1]}"
        if proxy_url: formatted.append({"http": proxy_url, "https": proxy_url})
    return formatted

def countdown(seconds, thread_name="MAIN"):
    for i in range(seconds, 0, -1):
        print(f"[{thread_name}] Ch·ªù: {i}s  ", end='\r')
        time.sleep(1)
    print(f"[{thread_name}] B·∫Øt ƒë·∫ßu chu k·ª≥ m·ªõi.             ")

def execute_api_request_with_proxy(method, url, config, thread_name, json_data=None):
    global proxy_index, failed_proxy_count, current_proxies
    num_proxies = len(current_proxies)
    while True:
        if num_proxies > 0 and failed_proxy_count >= num_proxies:
            time.sleep(5); failed_proxy_count = 0
            if num_proxies > 0: proxy_index = random.randint(0, num_proxies - 1)
        
        proxy = current_proxies[proxy_index] if num_proxies > 0 else None
        try:
            if method.upper() == 'GET': resp = requests.get(url, proxies=proxy, timeout=config.get("CONNECTION_TIMEOUT", 15))
            else: resp = requests.post(url, json=json_data, proxies=proxy, timeout=config.get("CONNECTION_TIMEOUT", 15))
            
            if resp.status_code == 200:
                failed_proxy_count = 0
                return resp.json()
            raise Exception(f"HTTP {resp.status_code}")
        except Exception as e:
            if num_proxies > 1:
                new_idx = proxy_index
                while new_idx == proxy_index: new_idx = random.randint(0, num_proxies - 1)
                proxy_index = new_idx
                failed_proxy_count += 1
            time.sleep(1)

def check_roblox_presence_single(account_id, config, thread_name, proxy_list, initial_proxy_index):
    """Ki·ªÉm tra online v1.6 (No Duplicate Random)."""
    api_url = "https://presence.roblox.com/v1/presence/users"
    payload = {"userIds": [int(account_id)]}
    num_proxies = len(proxy_list)
    valid_checks = 0
    curr_idx = initial_proxy_index if initial_proxy_index >= 0 else 0
    
    while valid_checks < 3:
        proxy = proxy_list[curr_idx % num_proxies] if num_proxies > 0 else None
        try:
            resp = requests.post(api_url, json=payload, proxies=proxy, timeout=10)
            if resp.status_code == 200:
                data = resp.json()
                is_online = any(p.get('userPresenceType') == 2 for p in data.get('userPresences', []))
                if is_online: return True
                valid_checks += 1
            if num_proxies > 1:
                new_idx = curr_idx
                while new_idx == curr_idx: new_idx = random.randint(0, num_proxies - 1)
                curr_idx = new_idx
        except:
            if num_proxies > 1: curr_idx = random.randint(0, num_proxies - 1)
            time.sleep(1)
    return False

# ==============================================================================
# -- LOGIC KEY DELTA & REBOOT (GI·ªÆ NGUY√äN) --
# ==============================================================================

def delta_key_monitor_loop():
    thread_name = "DELTA-KEY"
    LOCAL_KEY_PATH = "/storage/emulated/0/Delta/Internals/Cache/license"
    while True:
        config = fetch_and_load_config(CONFIG_URL)
        if str(config.get("SELECTED_EXECUTOR")) == "1":
            key_url = config.get("DELTA_KEY_URL")
            if key_url:
                try:
                    resp = requests.get(key_url, timeout=15)
                    if resp.status_code == 200:
                        remote_key = resp.text.strip()
                        local_key = ""
                        if os.path.exists(LOCAL_KEY_PATH):
                            with open(LOCAL_KEY_PATH, "r") as f: local_key = f.read().strip()
                        if remote_key != local_key:
                            print(f"[{thread_name}] ‚ö†Ô∏è C·∫¨P NH·∫¨T KEY M·ªöI!")
                            os.makedirs(os.path.dirname(LOCAL_KEY_PATH), exist_ok=True)
                            with open(LOCAL_KEY_PATH, "w") as f: f.write(remote_key)
                            time.sleep(5); subprocess.run(["su", "-c", "reboot"])
                except Exception as e: print(f"[{thread_name}] L·ªói: {e}")
        time.sleep(config.get("KEY_CHECK_INTERVAL_MINUTES", 30) * 60)

def reboot_loop():
    config = fetch_and_load_config(CONFIG_URL)
    if config.get("REBOOT_ENABLED", "off").lower() == "on":
        mins = config.get("REBOOT_INTERVAL_MINUTES", 1200)
        print(f"[REBOOT] H·ªá th·ªëng s·∫Ω kh·ªüi ƒë·ªông l·∫°i sau {mins} ph√∫t.")
        time.sleep(mins * 60)
        subprocess.run(["su", "-c", "reboot"])

# ==============================================================================
# -- LOGIC CH√çNH: SCAN & LAUNCH --
# ==============================================================================

def run_scanner(config, thread_name="SCAN"):
    global current_proxies, proxy_index
    current_proxies = format_proxies(config.get("PROXY_LIST", []))
    if len(current_proxies) > 0: proxy_index = random.randint(0, len(current_proxies) - 1)
    
    min_ratio = config.get("MIN_PLAYER_PERCENTAGE", 0) / 100.0
    max_ratio = config.get("MAX_PLAYER_PERCENTAGE", 100) / 100.0
    place_id = config["PLACE_ID"]
    
    collected_ids, next_cursor = [], ""
    while True:
        api_url = f"https://games.roblox.com/v1/games/{place_id}/servers/Public?sortOrder=Desc&limit=100"
        if next_cursor and next_cursor != "null": api_url += f"&cursor={next_cursor}"
        data = execute_api_request_with_proxy('GET', api_url, config, thread_name) 
        if not data: break
        
        servers = data.get("data", [])
        next_cursor = data.get("nextPageCursor")
        if not servers: break
            
        for s in servers:
            if s.get("maxPlayers", 0) > 0:
                ratio = s.get("playing", 0) / s.get("maxPlayers")
                if min_ratio <= ratio <= max_ratio:
                    sid = s.get("id")
                    if sid not in collected_ids: collected_ids.append(sid)
        
        avg_ratio = sum((s.get("playing", 0) / s.get("maxPlayers", 1)) for s in servers) / len(servers) if servers else 0
        print(f"\r[{thread_name}] Qu√©t... | ƒê√£ t√¨m: {len(collected_ids):<5}", end="")
        if avg_ratio < min_ratio or not next_cursor: break
            
    with file_lock:
        try:
            with open(config["OUTPUT_FILE_PATH"], "w") as f:
                for sid in collected_ids: f.write(f"{sid}\n")
        except: pass
    return True

def launch_session_instances(config, session_accounts, launch_mode, thread_name="LAUNCH"):
    """Th·ª±c thi launch cho danh s√°ch acc ƒë√£ ch·ªçn."""
    if not session_accounts: return
    
    server_ids = []
    if launch_mode == 'scan':
        with file_lock:
            try:
                with open(config['OUTPUT_FILE_PATH'], 'r') as f:
                    server_ids = [line.strip() for line in f if line.strip()]
            except: pass

    base_pkg = config.get("BASE_PACKAGE_NAME", "com.roblox.clien")
    proxies = format_proxies(config.get("PROXY_LIST", []))
    
    for i, acc in enumerate(session_accounts):
        suffix, uid = acc['suffix'], acc['id']
        pkg_name = f"{base_pkg}{suffix}"
        print(f"\n[{thread_name}] >> {suffix} ({uid})")
        
        is_active = check_process_running(pkg_name)
        should_start = False
        
        if not is_active:
            should_start = True
        else:
            is_online = check_roblox_presence_single(uid, config, thread_name, proxies, random.randint(0, len(proxies)-1) if proxies else -1)
            if not is_online:
                subprocess.run(["su", "-c", f"am force-stop {pkg_name}"])
                time.sleep(2); should_start = True
        
        if should_start:
            target_url = config.get('VIP_SERVER_URL', "") if launch_mode == 'vip' else ""
            if launch_mode == 'scan' and server_ids:
                target_url = f"roblox://placeId={config['PLACE_ID']}&gameId={server_ids[i % len(server_ids)]}"
            
            if target_url:
                subprocess.run(["am", "start", "-a", "android.intent.action.VIEW", "-d", target_url, "-p", pkg_name])
            time.sleep(config.get("LAUNCH_DELAY_SECONDS", 10))

# ==============================================================================
# -- V√íNG L·∫∂P CH√çNH --
# ==============================================================================

def scanner_loop():
    while True:
        config = fetch_and_load_config(CONFIG_URL)
        run_scanner(config, "SCAN")
        countdown(config.get("SCAN_INTERVAL_SECONDS", 300), "SCAN")

def launcher_loop(mode):
    # CH·ªåN T√ÄI KHO·∫¢N 1 L·∫¶N DUY NH·∫§T KHI B·∫ÆT ƒê·∫¶U LU·ªíNG (SESSION LOCK)
    initial_config = fetch_and_load_config(CONFIG_URL)
    session_accounts = get_session_account_subset(initial_config)
    
    while True:
        config = fetch_and_load_config(CONFIG_URL)
        launch_session_instances(config, session_accounts, mode, "LAUNCH")
        countdown(config.get("LAUNCH_INTERVAL_SECONDS", 300), "LAUNCH")

if __name__ == "__main__":
    os.system("termux-wake-lock")
    if not check_root_access(): sys.exit(1)
    
    # Kh·ªüi ƒë·ªông c√°c lu·ªìng ph·ª•
    threading.Thread(target=reboot_loop, daemon=True).start()
    threading.Thread(target=delta_key_monitor_loop, daemon=True).start()

    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(dest='command')
    subparsers.add_parser('parallel')
    subparsers.add_parser('scan')
    lp = subparsers.add_parser('launch')
    lp.add_argument('--mode', choices=['scan', 'vip'], default='scan')
    
    args = parser.parse_args()
    cmd = args.command if args.command else 'parallel'

    try:
        if cmd == 'scan': scanner_loop()
        elif cmd == 'launch': launcher_loop(args.mode)
        elif cmd == 'parallel':
            threading.Thread(target=scanner_loop, daemon=True).start()
            time.sleep(3)
            launcher_loop('vip') # Ho·∫∑c 'scan' t√πy nhu c·∫ßu
    except KeyboardInterrupt:
        print("\n[MAIN] D·ª´ng.")
