#!/data/data/com.termux/files/usr/bin/python
# -*- coding: utf-8 -*-

import subprocess
import time
import requests
import os
import sys
import argparse
import re
import threading
import json
from datetime import datetime

# ==============================================================================
# SCRIPT K·∫æT H·ª¢P: Lychkins's Task Runner v1.4 (Double Check & Delta Key Manager)
#
# C·∫¨P NH·∫¨T M·ªöI:
# 1. Double Check Offline: N·∫øu th·∫•y Offline -> ƒê·ª£i 10s -> Check l·∫°i -> M·ªõi Kill.
# 2. Delta Key Manager: T·ª± ƒë·ªông check license key t·ª´ Github (Ch·ªâ cho Delta).
#    - N·∫øu Key kh√°c -> Ghi ƒë√® -> Reboot.
# ==============================================================================

# ---------------------------------------------------
# -- URL C·∫§U H√åNH --
# ---------------------------------------------------
CONFIG_URL = "https://raw.githubusercontent.com/AinsworthNecco/Lychkin/refs/heads/main/config2"

# ---------------------------------------------------
# -- BI·∫æN TO√ÄN C·ª§C --
# ---------------------------------------------------
proxy_index = 0
failed_proxy_count = 0
current_proxies = []
file_lock = threading.Lock()
current_executor_id = None # Bi·∫øn l∆∞u ID executor hi·ªán t·∫°i ƒë·ªÉ check logic Delta

# ==============================================================================
# -- C√ÅC H√ÄM TI·ªÜN √çCH & KI·ªÇM TRA ROOT --
# ==============================================================================

def check_root_access():
    """Ki·ªÉm tra quy·ªÅn root."""
    print("[MAIN] ƒêang ki·ªÉm tra quy·ªÅn root...")
    try:
        process = subprocess.run(["su", "-c", "whoami"], capture_output=True, text=True, timeout=10)
        if process.stdout.strip() == "root":
            print("[MAIN] ‚úÖ Quy·ªÅn root ƒë√£ ƒë∆∞·ª£c c·∫•p.")
            return True
        else:
            print(f"[MAIN] ‚ùå L·ªói: Kh√¥ng c√≥ quy·ªÅn root (k·∫øt qu·∫£: {process.stdout.strip()}).")
            return False
    except Exception as e:
        print(f"[MAIN] ‚ùå L·ªói ki·ªÉm tra root: {e}")
        return False

def fetch_and_load_config(url):
    """
    T·∫£i c·∫•u h√¨nh t·ª´ xa v√† x·ª≠ l√Ω logic ƒë∆∞·ªùng d·∫´n ƒë·ªông.
    """
    global current_executor_id
    # print("[CONFIG] ƒêang t·∫£i c·∫•u h√¨nh t·ª´ server...") # Gi·∫£m spam log
    try:
        response = requests.get(url, timeout=20)
        response.raise_for_status()
        
        config = {}
        pattern = re.compile(r'^\s*([A-Za-z_][A-Za-z0-9_]*)\s*=\s*(["\'])(.*?)\2', re.DOTALL | re.MULTILINE)
        
        for key, _, value in pattern.findall(response.text):
            value = value.strip()
            if key in ["SCAN_INTERVAL_SECONDS", "LAUNCH_INTERVAL_SECONDS", "CONNECTION_TIMEOUT", "REBOOT_INTERVAL_MINUTES", "LAUNCH_DELAY_SECONDS", "KEY_CHECK_INTERVAL_MINUTES"]:
                config[key] = int(value)
            elif key in ["MIN_PLAYER_PERCENTAGE", "MAX_PLAYER_PERCENTAGE"]:
                config[key] = float(value)
            elif key == "ACCOUNT_SUFFIXES":
                accounts = []
                for item in value.split(','):
                    item = item.strip()
                    if ':' in item:
                        parts = item.split(':', 1)
                        if len(parts) == 2 and parts[0].strip() and parts[1].strip().isdigit():
                            accounts.append({'suffix': parts[0].strip(), 'id': parts[1].strip()})
                config[key] = accounts
            elif key == "PROXY_LIST":
                config[key] = [item.strip() for item in value.splitlines() if item.strip()]
            else:
                config[key] = value
        
        # --- X·ª¨ L√ù LOGIC EXECUTOR T·ª∞ ƒê·ªòNG ---
        if "SELECTED_EXECUTOR" in config:
            selected_id = config["SELECTED_EXECUTOR"]
            current_executor_id = selected_id # C·∫≠p nh·∫≠t bi·∫øn to√†n c·ª•c
            target_path_key = f"EXECUTOR_PATH_{selected_id}"
            
            if target_path_key in config:
                config["OUTPUT_FILE_PATH"] = config[target_path_key]
            else:
                print(f"[CONFIG] ‚ö†Ô∏è L·ªói: ƒê√£ ch·ªçn Executor {selected_id} nh∆∞ng kh√¥ng t√¨m th·∫•y '{target_path_key}'.")
                sys.exit(1)
        
        if "OUTPUT_FILE_PATH" not in config:
            print("[CONFIG] ‚ùå L·ªói: Thi·∫øu OUTPUT_FILE_PATH.")
            sys.exit(1)

        if "PLACE_ID" not in config:
            print("[CONFIG] ‚ùå L·ªói: Thi·∫øu PLACE_ID.")
            sys.exit(1)

        return config

    except requests.exceptions.RequestException as e:
        print(f"\n[CONFIG] ‚ùå L·ªñI M·∫†NG: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"\n[CONFIG] ‚ùå L·ªñI X·ª¨ L√ù: {e}")
        sys.exit(1)

def format_proxies(proxy_list):
    formatted = []
    if not proxy_list: return []
    for proxy_string in proxy_list:
        if not proxy_string: continue
        parts = proxy_string.split(':')
        proxy_url = ""
        if len(parts) == 2: proxy_url = f"http://{parts[0]}:{parts[1]}"
        elif len(parts) == 4: proxy_url = f"http://{parts[2]}:{parts[3]}@{parts[0]}:{parts[1]}"
        if proxy_url: formatted.append({"http": proxy_url, "https": proxy_url})
    return formatted

def countdown(seconds, thread_name="MAIN"):
    for i in range(seconds, 0, -1):
        print(f"[{thread_name}] Th·ªùi gian ch·ªù c√≤n l·∫°i: {i} gi√¢y    ", end='\r')
        sys.stdout.flush()
        time.sleep(1)
    print(f"[{thread_name}] B·∫Øt ƒë·∫ßu chu k·ª≥ m·ªõi.                                  ")

# ==============================================================================
# -- C√ÅC H√ÄM K·∫æT N·ªêI API --
# ==============================================================================

def execute_api_request_with_proxy(method, url, config, thread_name, json_data=None):
    global proxy_index, failed_proxy_count, current_proxies
    timeout = config.get("CONNECTION_TIMEOUT", 15)
    num_proxies = len(current_proxies)
    
    while True:
        if num_proxies > 0 and failed_proxy_count >= num_proxies:
            print(f"\n[{thread_name}] [!] T·∫•t c·∫£ proxies l·ªói. Ngh·ªâ 5 gi√¢y...")
            time.sleep(5)
            failed_proxy_count = 0; proxy_index = 0
        
        proxy, proxy_status = (current_proxies[proxy_index], f"Proxy {proxy_index + 1}/{num_proxies}") if num_proxies > 0 else (None, "IP G·ªëc")
        
        try:
            print(f"\r[{thread_name}] [*] K·∫øt n·ªëi API... | {proxy_status}", end="")
            sys.stdout.flush()
            if method.upper() == 'GET': response = requests.get(url, proxies=proxy, timeout=timeout)
            elif method.upper() == 'POST': response = requests.post(url, json=json_data, proxies=proxy, timeout=timeout)
            else: raise ValueError(f"Method l·∫°: {method}")
            
            if response.status_code == 200:
                failed_proxy_count = 0
                return response.json()
            
            error_reason = "Rate Limit" if response.status_code == 429 else f"Code {response.status_code}"
            raise requests.exceptions.HTTPError(error_reason)
            
        except (requests.exceptions.RequestException, requests.exceptions.HTTPError, ValueError) as e:
            if num_proxies > 0:
                print(f"\n[{thread_name}] [!] Proxy {proxy_index + 1} l·ªói ({e}). ƒê·ªïi proxy...")
                failed_proxy_count += 1
                proxy_index = (proxy_index + 1) % num_proxies
                time.sleep(1)
            else:
                print(f"\n[{thread_name}] [!] IP G·ªëc l·ªói ({e}). Ngh·ªâ 60 gi√¢y...")
                time.sleep(60)

def execute_direct_api_request(method, url, config, thread_name, json_data=None):
    retries = 3
    timeout = config.get("CONNECTION_TIMEOUT", 15)
    for attempt in range(retries):
        try:
            # print(f"\r[{thread_name}] [*] K·∫øt n·ªëi API (Direct)...", end="")
            # sys.stdout.flush()
            if method.upper() == 'GET': response = requests.get(url, timeout=timeout)
            elif method.upper() == 'POST': response = requests.post(url, json=json_data, timeout=timeout)
            
            if response.status_code == 200: return response.json()
            # print(f"\n[{thread_name}] [!] L·ªói {response.status_code}. Retry...", end="")
        except Exception as e:
            print(f"\n[{thread_name}] [!] L·ªói k·∫øt n·ªëi: {e}. Retry...", end="")
        
        if attempt < retries - 1: time.sleep(5)
        else:
            return None

# ==============================================================================
# -- LOGIC M·ªöI: DELTA KEY MANAGER --
# ==============================================================================

def delta_key_monitor_loop():
    """
    Lu·ªìng ki·ªÉm tra v√† c·∫≠p nh·∫≠t Key Delta.
    Ch·ªâ ch·∫°y n·∫øu Executor = 1.
    """
    thread_name = "DELTA-KEY"
    print(f"[{thread_name}] ƒêang kh·ªüi ƒë·ªông tr√¨nh qu·∫£n l√Ω Key cho Delta...")
    
    # ƒê∆∞·ªùng d·∫´n file license c·ªßa Delta (C·ªë ƒë·ªãnh)
    LOCAL_KEY_PATH = "/storage/emulated/0/Delta/Internals/Cache/license"

    while True:
        # T·∫£i config m·ªõi nh·∫•t ƒë·ªÉ l·∫•y URL v√† Interval
        config = fetch_and_load_config(CONFIG_URL)
        
        # Ki·ªÉm tra xem c√≥ ph·∫£i ƒëang d√πng Delta kh√¥ng (SELECTED_EXECUTOR="1")
        if str(config.get("SELECTED_EXECUTOR")) != "1":
            print(f"[{thread_name}] Kh√¥ng ph·∫£i ch·∫ø ƒë·ªô Delta. Lu·ªìng s·∫Ω ng·ªß ƒë√¥ng d√†i h·∫°n.")
            time.sleep(3600)
            continue

        key_url = config.get("DELTA_KEY_URL")
        interval = config.get("KEY_CHECK_INTERVAL_MINUTES", 30)

        if not key_url:
            print(f"[{thread_name}] ‚ö†Ô∏è C·∫£nh b√°o: Ch∆∞a c·∫•u h√¨nh DELTA_KEY_URL trong config online.")
        else:
            try:
                # 1. L·∫•y Key t·ª´ Github
                print(f"[{thread_name}] ƒêang ki·ªÉm tra Key m·ªõi t·ª´ GitHub...")
                response = requests.get(key_url, timeout=15)
                if response.status_code == 200:
                    remote_key = response.text.strip()
                    
                    # 2. ƒê·ªçc Key hi·ªán t·∫°i trong m√°y
                    local_key = ""
                    if os.path.exists(LOCAL_KEY_PATH):
                        try:
                            with open(LOCAL_KEY_PATH, "r") as f:
                                local_key = f.read().strip()
                        except: pass
                    
                    # 3. So s√°nh
                    if remote_key == local_key:
                        print(f"[{thread_name}] ‚úÖ Key tr√πng kh·ªõp. Kh√¥ng c·∫ßn c·∫≠p nh·∫≠t.")
                    else:
                        print(f"[{thread_name}] ‚ö†Ô∏è PH√ÅT HI·ªÜN KEY M·ªöI! Ti·∫øn h√†nh c·∫≠p nh·∫≠t...")
                        print(f"[{thread_name}] -> C≈©: {local_key[:10]}... | M·ªõi: {remote_key[:10]}...")
                        
                        # ƒê·∫£m b·∫£o th∆∞ m·ª•c t·ªìn t·∫°i
                        os.makedirs(os.path.dirname(LOCAL_KEY_PATH), exist_ok=True)
                        
                        # Ghi ƒë√® file
                        with open(LOCAL_KEY_PATH, "w") as f:
                            f.write(remote_key)
                        
                        print(f"[{thread_name}] ‚úÖ ƒê√£ ghi key m·ªõi th√†nh c√¥ng.")
                        print(f"[{thread_name}] üõë REBOOT H·ªÜ TH·ªêNG TRONG 5 GI√ÇY ƒê·ªÇ √ÅP D·ª§NG...")
                        time.sleep(5)
                        subprocess.run(["su", "-c", "reboot"])
                else:
                    print(f"[{thread_name}] L·ªói t·∫£i Key: HTTP {response.status_code}")
            except Exception as e:
                print(f"[{thread_name}] L·ªói qu√° tr√¨nh check Key: {e}")

        # Ch·ªù ƒë·∫øn l·∫ßn check ti·∫øp theo
        # print(f"[{thread_name}] Ng·ªß {interval} ph√∫t...")
        time.sleep(interval * 60)

# ==============================================================================
# -- LOGIC CH√çNH: SCAN & LAUNCH --
# ==============================================================================

def check_roblox_presence(accounts, config, thread_name):
    user_ids = [int(acc['id']) for acc in accounts]
    if not user_ids: return {}
    api_url = "https://presence.roblox.com/v1/presence/users"
    response = execute_direct_api_request('POST', api_url, config, thread_name, {"userIds": user_ids})
    status_map = {str(uid): False for uid in user_ids}
    if response and 'userPresences' in response:
        for p in response['userPresences']:
            if p.get('userPresenceType') == 2: status_map[str(p.get('userId'))] = True
    return status_map

def run_scanner(config, thread_name="SCAN"):
    global current_proxies
    print(f"[{thread_name}] ƒêang qu√©t server...")
    
    current_proxies = format_proxies(config.get("PROXY_LIST", []))
    min_ratio = config.get("MIN_PLAYER_PERCENTAGE", 0) / 100.0
    max_ratio = config.get("MAX_PLAYER_PERCENTAGE", 100) / 100.0
    place_id = config["PLACE_ID"]
    
    collected_ids, next_cursor = [], ""
    while True:
        api_url = f"https://games.roblox.com/v1/games/{place_id}/servers/Public?sortOrder=Desc&limit=100"
        if next_cursor and next_cursor != "null": api_url += f"&cursor={next_cursor}"
        
        data = execute_api_request_with_proxy('GET', api_url, config, thread_name)
        if not data: continue
        
        servers = data.get("data", [])
        next_cursor = data.get("nextPageCursor")
        
        if not servers:
            print(f"\n[{thread_name}] [i] H·∫øt danh s√°ch server.")
            break
            
        total_ratio = sum((s.get("playing", 0) / s.get("maxPlayers", 1)) for s in servers if s.get("maxPlayers", 0) > 0)
        
        for s in servers:
            if s.get("maxPlayers", 0) > 0:
                ratio = s.get("playing", 0) / s.get("maxPlayers")
                if min_ratio <= ratio <= max_ratio:
                    sid = s.get("id")
                    if sid and sid not in collected_ids: collected_ids.append(sid)
        
        avg_ratio = (total_ratio / len(servers)) if servers else 0
        print(f"\r[{thread_name}] Qu√©t... | T·ªâ l·ªá trang: {avg_ratio * 100:5.1f}% | ƒê√£ t√¨m: {len(collected_ids):<5}", end="")
        
        if 0 < avg_ratio < min_ratio or not next_cursor or next_cursor == "null":
            print(f"\n[{thread_name}] [i] ƒê·∫°t gi·ªõi h·∫°n d∆∞·ªõi ho·∫∑c h·∫øt trang.")
            break
            
    output_path = config["OUTPUT_FILE_PATH"]
    
    output_dir = os.path.dirname(output_path)
    if output_dir and not os.path.exists(output_dir):
        try: os.makedirs(output_dir)
        except: pass

    with file_lock:
        try:
            with open(output_path, "w") as f:
                for sid in collected_ids: f.write(f"{sid}\n")
            print(f"[{thread_name}] ‚úÖ ƒê√£ l∆∞u {len(collected_ids)} ID v√†o: {output_path}")
        except Exception as e:
            print(f"\n[{thread_name}] ‚ùå L·ªói ghi file: {e}")
            
    return True

def launch_roblox_instances(config, launch_mode, thread_name="LAUNCH"):
    accounts = config.get("ACCOUNT_SUFFIXES", [])
    if not accounts:
        print(f"[{thread_name}] L·ªói: Ch∆∞a c·∫•u h√¨nh t√†i kho·∫£n.")
        return

    print(f"[{thread_name}] Ki·ªÉm tra online (L·∫ßn 1)...")
    online_statuses = check_roblox_presence(accounts, config, thread_name)
    
    # --- LOGIC DOUBLE CHECK ---
    # T√¨m nh·ªØng t√†i kho·∫£n b·ªã b√°o Offline
    offline_candidates = [acc for acc in accounts if not online_statuses.get(acc['id'], False)]
    
    if offline_candidates:
        print(f"[{thread_name}] ‚ö†Ô∏è Ph√°t hi·ªán {len(offline_candidates)} t√†i kho·∫£n Offline. Ch·ªù 10s ƒë·ªÉ ki·ªÉm tra l·∫°i (Double Check)...")
        time.sleep(10)
        
        print(f"[{thread_name}] Ki·ªÉm tra online (L·∫ßn 2)...")
        # Check l·∫°i ch·ªâ nh·ªØng ng∆∞·ªùi offline
        recheck_statuses = check_roblox_presence(offline_candidates, config, thread_name)
        
        # C·∫≠p nh·∫≠t l·∫°i status ch√≠nh
        for uid, status in recheck_statuses.items():
            online_statuses[uid] = status # N·∫øu True th√¨ c·∫≠p nh·∫≠t th√†nh True, False v·∫´n False
    # --------------------------

    server_ids = []
    if launch_mode == 'scan':
        with file_lock:
            try:
                with open(config['OUTPUT_FILE_PATH'], 'r') as f:
                    server_ids = [line.strip() for line in f if line.strip()]
            except: pass
        if not server_ids:
            print(f"[{thread_name}] Ch∆∞a c√≥ server ƒë·ªÉ join. Ch·ªù qu√©t...")
            return

    base_pkg = config.get("BASE_PACKAGE_NAME", "com.roblox.clien")
    
    for i, acc in enumerate(accounts):
        suffix, uid = acc['suffix'], acc['id']
        pkg_name = f"{base_pkg}{suffix}"
        
        if not online_statuses.get(uid, False):
            print(f"[{thread_name}] [CONFIRMED OFFLINE] '{suffix}' (ID: {uid}) -> Kill & Start.")
            try:
                cmd_kill = f"PID=$(ps -ef | grep {pkg_name} | grep -v grep | awk '{{print $2}}'); if [ ! -z \"$PID\" ]; then kill -9 $PID; fi"
                subprocess.run(["su", "-c", cmd_kill], capture_output=True, timeout=10)
                time.sleep(3)
            except: pass
        else:
            print(f"[{thread_name}] [REFRESH] '{suffix}' Online -> Re-join.")
            
        target_url = ""
        if launch_mode == 'scan':
            target_url = f"roblox://placeId={config['PLACE_ID']}&gameId={server_ids[i % len(server_ids)]}"
        elif launch_mode == 'vip':
            target_url = config.get('VIP_SERVER_URL', "")
            
        if target_url:
            subprocess.run(["am", "start", "-a", "android.intent.action.VIEW", "-d", target_url, "-p", pkg_name], capture_output=True)
            print(f"[{thread_name}] -> ƒê√£ g·ªçi l·ªánh start cho {pkg_name}")
            
        time.sleep(config.get("LAUNCH_DELAY_SECONDS", 10))

# ==============================================================================
# -- V√íNG L·∫∂P & MAIN --
# ==============================================================================

def scanner_loop():
    print("[SCAN] B·∫Øt ƒë·∫ßu...")
    config = fetch_and_load_config(CONFIG_URL)
    while True:
        run_scanner(config, "SCAN")
        countdown(config.get("SCAN_INTERVAL_SECONDS", 300), "SCAN")

def launcher_loop(mode):
    print(f"[LAUNCH] B·∫Øt ƒë·∫ßu ch·∫ø ƒë·ªô {mode}...")
    config = fetch_and_load_config(CONFIG_URL)
    while True:
        launch_roblox_instances(config, mode, "LAUNCH")
        countdown(config.get("LAUNCH_INTERVAL_SECONDS", 300), "LAUNCH")

def reboot_loop():
    print("[REBOOT] Ki·ªÉm tra l·ªãch...")
    config = fetch_and_load_config(CONFIG_URL)
    if config.get("REBOOT_ENABLED", "off").lower() == "on":
        mins = config.get("REBOOT_INTERVAL_MINUTES", 1200)
        print(f"[REBOOT] H·∫πn gi·ªù: {mins} ph√∫t.")
        time.sleep(mins * 60)
        print("[REBOOT] ƒêang kh·ªüi ƒë·ªông l·∫°i...")
        try: subprocess.run(["su", "-c", "reboot"])
        except: pass

if __name__ == "__main__":
    if not check_root_access(): sys.exit(1)
    
    # Lu·ªìng 1: Reboot ƒë·ªãnh k·ª≥
    threading.Thread(target=reboot_loop, daemon=True).start()

    # Lu·ªìng 2: Delta Key Manager (T·ª± check config b√™n trong ƒë·ªÉ ch·∫°y hay ng·ªß)
    threading.Thread(target=delta_key_monitor_loop, daemon=True).start()

    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(dest='command')
    subparsers.add_parser('parallel')
    subparsers.add_parser('scan')
    lp = subparsers.add_parser('launch')
    lp.add_argument('--mode', choices=['scan', 'vip'], default='scan')
    
    args = parser.parse_args()
    cmd = args.command if args.command else 'parallel'

    try:
        if cmd == 'scan': scanner_loop()
        elif cmd == 'launch': launcher_loop(args.mode)
        elif cmd == 'parallel':
            threading.Thread(target=scanner_loop, daemon=True).start()
            time.sleep(3)
            threading.Thread(target=launcher_loop, args=('vip',), daemon=True).start()
            while True: time.sleep(1)
    except KeyboardInterrupt:
        print("\n[MAIN] D·ª´ng.")
