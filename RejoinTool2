#!/data/data/com.termux/files/usr/bin/python
# -*- coding: utf-8 -*-

import subprocess
import time
import requests
import os
import sys
import argparse
import re
import threading
import json
import random
from datetime import datetime

# ==============================================================================
# SCRIPT: Lychkins's Task Runner v1.6 (Smart Random - No Duplicate)
#
# C·∫¨P NH·∫¨T M·ªöI (v1.6):
# 1. Smart Random Selection:
#    - Kh·∫Øc ph·ª•c v·∫•n ƒë·ªÅ random tr√πng l·∫∑p: Khi ch·ªçn proxy ng·∫´u nhi√™n m·ªõi,
#      h·ªá th·ªëng s·∫Ω ƒë·∫£m b·∫£o Index m·ªõi != Index c≈© (n·∫øu c√≥ nhi·ªÅu h∆°n 1 proxy).
#    - √Åp d·ª•ng cho c·∫£ Scanner (khi ƒë·ªïi IP) v√† Launcher (khi Retry ho·∫∑c Next Check).
# ==============================================================================

# ---------------------------------------------------
# -- URL C·∫§U H√åNH --
# ---------------------------------------------------
CONFIG_URL = "https://raw.githubusercontent.com/AinsworthNecco/Lychkin/refs/heads/main/config2"

# ---------------------------------------------------
# -- BI·∫æN TO√ÄN C·ª§C --
# ---------------------------------------------------
proxy_index = 0
failed_proxy_count = 0
current_proxies = []
file_lock = threading.Lock()
current_executor_id = None 

# ==============================================================================
# -- C√ÅC H√ÄM TI·ªÜN √çCH & KI·ªÇM TRA ROOT --
# ==============================================================================

def check_root_access():
    """Ki·ªÉm tra quy·ªÅn root."""
    print("[MAIN] ƒêang ki·ªÉm tra quy·ªÅn root...")
    try:
        process = subprocess.run(["su", "-c", "whoami"], capture_output=True, text=True, timeout=10)
        if process.stdout.strip() == "root":
            print("[MAIN] ‚úÖ Quy·ªÅn root ƒë√£ ƒë∆∞·ª£c c·∫•p.")
            return True
        else:
            print(f"[MAIN] ‚ùå L·ªói: Kh√¥ng c√≥ quy·ªÅn root (k·∫øt qu·∫£: {process.stdout.strip()}).")
            return False
    except Exception as e:
        print(f"[MAIN] ‚ùå L·ªói ki·ªÉm tra root: {e}")
        return False

def check_process_running(pkg_name):
    """
    Ki·ªÉm tra xem package c√≥ ƒëang ch·∫°y kh√¥ng b·∫±ng l·ªánh ps.
    Tr·∫£ v·ªÅ True n·∫øu t√¨m th·∫•y process, False n·∫øu kh√¥ng.
    """
    try:
        # grep -v grep ƒë·ªÉ tr√°nh t√¨m th·∫•y ch√≠nh c√¢u l·ªánh grep
        cmd = f"ps -ef | grep {pkg_name} | grep -v grep"
        result = subprocess.run(["su", "-c", cmd], capture_output=True, text=True, timeout=5)
        # N·∫øu output c√≥ n·ªôi dung -> Process ƒëang ch·∫°y
        if result.stdout.strip():
            return True
        return False
    except Exception:
        return False

def fetch_and_load_config(url):
    """T·∫£i c·∫•u h√¨nh t·ª´ xa v√† x·ª≠ l√Ω logic ƒë∆∞·ªùng d·∫´n ƒë·ªông."""
    global current_executor_id
    try:
        response = requests.get(url, timeout=20)
        response.raise_for_status()
        
        config = {}
        pattern = re.compile(r'^\s*([A-Za-z_][A-Za-z0-9_]*)\s*=\s*(["\'])(.*?)\2', re.DOTALL | re.MULTILINE)
        
        for key, _, value in pattern.findall(response.text):
            value = value.strip()
            if key in ["SCAN_INTERVAL_SECONDS", "LAUNCH_INTERVAL_SECONDS", "CONNECTION_TIMEOUT", "REBOOT_INTERVAL_MINUTES", "LAUNCH_DELAY_SECONDS", "KEY_CHECK_INTERVAL_MINUTES"]:
                config[key] = int(value)
            elif key in ["MIN_PLAYER_PERCENTAGE", "MAX_PLAYER_PERCENTAGE"]:
                config[key] = float(value)
            elif key == "ACCOUNT_SUFFIXES":
                accounts = []
                for item in value.split(','):
                    item = item.strip()
                    if ':' in item:
                        parts = item.split(':', 1)
                        if len(parts) == 2 and parts[0].strip() and parts[1].strip().isdigit():
                            accounts.append({'suffix': parts[0].strip(), 'id': parts[1].strip()})
                config[key] = accounts
            elif key == "PROXY_LIST":
                config[key] = [item.strip() for item in value.splitlines() if item.strip()]
            else:
                config[key] = value
        
        # --- X·ª¨ L√ù LOGIC EXECUTOR T·ª∞ ƒê·ªòNG ---
        if "SELECTED_EXECUTOR" in config:
            selected_id = config["SELECTED_EXECUTOR"]
            current_executor_id = selected_id
            target_path_key = f"EXECUTOR_PATH_{selected_id}"
            
            if target_path_key in config:
                config["OUTPUT_FILE_PATH"] = config[target_path_key]
            else:
                print(f"[CONFIG] ‚ö†Ô∏è L·ªói: ƒê√£ ch·ªçn Executor {selected_id} nh∆∞ng kh√¥ng t√¨m th·∫•y '{target_path_key}'.")
                sys.exit(1)
        
        if "OUTPUT_FILE_PATH" not in config:
            print("[CONFIG] ‚ùå L·ªói: Thi·∫øu OUTPUT_FILE_PATH.")
            sys.exit(1)

        if "PLACE_ID" not in config:
            print("[CONFIG] ‚ùå L·ªói: Thi·∫øu PLACE_ID.")
            sys.exit(1)

        return config

    except requests.exceptions.RequestException as e:
        print(f"\n[CONFIG] ‚ùå L·ªñI M·∫†NG: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"\n[CONFIG] ‚ùå L·ªñI X·ª¨ L√ù: {e}")
        sys.exit(1)

def format_proxies(proxy_list):
    """Chuy·ªÉn ƒë·ªïi danh s√°ch proxy string sang ƒë·ªãnh d·∫°ng requests."""
    formatted = []
    if not proxy_list: return []
    for proxy_string in proxy_list:
        if not proxy_string: continue
        parts = proxy_string.split(':')
        proxy_url = ""
        if len(parts) == 2: proxy_url = f"http://{parts[0]}:{parts[1]}"
        elif len(parts) == 4: proxy_url = f"http://{parts[2]}:{parts[3]}@{parts[0]}:{parts[1]}"
        if proxy_url: formatted.append({"http": proxy_url, "https": proxy_url})
    return formatted

def countdown(seconds, thread_name="MAIN"):
    for i in range(seconds, 0, -1):
        print(f"[{thread_name}] Th·ªùi gian ch·ªù c√≤n l·∫°i: {i} gi√¢y    ", end='\r')
        sys.stdout.flush()
        time.sleep(1)
    print(f"[{thread_name}] B·∫Øt ƒë·∫ßu chu k·ª≥ m·ªõi.                                      ")

# ==============================================================================
# -- C√ÅC H√ÄM K·∫æT N·ªêI API --
# ==============================================================================

def execute_api_request_with_proxy(method, url, config, thread_name, json_data=None):
    """Th·ª±c hi·ªán request v·ªõi logic xoay v√≤ng (rotation) proxy ng·∫´u nhi√™n (tr√°nh tr√πng l·∫∑p)."""
    global proxy_index, failed_proxy_count, current_proxies
    timeout = config.get("CONNECTION_TIMEOUT", 15)
    num_proxies = len(current_proxies)
    
    while True:
        if num_proxies > 0 and failed_proxy_count >= num_proxies:
            print(f"\n[{thread_name}] [!] T·∫•t c·∫£ proxies l·ªói. Ngh·ªâ 5 gi√¢y...")
            time.sleep(5)
            failed_proxy_count = 0; 
            # Reset random index
            if num_proxies > 0:
                proxy_index = random.randint(0, num_proxies - 1)
        
        proxy, proxy_status = (current_proxies[proxy_index], f"Proxy {proxy_index + 1}/{num_proxies}") if num_proxies > 0 else (None, "IP G·ªëc")
        
        try:
            print(f"\r[{thread_name}] [*] K·∫øt n·ªëi API... | {proxy_status}", end="")
            sys.stdout.flush()
            if method.upper() == 'GET': response = requests.get(url, proxies=proxy, timeout=timeout)
            elif method.upper() == 'POST': response = requests.post(url, json=json_data, proxies=proxy, timeout=timeout)
            else: raise ValueError(f"Method l·∫°: {method}")
            
            if response.status_code == 200:
                failed_proxy_count = 0
                return response.json()
            
            error_reason = "Rate Limit" if response.status_code == 429 else f"Code {response.status_code}"
            raise requests.exceptions.HTTPError(error_reason)
            
        except (requests.exceptions.RequestException, requests.exceptions.HTTPError, ValueError) as e:
            if num_proxies > 0:
                print(f"\n[{thread_name}] [!] Proxy {proxy_index + 1} l·ªói ({e}). Ch·ªçn ng·∫´u nhi√™n proxy KH√ÅC...")
                failed_proxy_count += 1
                
                # --- LOGIC TR√ÅNH TR√ôNG L·∫∂P CHO SCANNER ---
                if num_proxies > 1:
                    new_index = proxy_index
                    while new_index == proxy_index: # L·∫∑p l·∫°i cho ƒë·∫øn khi t√¨m ƒë∆∞·ª£c index kh√°c
                        new_index = random.randint(0, num_proxies - 1)
                    proxy_index = new_index
                else:
                    # Ch·ªâ c√≥ 1 proxy th√¨ ƒë√†nh ch·ªãu
                    pass
                    
                time.sleep(1)
            else:
                print(f"\n[{thread_name}] [!] IP G·ªëc l·ªói ({e}). Ngh·ªâ 60 gi√¢y...")
                time.sleep(60)

def execute_api_request_simple(method, url, config, thread_name, json_data=None, proxy=None):
    """Th·ª±c hi·ªán request ƒë∆°n gi·∫£n, d√πng proxy ch·ªâ ƒë·ªãnh (KH√îNG c√≥ rotation)."""
    timeout = config.get("CONNECTION_TIMEOUT", 15)
    proxies = proxy if proxy else None
    
    try:
        if method.upper() == 'GET': response = requests.get(url, proxies=proxies, timeout=timeout)
        elif method.upper() == 'POST': response = requests.post(url, json=json_data, proxies=proxies, timeout=timeout)
        else: raise ValueError(f"Method l·∫°: {method}")
        
        if response.status_code == 200: return response.json()
        
    except Exception:
        # B·ªè qua l·ªói k·∫øt n·ªëi proxy/m·∫°ng v√† tr·∫£ v·ªÅ None
        pass 
        
    return None

def check_roblox_presence_single(account_id, config, thread_name, proxy_list, initial_proxy_index):
    """
    Ki·ªÉm tra tr·∫°ng th√°i online v1.6 (No Duplicate Random).
    Logic:
    - Khi Retry ho·∫∑c Next Check, ƒë·∫£m b·∫£o kh√¥ng ch·ªçn l·∫°i ƒë√∫ng proxy v·ª´a d√πng (n·∫øu list > 1).
    """
    user_ids = [int(account_id)]
    api_url = "https://presence.roblox.com/v1/presence/users"
    payload = {"userIds": user_ids}
    
    formatted_proxies = proxy_list
    num_proxies = len(formatted_proxies)
    
    # S·ªë l·∫ßn c·∫ßn x√°c nh·∫≠n h·ª£p l·ªá
    REQUIRED_VALID_CHECKS = 3
    valid_checks_count = 0
    
    # Index proxy hi·ªán t·∫°i
    current_idx = initial_proxy_index if initial_proxy_index >= 0 else 0
    
    # Bi·∫øn ƒë·∫øm l·ªói li√™n ti·∫øp
    consecutive_network_failures = 0
    MAX_CONSECUTIVE_FAILURES = 50 

    while valid_checks_count < REQUIRED_VALID_CHECKS:
        
        # --- V√íNG L·∫∂P T√åM K·∫æT N·ªêI (RETRY LOOP) ---
        response = None
        while response is None:
            # Ch·ªçn proxy
            proxy = None
            proxy_info = "IP G·ªëc"
            
            if num_proxies > 0:
                # ƒê·∫£m b·∫£o index n·∫±m trong gi·ªõi h·∫°n
                current_idx = current_idx % num_proxies
                proxy = formatted_proxies[current_idx]
                proxy_info = f"Proxy #{current_idx + 1}"
            
            # In log ƒëang th·ª≠
            print(f"[{thread_name}] [{account_id}] Check l·∫ßn {valid_checks_count + 1}/{REQUIRED_VALID_CHECKS} | ƒêang th·ª≠ {proxy_info}...", end='\r')
            sys.stdout.flush()

            # G·ªçi API
            response = execute_api_request_simple('POST', api_url, config, thread_name, json_data=payload, proxy=proxy)

            if response is None:
                # L·ªñI K·∫æT N·ªêI/PROXY
                consecutive_network_failures += 1
                print(f"[{thread_name}] [{account_id}] {proxy_info} ‚ùå L·ªói m·∫°ng. ƒê·ª£i 1s -> Random Proxy KH√ÅC...         ")
                time.sleep(1) # Y√™u c·∫ßu: ƒê·ª£i 1 gi√¢y
                
                if num_proxies > 0:
                    # --- LOGIC TR√ÅNH TR√ôNG L·∫∂P KHI RETRY ---
                    if num_proxies > 1:
                        new_idx = current_idx
                        while new_idx == current_idx:
                            new_idx = random.randint(0, num_proxies - 1)
                        current_idx = new_idx
                    else:
                        pass # 1 proxy th√¨ ch·ªãu
                else:
                    time.sleep(2)
                
                # Safety break
                if consecutive_network_failures > MAX_CONSECUTIVE_FAILURES:
                    print(f"[{thread_name}] [{account_id}] ‚ùå QU√Å NHI·ªÄU L·ªñI K·∫æT N·ªêI LI√äN TI·∫æP. H·ªßy check.")
                    return False
            else:
                # K·∫æT N·ªêI TH√ÄNH C√îNG (HTTP 200)
                consecutive_network_failures = 0 # Reset ƒë·∫øm l·ªói
                # (Tho√°t v√≤ng l·∫∑p while response is None)

        # --- X·ª¨ L√ù D·ªÆ LI·ªÜU JSON (Khi ƒë√£ c√≥ response) ---
        is_online = False
        if 'userPresences' in response:
            for p in response['userPresences']:
                if p.get('userPresenceType') == 2 and str(p.get('userId')) == str(account_id):
                    is_online = True
        
        if is_online:
            print(f"[{thread_name}] [{account_id}] ‚úÖ {proxy_info}: PH√ÅT HI·ªÜN ONLINE! (D·ª´ng check)               ")
            return True
        else:
            print(f"[{thread_name}] [{account_id}] ‚ö†Ô∏è {proxy_info}: B√°o OFFLINE (L·∫ßn h·ª£p l·ªá {valid_checks_count + 1})")
            valid_checks_count += 1
            
            # ƒê·ªÉ l·∫ßn check ti·∫øp theo d√πng proxy kh√°c cho kh√°ch quan
            if num_proxies > 0:
                # --- LOGIC TR√ÅNH TR√ôNG L·∫∂P CHO L·∫¶N CHECK TI·∫æP THEO ---
                if num_proxies > 1:
                    new_idx = current_idx
                    while new_idx == current_idx:
                        new_idx = random.randint(0, num_proxies - 1)
                    current_idx = new_idx
            
            # Ngh·ªâ nh·∫π 1 x√≠u gi·ªØa c√°c l·∫ßn check h·ª£p l·ªá
            time.sleep(0.5)

    # N·∫øu ch·∫°y h·∫øt v√≤ng while m√† kh√¥ng return True -> Confirm Offline
    print(f"[{thread_name}] [{account_id}] üõë X√ÅC NH·∫¨N OFFLINE sau {REQUIRED_VALID_CHECKS} l·∫ßn check th√†nh c√¥ng.")
    return False


# ==============================================================================
# -- LOGIC M·ªöI: DELTA KEY MANAGER --
# ==============================================================================

def delta_key_monitor_loop():
    """
    Lu·ªìng ki·ªÉm tra v√† c·∫≠p nh·∫≠t Key Delta.
    Ch·ªâ ch·∫°y n·∫øu Executor = 1.
    """
    thread_name = "DELTA-KEY"
    print(f"[{thread_name}] ƒêang kh·ªüi ƒë·ªông tr√¨nh qu·∫£n l√Ω Key cho Delta...")
    
    # ƒê∆∞·ªùng d·∫´n file license c·ªßa Delta (C·ªë ƒë·ªãnh)
    LOCAL_KEY_PATH = "/storage/emulated/0/Delta/Internals/Cache/license"

    while True:
        # T·∫£i config m·ªõi nh·∫•t ƒë·ªÉ l·∫•y URL v√† Interval
        config = fetch_and_load_config(CONFIG_URL)
        
        # Ki·ªÉm tra xem c√≥ ph·∫£i ƒëang d√πng Delta kh√¥ng (SELECTED_EXECUTOR="1")
        if str(config.get("SELECTED_EXECUTOR")) != "1":
            print(f"[{thread_name}] Kh√¥ng ph·∫£i ch·∫ø ƒë·ªô Delta. Lu·ªìng s·∫Ω ng·ªß ƒë√¥ng d√†i h·∫°n.")
            time.sleep(3600)
            continue

        key_url = config.get("DELTA_KEY_URL")
        interval = config.get("KEY_CHECK_INTERVAL_MINUTES", 30)

        if not key_url:
            print(f"[{thread_name}] ‚ö†Ô∏è C·∫£nh b√°o: Ch∆∞a c·∫•u h√¨nh DELTA_KEY_URL trong config online.")
        else:
            try:
                # 1. L·∫•y Key t·ª´ Github
                print(f"[{thread_name}] ƒêang ki·ªÉm tra Key m·ªõi t·ª´ GitHub...")
                response = requests.get(key_url, timeout=15)
                if response.status_code == 200:
                    remote_key = response.text.strip()
                    
                    # 2. ƒê·ªçc Key hi·ªán t·∫°i trong m√°y
                    local_key = ""
                    if os.path.exists(LOCAL_KEY_PATH):
                        try:
                            with open(LOCAL_KEY_PATH, "r") as f:
                                local_key = f.read().strip()
                        except: pass
                    
                    # 3. So s√°nh
                    if remote_key == local_key:
                        print(f"[{thread_name}] ‚úÖ Key tr√πng kh·ªõp. Kh√¥ng c·∫ßn c·∫≠p nh·∫≠t.")
                    else:
                        print(f"[{thread_name}] ‚ö†Ô∏è PH√ÅT HI·ªÜN KEY M·ªöI! Ti·∫øn h√†nh c·∫≠p nh·∫≠t...")
                        
                        # ƒê·∫£m b·∫£o th∆∞ m·ª•c t·ªìn t·∫°i
                        os.makedirs(os.path.dirname(LOCAL_KEY_PATH), exist_ok=True)
                        
                        # Ghi ƒë√® file
                        with open(LOCAL_KEY_PATH, "w") as f:
                            f.write(remote_key)
                        
                        print(f"[{thread_name}] ‚úÖ ƒê√£ ghi key m·ªõi th√†nh c√¥ng.")
                        print(f"[{thread_name}] üõë REBOOT H·ªÜ TH·ªêNG TRONG 5 GI√ÇY ƒê·ªÇ √ÅP D·ª§NG...")
                        time.sleep(5)
                        subprocess.run(["su", "-c", "reboot"])
                else:
                    print(f"[{thread_name}] L·ªói t·∫£i Key: HTTP {response.status_code}")
            except Exception as e:
                print(f"[{thread_name}] L·ªói qu√° tr√¨nh check Key: {e}")

        # Ch·ªù ƒë·∫øn l·∫ßn check ti·∫øp theo
        time.sleep(interval * 60)

# ==============================================================================
# -- LOGIC CH√çNH: SCAN & LAUNCH --
# ==============================================================================

def run_scanner(config, thread_name="SCAN"):
    global current_proxies, proxy_index
    print(f"[{thread_name}] ƒêang qu√©t server...")
    
    current_proxies = format_proxies(config.get("PROXY_LIST", []))
    
    # KH·ªûI T·∫†O PROXY RANDOM CHO SCANNER
    if len(current_proxies) > 0:
        proxy_index = random.randint(0, len(current_proxies) - 1)
        
    min_ratio = config.get("MIN_PLAYER_PERCENTAGE", 0) / 100.0
    max_ratio = config.get("MAX_PLAYER_PERCENTAGE", 100) / 100.0
    place_id = config["PLACE_ID"]
    
    collected_ids, next_cursor = [], ""
    while True:
        api_url = f"https://games.roblox.com/v1/games/{place_id}/servers/Public?sortOrder=Desc&limit=100"
        if next_cursor and next_cursor != "null": api_url += f"&cursor={next_cursor}"
        
        # D√πng h√†m rotation cho scanner
        data = execute_api_request_with_proxy('GET', api_url, config, thread_name) 
        if not data: continue
        
        servers = data.get("data", [])
        next_cursor = data.get("nextPageCursor")
        
        if not servers:
            print(f"\n[{thread_name}] [i] H·∫øt danh s√°ch server.")
            break
            
        total_ratio = sum((s.get("playing", 0) / s.get("maxPlayers", 1)) for s in servers if s.get("maxPlayers", 0) > 0)
        
        for s in servers:
            if s.get("maxPlayers", 0) > 0:
                ratio = s.get("playing", 0) / s.get("maxPlayers")
                if min_ratio <= ratio <= max_ratio:
                    sid = s.get("id")
                    if sid and sid not in collected_ids: collected_ids.append(sid)
        
        avg_ratio = (total_ratio / len(servers)) if servers else 0
        print(f"\r[{thread_name}] Qu√©t... | T·ªâ l·ªá trang: {avg_ratio * 100:5.1f}% | ƒê√£ t√¨m: {len(collected_ids):<5}", end="")
        
        if 0 < avg_ratio < min_ratio or not next_cursor or next_cursor == "null":
            print(f"\n[{thread_name}] [i] ƒê·∫°t gi·ªõi h·∫°n d∆∞·ªõi ho·∫∑c h·∫øt trang.")
            break
            
    output_path = config["OUTPUT_FILE_PATH"]
    
    output_dir = os.path.dirname(output_path)
    if output_dir and not os.path.exists(output_dir):
        try: os.makedirs(output_dir)
        except: pass

    with file_lock:
        try:
            with open(output_path, "w") as f:
                with open(output_path, "w") as f:
                    for sid in collected_ids: f.write(f"{sid}\n")
            print(f"[{thread_name}] ‚úÖ ƒê√£ l∆∞u {len(collected_ids)} ID v√†o: {output_path}")
        except Exception as e:
            print(f"\n[{thread_name}] ‚ùå L·ªói ghi file: {e}")
            
    return True

def launch_roblox_instances(config, launch_mode, thread_name="LAUNCH"):
    accounts = config.get("ACCOUNT_SUFFIXES", [])
    if not accounts:
        print(f"[{thread_name}] L·ªói: Ch∆∞a c·∫•u h√¨nh t√†i kho·∫£n.")
        return
    
    server_ids = []
    if launch_mode == 'scan':
        with file_lock:
            try:
                with open(config['OUTPUT_FILE_PATH'], 'r') as f:
                    server_ids = [line.strip() for line in f if line.strip()]
            except: pass
        if not server_ids:
            print(f"[{thread_name}] Ch∆∞a c√≥ server ƒë·ªÉ join. Ch·ªù qu√©t...")
            return

    base_pkg = config.get("BASE_PACKAGE_NAME", "com.roblox.clien")
    formatted_proxies = format_proxies(config.get("PROXY_LIST", []))
    num_proxies = len(formatted_proxies)
    
    for i, acc in enumerate(accounts):
        suffix, uid = acc['suffix'], acc['id']
        pkg_name = f"{base_pkg}{suffix}"
        
        print(f"\n[{thread_name}] ---- CHECK ACCOUNT: {suffix} (ID: {uid}) ----")
        
        # ======================================================================
        # 1. KI·ªÇM TRA PROCESS (C√≥ ƒëang ch·∫°y ng·∫ßm kh√¥ng?)
        # ======================================================================
        is_process_active = check_process_running(pkg_name)
        should_launch = False
        
        if not is_process_active:
            print(f"[{thread_name}] ‚ö†Ô∏è PH√ÅT HI·ªÜN: App '{suffix}' ƒëang T·∫ÆT (Kh√¥ng t√¨m th·∫•y Process).")
            print(f"[{thread_name}] -> B·ªè qua check API Online. Ti·∫øn h√†nh START ngay.")
            should_launch = True
        else:
            print(f"[{thread_name}] ‚ÑπÔ∏è App '{suffix}' ƒëang CH·∫†Y (Process OK). Ti·∫øn h√†nh check API Strict (v1.6)...")
            
            # ==================================================================
            # 2. LOGIC CHECK API v1.6 (Smart Random)
            # ==================================================================
            
            # Ch·ªçn index ng·∫´u nhi√™n ƒë·ªÉ b·∫Øt ƒë·∫ßu
            start_idx = random.randint(0, num_proxies - 1) if num_proxies > 0 else -1
            
            is_online = check_roblox_presence_single(
                uid, config, thread_name, formatted_proxies, start_idx
            )
            
            if is_online:
                print(f"[{thread_name}] [QUY·∫æT ƒê·ªäNH] '{suffix}' ƒêANG ONLINE. -> Skip.")
                continue # B·ªè qua, qua acc ti·∫øp theo
            else:
                print(f"[{thread_name}] [QUY·∫æT ƒê·ªäNH] '{suffix}' CONFIRMED OFFLINE. -> Kill & Restart.")
                
                # Kill tr∆∞·ªõc khi start l·∫°i
                try:
                    cmd_kill = f"PID=$(ps -ef | grep {pkg_name} | grep -v grep | awk '{{print $2}}'); if [ ! -z \"$PID\" ]; then kill -9 $PID; fi"
                    subprocess.run(["su", "-c", cmd_kill], capture_output=True, timeout=10)
                    time.sleep(3) 
                except: pass
                
                should_launch = True

        # ======================================================================
        # 3. TH·ª∞C THI START (Ch·∫°y n·∫øu Process T·∫Øt HO·∫∂C Process B·∫≠t nh∆∞ng Offline)
        # ======================================================================
        if should_launch:
            target_url = ""
            if launch_mode == 'scan':
                if server_ids:
                    target_url = f"roblox://placeId={config['PLACE_ID']}&gameId={server_ids[i % len(server_ids)]}"
                else:
                    print(f"[{thread_name}] [-] Kh√¥ng c√≥ server h·ª£p l·ªá ƒë·ªÉ join cho '{suffix}'. B·ªè qua start.")
                    continue
            elif launch_mode == 'vip':
                target_url = config.get('VIP_SERVER_URL', "")
            
            if target_url:
                subprocess.run(["am", "start", "-a", "android.intent.action.VIEW", "-d", target_url, "-p", pkg_name], capture_output=True)
                print(f"[{thread_name}] -> ƒê√£ g·ªçi l·ªánh start cho {pkg_name}")
            
            # Ngh·ªâ gi·ªØa c√°c l·∫ßn kh·ªüi ƒë·ªông acc
            delay = config.get("LAUNCH_DELAY_SECONDS", 10)
            if i < len(accounts) - 1:
                print(f"[{thread_name}] ƒê·ª£i {delay}s tr∆∞·ªõc khi qua acc ti·∫øp theo...")
                time.sleep(delay)

# ==============================================================================
# -- V√íNG L·∫∂P & MAIN --
# ==============================================================================

def scanner_loop():
    print("[SCAN] B·∫Øt ƒë·∫ßu...")
    config = fetch_and_load_config(CONFIG_URL)
    while True:
        run_scanner(config, "SCAN")
        countdown(config.get("SCAN_INTERVAL_SECONDS", 300), "SCAN")

def launcher_loop(mode):
    print(f"[LAUNCH] B·∫Øt ƒë·∫ßu ch·∫ø ƒë·ªô {mode}...")
    config = fetch_and_load_config(CONFIG_URL)
    while True:
        launch_roblox_instances(config, mode, "LAUNCH")
        countdown(config.get("LAUNCH_INTERVAL_SECONDS", 300), "LAUNCH")

def reboot_loop():
    print("[REBOOT] Ki·ªÉm tra l·ªãch...")
    config = fetch_and_load_config(CONFIG_URL)
    if config.get("REBOOT_ENABLED", "off").lower() == "on":
        mins = config.get("REBOOT_INTERVAL_MINUTES", 1200)
        print(f"[REBOOT] H·∫πn gi·ªù: {mins} ph√∫t.")
        time.sleep(mins * 60)
        print("[REBOOT] ƒêang kh·ªüi ƒë·ªông l·∫°i...")
        try: subprocess.run(["su", "-c", "reboot"])
        except: pass

if __name__ == "__main__":
    os.system("termux-wake-lock")
    if not check_root_access(): sys.exit(1)
    
    threading.Thread(target=reboot_loop, daemon=True).start()
    threading.Thread(target=delta_key_monitor_loop, daemon=True).start()

    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(dest='command')
    subparsers.add_parser('parallel')
    subparsers.add_parser('scan')
    lp = subparsers.add_parser('launch')
    lp.add_argument('--mode', choices=['scan', 'vip'], default='scan')
    
    args = parser.parse_args()
    cmd = args.command if args.command else 'parallel'

    try:
        if cmd == 'scan': scanner_loop()
        elif cmd == 'launch': launcher_loop(args.mode)
        elif cmd == 'parallel':
            threading.Thread(target=scanner_loop, daemon=True).start()
            time.sleep(3)
            threading.Thread(target=launcher_loop, args=('vip',), daemon=True).start()
            while True: time.sleep(1)
    except KeyboardInterrupt:
        print("\n[MAIN] D·ª´ng.")
