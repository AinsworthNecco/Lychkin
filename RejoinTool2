#!/data/data/com.termux/files/usr/bin/python
# -*- coding: utf-8 -*-

import subprocess
import time
import requests
import os
import sys
import argparse
import re
import threading
import json
import random # ThÃªm thÆ° viá»‡n random cho viá»‡c chá»n proxy
from datetime import datetime

# ==============================================================================
# SCRIPT Káº¾T Há»¢P: Lychkins's Task Runner v1.2 (Strict Check Mode)
#
# Cáº¬P NHáº¬T Má»šI:
# 1. Logic Launch: Náº¿u tÃ i khoáº£n Ä‘ang ONLINE -> Chá»‰ Skip qua acc khÃ¡c, KHÃ”NG Refresh.
# 2. Logic Check: "Cá»±c ká»³ cháº·t cháº½" (Strict Mode).
#    - Náº¿u API bÃ¡o ONLINE -> Chá»‘t ngay.
#    - Náº¿u API bÃ¡o OFFLINE -> KHÃ”NG tin ngay, tiáº¿p tá»¥c thá»­ cÃ¡c proxy khÃ¡c (Ä‘á»§ 3 láº§n).
#      Chá»‰ chá»‘t Offline khi cáº£ 3 láº§n Ä‘á»u khÃ´ng tháº¥y Online.
# ==============================================================================

# ---------------------------------------------------
# -- URL Cáº¤U HÃŒNH --
# ---------------------------------------------------
CONFIG_URL = "https://raw.githubusercontent.com/AinsworthNecco/Lychkin/refs/heads/main/config2"

# ---------------------------------------------------
# -- BIáº¾N TOÃ€N Cá»¤C --
# ---------------------------------------------------
proxy_index = 0
failed_proxy_count = 0
current_proxies = []
file_lock = threading.Lock()
current_executor_id = None # Biáº¿n lÆ°u ID executor hiá»‡n táº¡i Ä‘á»ƒ check logic Delta

# ==============================================================================
# -- CÃC HÃ€M TIá»†N ÃCH & KIá»‚M TRA ROOT --
# ==============================================================================

def check_root_access():
    """Kiá»ƒm tra quyá»n root."""
    print("[MAIN] Äang kiá»ƒm tra quyá»n root...")
    try:
        process = subprocess.run(["su", "-c", "whoami"], capture_output=True, text=True, timeout=10)
        if process.stdout.strip() == "root":
            print("[MAIN] âœ… Quyá»n root Ä‘Ã£ Ä‘Æ°á»£c cáº¥p.")
            return True
        else:
            print(f"[MAIN] âŒ Lá»—i: KhÃ´ng cÃ³ quyá»n root (káº¿t quáº£: {process.stdout.strip()}).")
            return False
    except Exception as e:
        print(f"[MAIN] âŒ Lá»—i kiá»ƒm tra root: {e}")
        return False

def fetch_and_load_config(url):
    """
    Táº£i cáº¥u hÃ¬nh tá»« xa vÃ  xá»­ lÃ½ logic Ä‘Æ°á»ng dáº«n Ä‘á»™ng.
    """
    global current_executor_id
    try:
        response = requests.get(url, timeout=20)
        response.raise_for_status()
        
        config = {}
        pattern = re.compile(r'^\s*([A-Za-z_][A-Za-z0-9_]*)\s*=\s*(["\'])(.*?)\2', re.DOTALL | re.MULTILINE)
        
        for key, _, value in pattern.findall(response.text):
            value = value.strip()
            if key in ["SCAN_INTERVAL_SECONDS", "LAUNCH_INTERVAL_SECONDS", "CONNECTION_TIMEOUT", "REBOOT_INTERVAL_MINUTES", "LAUNCH_DELAY_SECONDS", "KEY_CHECK_INTERVAL_MINUTES"]:
                config[key] = int(value)
            elif key in ["MIN_PLAYER_PERCENTAGE", "MAX_PLAYER_PERCENTAGE"]:
                config[key] = float(value)
            elif key == "ACCOUNT_SUFFIXES":
                accounts = []
                for item in value.split(','):
                    item = item.strip()
                    if ':' in item:
                        parts = item.split(':', 1)
                        if len(parts) == 2 and parts[0].strip() and parts[1].strip().isdigit():
                            accounts.append({'suffix': parts[0].strip(), 'id': parts[1].strip()})
                config[key] = accounts
            elif key == "PROXY_LIST":
                config[key] = [item.strip() for item in value.splitlines() if item.strip()]
            else:
                config[key] = value
        
        # --- Xá»¬ LÃ LOGIC EXECUTOR Tá»° Äá»˜NG ---
        if "SELECTED_EXECUTOR" in config:
            selected_id = config["SELECTED_EXECUTOR"]
            current_executor_id = selected_id
            target_path_key = f"EXECUTOR_PATH_{selected_id}"
            
            if target_path_key in config:
                config["OUTPUT_FILE_PATH"] = config[target_path_key]
            else:
                print(f"[CONFIG] âš ï¸ Lá»—i: ÄÃ£ chá»n Executor {selected_id} nhÆ°ng khÃ´ng tÃ¬m tháº¥y '{target_path_key}'.")
                sys.exit(1)
        
        if "OUTPUT_FILE_PATH" not in config:
            print("[CONFIG] âŒ Lá»—i: Thiáº¿u OUTPUT_FILE_PATH.")
            sys.exit(1)

        if "PLACE_ID" not in config:
            print("[CONFIG] âŒ Lá»—i: Thiáº¿u PLACE_ID.")
            sys.exit(1)

        return config

    except requests.exceptions.RequestException as e:
        print(f"\n[CONFIG] âŒ Lá»–I Máº NG: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"\n[CONFIG] âŒ Lá»–I Xá»¬ LÃ: {e}")
        sys.exit(1)

def format_proxies(proxy_list):
    """Chuyá»ƒn Ä‘á»•i danh sÃ¡ch proxy string sang Ä‘á»‹nh dáº¡ng requests."""
    formatted = []
    if not proxy_list: return []
    for proxy_string in proxy_list:
        if not proxy_string: continue
        parts = proxy_string.split(':')
        proxy_url = ""
        if len(parts) == 2: proxy_url = f"http://{parts[0]}:{parts[1]}"
        elif len(parts) == 4: proxy_url = f"http://{parts[2]}:{parts[3]}@{parts[0]}:{parts[1]}"
        if proxy_url: formatted.append({"http": proxy_url, "https": proxy_url})
    return formatted

def countdown(seconds, thread_name="MAIN"):
    for i in range(seconds, 0, -1):
        print(f"[{thread_name}] Thá»i gian chá» cÃ²n láº¡i: {i} giÃ¢y    ", end='\r')
        sys.stdout.flush()
        time.sleep(1)
    print(f"[{thread_name}] Báº¯t Ä‘áº§u chu ká»³ má»›i.                                  ")

# ==============================================================================
# -- CÃC HÃ€M Káº¾T Ná»I API --
# ==============================================================================

def execute_api_request_with_proxy(method, url, config, thread_name, json_data=None):
    """Thá»±c hiá»‡n request vá»›i logic xoay vÃ²ng (rotation) proxy cho Scanner."""
    global proxy_index, failed_proxy_count, current_proxies
    timeout = config.get("CONNECTION_TIMEOUT", 15)
    num_proxies = len(current_proxies)
    
    while True:
        if num_proxies > 0 and failed_proxy_count >= num_proxies:
            print(f"\n[{thread_name}] [!] Táº¥t cáº£ proxies lá»—i. Nghá»‰ 5 giÃ¢y...")
            time.sleep(5)
            failed_proxy_count = 0; proxy_index = 0
        
        proxy, proxy_status = (current_proxies[proxy_index], f"Proxy {proxy_index + 1}/{num_proxies}") if num_proxies > 0 else (None, "IP Gá»‘c")
        
        try:
            print(f"\r[{thread_name}] [*] Káº¿t ná»‘i API... | {proxy_status}", end="")
            sys.stdout.flush()
            if method.upper() == 'GET': response = requests.get(url, proxies=proxy, timeout=timeout)
            elif method.upper() == 'POST': response = requests.post(url, json=json_data, proxies=proxy, timeout=timeout)
            else: raise ValueError(f"Method láº¡: {method}")
            
            if response.status_code == 200:
                failed_proxy_count = 0
                return response.json()
            
            error_reason = "Rate Limit" if response.status_code == 429 else f"Code {response.status_code}"
            raise requests.exceptions.HTTPError(error_reason)
            
        except (requests.exceptions.RequestException, requests.exceptions.HTTPError, ValueError) as e:
            if num_proxies > 0:
                print(f"\n[{thread_name}] [!] Proxy {proxy_index + 1} lá»—i ({e}). Äá»•i proxy...")
                failed_proxy_count += 1
                proxy_index = (proxy_index + 1) % num_proxies
                time.sleep(1)
            else:
                print(f"\n[{thread_name}] [!] IP Gá»‘c lá»—i ({e}). Nghá»‰ 60 giÃ¢y...")
                time.sleep(60)

def execute_api_request_simple(method, url, config, thread_name, json_data=None, proxy=None):
    """Thá»±c hiá»‡n request Ä‘Æ¡n giáº£n, dÃ¹ng proxy chá»‰ Ä‘á»‹nh (KHÃ”NG cÃ³ rotation)."""
    timeout = config.get("CONNECTION_TIMEOUT", 15)
    proxies = proxy if proxy else None
    
    try:
        if method.upper() == 'GET': response = requests.get(url, proxies=proxies, timeout=timeout)
        elif method.upper() == 'POST': response = requests.post(url, json=json_data, proxies=proxies, timeout=timeout)
        else: raise ValueError(f"Method láº¡: {method}")
        
        if response.status_code == 200: return response.json()
        
    except Exception:
        # Bá» qua lá»—i káº¿t ná»‘i proxy/máº¡ng vÃ  tráº£ vá» None
        pass 
        
    return None

def check_roblox_presence_single(account_id, config, thread_name, proxy_list, initial_proxy_index, check_info="Check"):
    """
    Kiá»ƒm tra tráº¡ng thÃ¡i online cá»§a Má»˜T tÃ i khoáº£n.
    CHáº¾ Äá»˜ STRICT: 
    - Náº¿u Online -> Tráº£ vá» True ngay.
    - Náº¿u Offline -> KHÃ”NG tin ngay, tiáº¿p tá»¥c thá»­ cÃ¡c proxy khÃ¡c cho Ä‘áº¿n háº¿t max_retries.
    """
    user_ids = [int(account_id)]
    api_url = "https://presence.roblox.com/v1/presence/users"
    payload = {"userIds": user_ids}
    
    formatted_proxies = proxy_list
    num_proxies = len(formatted_proxies)
    
    max_retries = 3
    
    for attempt in range(max_retries):
        
        # --- CHá»ŒN PROXY CHO Láº¦N THá»¬ NÃ€Y ---
        idx = -1
        proxy = None
        
        if num_proxies > 0:
            if attempt == 0:
                # Láº§n Ä‘áº§u tiÃªn, dÃ¹ng proxy Ä‘Æ°á»£c chá»‰ Ä‘á»‹nh tá»« bÃªn ngoÃ i
                idx = initial_proxy_index
            else:
                # CÃ¡c láº§n sau, chá»n ngáº«u nhiÃªn
                idx = random.randint(0, num_proxies - 1)
            
            proxy = formatted_proxies[idx]
        
        proxy_info = f"{check_info} (P#{idx + 1})" if idx != -1 else f"{check_info} (IP Gá»‘c)"
        
        # In tráº¡ng thÃ¡i Ä‘ang thá»­
        print(f"[{thread_name}] [{account_id}] Äang thá»­ {proxy_info} (Láº§n {attempt + 1}/{max_retries})...", end='\r')
        sys.stdout.flush()

        # Thá»±c hiá»‡n request Ä‘Æ¡n giáº£n
        response = execute_api_request_simple('POST', api_url, config, thread_name, json_data=payload, proxy=proxy)

        if response is not None:
            # ThÃ nh cÃ´ng káº¿t ná»‘i vÃ  nháº­n Ä‘Æ°á»£c response
            is_online = False
            if 'userPresences' in response:
                for p in response['userPresences']:
                    if p.get('userPresenceType') == 2 and str(p.get('userId')) == str(account_id):
                        is_online = True
            
            if is_online:
                # Náº¿u tháº¥y Online -> Tuyá»‡t vá»i, chá»‘t luÃ´n!
                print(f"[{thread_name}] [{account_id}] {proxy_info}: ONLINE (ÄÃ£ xÃ¡c nháº­n)")
                return True
            else:
                # Náº¿u tháº¥y Offline -> ChÆ°a tin ngay!
                # In ra Ä‘á»ƒ user biáº¿t lÃ  Ä‘Ã£ check tháº¥y offline nhÆ°ng Ä‘ang nghi ngá»
                if attempt < max_retries - 1:
                    print(f"[{thread_name}] [{account_id}] {proxy_info}: OFFLINE (Nghi ngá», thá»­ láº¡i proxy khÃ¡c)...")
                    # KhÃ´ng return False á»Ÿ Ä‘Ã¢y, Ä‘á»ƒ vÃ²ng láº·p cháº¡y tiáº¿p
                else:
                    # ÄÃ¢y lÃ  láº§n cuá»‘i cÃ¹ng rá»“i mÃ  váº«n Offline
                    print(f"[{thread_name}] [{account_id}] {proxy_info}: OFFLINE (Chá»‘t sau {max_retries} láº§n thá»­)")
                    return False
        
        # Náº¿u response lÃ  None (Lá»—i máº¡ng) hoáº·c Offline (á»Ÿ cÃ¡c láº§n thá»­ Ä‘áº§u) -> Chá» xÃ­u rá»“i thá»­ láº¡i
        time.sleep(1.5) 

    # Tháº¥t báº¡i sau max_retries
    print(f"[{thread_name}] [{account_id}] KhÃ´ng thá»ƒ xÃ¡c Ä‘á»‹nh (Lá»—i káº¿t ná»‘i) sau {max_retries} láº§n.")
    return False


# ==============================================================================
# -- LOGIC Má»šI: DELTA KEY MANAGER --
# ==============================================================================

def delta_key_monitor_loop():
    """
    Luá»“ng kiá»ƒm tra vÃ  cáº­p nháº­t Key Delta.
    Chá»‰ cháº¡y náº¿u Executor = 1.
    """
    thread_name = "DELTA-KEY"
    print(f"[{thread_name}] Äang khá»Ÿi Ä‘á»™ng trÃ¬nh quáº£n lÃ½ Key cho Delta...")
    
    # ÄÆ°á»ng dáº«n file license cá»§a Delta (Cá»‘ Ä‘á»‹nh)
    LOCAL_KEY_PATH = "/storage/emulated/0/Delta/Internals/Cache/license"

    while True:
        # Táº£i config má»›i nháº¥t Ä‘á»ƒ láº¥y URL vÃ  Interval
        config = fetch_and_load_config(CONFIG_URL)
        
        # Kiá»ƒm tra xem cÃ³ pháº£i Ä‘ang dÃ¹ng Delta khÃ´ng (SELECTED_EXECUTOR="1")
        if str(config.get("SELECTED_EXECUTOR")) != "1":
            print(f"[{thread_name}] KhÃ´ng pháº£i cháº¿ Ä‘á»™ Delta. Luá»“ng sáº½ ngá»§ Ä‘Ã´ng dÃ i háº¡n.")
            time.sleep(3600)
            continue

        key_url = config.get("DELTA_KEY_URL")
        interval = config.get("KEY_CHECK_INTERVAL_MINUTES", 30)

        if not key_url:
            print(f"[{thread_name}] âš ï¸ Cáº£nh bÃ¡o: ChÆ°a cáº¥u hÃ¬nh DELTA_KEY_URL trong config online.")
        else:
            try:
                # 1. Láº¥y Key tá»« Github
                print(f"[{thread_name}] Äang kiá»ƒm tra Key má»›i tá»« GitHub...")
                response = requests.get(key_url, timeout=15)
                if response.status_code == 200:
                    remote_key = response.text.strip()
                    
                    # 2. Äá»c Key hiá»‡n táº¡i trong mÃ¡y
                    local_key = ""
                    if os.path.exists(LOCAL_KEY_PATH):
                        try:
                            with open(LOCAL_KEY_PATH, "r") as f:
                                local_key = f.read().strip()
                        except: pass
                    
                    # 3. So sÃ¡nh
                    if remote_key == local_key:
                        print(f"[{thread_name}] âœ… Key trÃ¹ng khá»›p. KhÃ´ng cáº§n cáº­p nháº­t.")
                    else:
                        print(f"[{thread_name}] âš ï¸ PHÃT HIá»†N KEY Má»šI! Tiáº¿n hÃ nh cáº­p nháº­t...")
                        
                        # Äáº£m báº£o thÆ° má»¥c tá»“n táº¡i
                        os.makedirs(os.path.dirname(LOCAL_KEY_PATH), exist_ok=True)
                        
                        # Ghi Ä‘Ã¨ file
                        with open(LOCAL_KEY_PATH, "w") as f:
                            f.write(remote_key)
                        
                        print(f"[{thread_name}] âœ… ÄÃ£ ghi key má»›i thÃ nh cÃ´ng.")
                        print(f"[{thread_name}] ğŸ›‘ REBOOT Há»† THá»NG TRONG 5 GIÃ‚Y Äá»‚ ÃP Dá»¤NG...")
                        time.sleep(5)
                        subprocess.run(["su", "-c", "reboot"])
                else:
                    print(f"[{thread_name}] Lá»—i táº£i Key: HTTP {response.status_code}")
            except Exception as e:
                print(f"[{thread_name}] Lá»—i quÃ¡ trÃ¬nh check Key: {e}")

        # Chá» Ä‘áº¿n láº§n check tiáº¿p theo
        time.sleep(interval * 60)

# ==============================================================================
# -- LOGIC CHÃNH: SCAN & LAUNCH --
# ==============================================================================

def run_scanner(config, thread_name="SCAN"):
    global current_proxies
    print(f"[{thread_name}] Äang quÃ©t server...")
    
    current_proxies = format_proxies(config.get("PROXY_LIST", []))
    min_ratio = config.get("MIN_PLAYER_PERCENTAGE", 0) / 100.0
    max_ratio = config.get("MAX_PLAYER_PERCENTAGE", 100) / 100.0
    place_id = config["PLACE_ID"]
    
    collected_ids, next_cursor = [], ""
    while True:
        api_url = f"https://games.roblox.com/v1/games/{place_id}/servers/Public?sortOrder=Desc&limit=100"
        if next_cursor and next_cursor != "null": api_url += f"&cursor={next_cursor}"
        
        # DÃ¹ng hÃ m rotation cho scanner
        data = execute_api_request_with_proxy('GET', api_url, config, thread_name) 
        if not data: continue
        
        servers = data.get("data", [])
        next_cursor = data.get("nextPageCursor")
        
        if not servers:
            print(f"\n[{thread_name}] [i] Háº¿t danh sÃ¡ch server.")
            break
            
        total_ratio = sum((s.get("playing", 0) / s.get("maxPlayers", 1)) for s in servers if s.get("maxPlayers", 0) > 0)
        
        for s in servers:
            if s.get("maxPlayers", 0) > 0:
                ratio = s.get("playing", 0) / s.get("maxPlayers")
                if min_ratio <= ratio <= max_ratio:
                    sid = s.get("id")
                    if sid and sid not in collected_ids: collected_ids.append(sid)
        
        avg_ratio = (total_ratio / len(servers)) if servers else 0
        print(f"\r[{thread_name}] QuÃ©t... | Tá»‰ lá»‡ trang: {avg_ratio * 100:5.1f}% | ÄÃ£ tÃ¬m: {len(collected_ids):<5}", end="")
        
        if 0 < avg_ratio < min_ratio or not next_cursor or next_cursor == "null":
            print(f"\n[{thread_name}] [i] Äáº¡t giá»›i háº¡n dÆ°á»›i hoáº·c háº¿t trang.")
            break
            
    output_path = config["OUTPUT_FILE_PATH"]
    
    output_dir = os.path.dirname(output_path)
    if output_dir and not os.path.exists(output_dir):
        try: os.makedirs(output_dir)
        except: pass

    with file_lock:
        try:
            with open(output_path, "w") as f:
                for sid in collected_ids: f.write(f"{sid}\n")
            print(f"[{thread_name}] âœ… ÄÃ£ lÆ°u {len(collected_ids)} ID vÃ o: {output_path}")
        except Exception as e:
            print(f"\n[{thread_name}] âŒ Lá»—i ghi file: {e}")
            
    return True

def launch_roblox_instances(config, launch_mode, thread_name="LAUNCH"):
    accounts = config.get("ACCOUNT_SUFFIXES", [])
    if not accounts:
        print(f"[{thread_name}] Lá»—i: ChÆ°a cáº¥u hÃ¬nh tÃ i khoáº£n.")
        return
    
    server_ids = []
    if launch_mode == 'scan':
        with file_lock:
            try:
                with open(config['OUTPUT_FILE_PATH'], 'r') as f:
                    server_ids = [line.strip() for line in f if line.strip()]
            except: pass
        if not server_ids:
            print(f"[{thread_name}] ChÆ°a cÃ³ server Ä‘á»ƒ join. Chá» quÃ©t...")
            return

    base_pkg = config.get("BASE_PACKAGE_NAME", "com.roblox.clien")
    
    # Láº¥y danh sÃ¡ch proxies Ä‘Ã£ format
    formatted_proxies = format_proxies(config.get("PROXY_LIST", []))
    num_proxies = len(formatted_proxies)
    
    for i, acc in enumerate(accounts):
        suffix, uid = acc['suffix'], acc['id']
        pkg_name = f"{base_pkg}{suffix}"
        
        print(f"\n[{thread_name}] ---- Báº®T Äáº¦U CHECK: {suffix} (ID: {uid}) ----")
        
        # --- CHá»ŒN PROXY CHO Láº¦N 1 ---
        idx_1 = random.randint(0, num_proxies - 1) if num_proxies > 0 else -1
        
        # 1. Kiá»ƒm tra API láº§n 1 (STRICT MODE: Sáº½ thá»­ Ä‘á»§ 3 láº§n náº¿u tháº¥y Offline)
        is_online_l1 = check_roblox_presence_single(
            uid, config, thread_name, formatted_proxies, idx_1, check_info="Check L1"
        )
        
        is_online_final = is_online_l1 # Giáº£ Ä‘á»‹nh ban Ä‘áº§u lÃ  káº¿t quáº£ L1

        # 2. Logic Double Check (Chá»‰ cháº¡y khi káº¿t quáº£ L1 váº«n lÃ  OFFLINE sau 3 láº§n thá»­)
        # VÃ¬ Check L1 Ä‘Ã£ ráº¥t cháº·t cháº½ (retry 3 láº§n), nÃªn náº¿u nÃ³ bÃ¡o Offline nghÄ©a lÃ  khÃ¡ cháº¯c cháº¯n rá»“i.
        # Tuy nhiÃªn, Ä‘á»ƒ Ä‘áº£m báº£o "siÃªu cháº·t cháº½" nhÆ° logic cÅ©, ta váº«n giá»¯ Double Check L2.
        
        if not is_online_l1:
            print(f"[{thread_name}] âš ï¸ [{suffix}] Váº«n bÃ¡o Offline (Sau 3 láº§n check L1). Chá» 10s check L2...")
            time.sleep(3)

            # --- CHá»ŒN PROXY CHO Láº¦N 2 (KhÃ¡c Láº§n 1 náº¿u cÃ³ thá»ƒ) ---
            idx_2 = -1
            if num_proxies > 0:
                if num_proxies > 1:
                    available_indices = [j for j in range(num_proxies) if j != idx_1]
                    idx_2 = random.choice(available_indices)
                else:
                    idx_2 = idx_1
            
            # 3. Kiá»ƒm tra API láº§n 2 (CÅ©ng STRICT MODE: Thá»­ tiáº¿p 3 láº§n ná»¯a)
            is_online_l2 = check_roblox_presence_single(
                uid, config, thread_name, formatted_proxies, idx_2, check_info="Check L2"
            )
            
            is_online_final = is_online_l2 # Káº¿t quáº£ L2 lÃ  káº¿t quáº£ cuá»‘i cÃ¹ng

        # ======================================================================
        # 4. QUYáº¾T Äá»ŠNH & THá»°C THI
        # ======================================================================
        
        if is_online_final:
            print(f"[{thread_name}] [QUYáº¾T Äá»ŠNH] '{suffix}' ÄANG ONLINE. -> Bá» qua (Skip), KHÃ”NG lÃ m má»›i.")
            # Sá»­ dá»¥ng continue Ä‘á»ƒ nháº£y sang tÃ i khoáº£n káº¿ tiáº¿p ngay láº­p tá»©c
            continue 

        # Náº¿u code cháº¡y xuá»‘ng Ä‘Ã¢y, nghÄ©a lÃ  is_online_final == False (OFFLINE)
        print(f"[{thread_name}] [QUYáº¾T Äá»ŠNH] '{suffix}' CONFIRMED OFFLINE. Tiáº¿n hÃ nh Kill & Start.")
        
        # Kill logic (Chá»‰ cháº¡y khi Offline)
        try:
            cmd_kill = f"PID=$(ps -ef | grep {pkg_name} | grep -v grep | awk '{{print $2}}'); if [ ! -z \"$PID\" ]; then kill -9 $PID; fi"
            subprocess.run(["su", "-c", cmd_kill], capture_output=True, timeout=10)
            time.sleep(3) # Chá» process cháº¿t háº³n
        except: pass

        # 5. Táº¡o lá»‡nh Start (Chá»‰ cháº¡y khi Offline)
        target_url = ""
        if launch_mode == 'scan':
            if server_ids:
                target_url = f"roblox://placeId={config['PLACE_ID']}&gameId={server_ids[i % len(server_ids)]}"
            else:
                print(f"[{thread_name}] [-] KhÃ´ng cÃ³ server há»£p lá»‡ Ä‘á»ƒ join cho '{suffix}'. Bá» qua start.")
                continue
        elif launch_mode == 'vip':
            target_url = config.get('VIP_SERVER_URL', "")
            
        if target_url:
            subprocess.run(["am", "start", "-a", "android.intent.action.VIEW", "-d", target_url, "-p", pkg_name], capture_output=True)
            print(f"[{thread_name}] -> ÄÃ£ gá»i lá»‡nh start cho {pkg_name}")
            
        # Nghá»‰ giá»¯a cÃ¡c láº§n khá»Ÿi Ä‘á»™ng acc
        delay = config.get("LAUNCH_DELAY_SECONDS", 10)
        if i < len(accounts) - 1:
            print(f"[{thread_name}] Äá»£i {delay}s trÆ°á»›c khi qua acc tiáº¿p theo...")
            time.sleep(delay)

# ==============================================================================
# -- VÃ’NG Láº¶P & MAIN --
# ==============================================================================

def scanner_loop():
    print("[SCAN] Báº¯t Ä‘áº§u...")
    config = fetch_and_load_config(CONFIG_URL)
    while True:
        run_scanner(config, "SCAN")
        countdown(config.get("SCAN_INTERVAL_SECONDS", 300), "SCAN")

def launcher_loop(mode):
    print(f"[LAUNCH] Báº¯t Ä‘áº§u cháº¿ Ä‘á»™ {mode}...")
    config = fetch_and_load_config(CONFIG_URL)
    while True:
        launch_roblox_instances(config, mode, "LAUNCH")
        countdown(config.get("LAUNCH_INTERVAL_SECONDS", 300), "LAUNCH")

def reboot_loop():
    print("[REBOOT] Kiá»ƒm tra lá»‹ch...")
    config = fetch_and_load_config(CONFIG_URL)
    if config.get("REBOOT_ENABLED", "off").lower() == "on":
        mins = config.get("REBOOT_INTERVAL_MINUTES", 1200)
        print(f"[REBOOT] Háº¹n giá»: {mins} phÃºt.")
        time.sleep(mins * 60)
        print("[REBOOT] Äang khá»Ÿi Ä‘á»™ng láº¡i...")
        try: subprocess.run(["su", "-c", "reboot"])
        except: pass

if __name__ == "__main__":
    os.system("termux-wake-lock")
    if not check_root_access(): sys.exit(1)
    
    threading.Thread(target=reboot_loop, daemon=True).start()
    threading.Thread(target=delta_key_monitor_loop, daemon=True).start()

    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(dest='command')
    subparsers.add_parser('parallel')
    subparsers.add_parser('scan')
    lp = subparsers.add_parser('launch')
    lp.add_argument('--mode', choices=['scan', 'vip'], default='scan')
    
    args = parser.parse_args()
    cmd = args.command if args.command else 'parallel'

    try:
        if cmd == 'scan': scanner_loop()
        elif cmd == 'launch': launcher_loop(args.mode)
        elif cmd == 'parallel':
            threading.Thread(target=scanner_loop, daemon=True).start()
            time.sleep(3)
            threading.Thread(target=launcher_loop, args=('vip',), daemon=True).start()
            while True: time.sleep(1)
    except KeyboardInterrupt:
        print("\n[MAIN] Dá»«ng.")
