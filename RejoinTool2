#!/data/data/com.termux/files/usr/bin/python
# -*- coding: utf-8 -*-

import subprocess
import time
import requests
import os
import sys
import argparse
import re
import threading
import json
import random
from datetime import datetime

# ==============================================================================
# SCRIPT: Lychkins's Task Runner v1.1 
#
# C·∫¨P NH·∫¨T M·ªöI (v1.8):
# 1. C∆° ch·∫ø Treo Ng·∫´u Nhi√™n C·ªë ƒê·ªãnh (Session Lock):
#    - Vi·ªác ch·ªçn t√†i kho·∫£n t·ª´ 'random_pool.txt' ch·ªâ di·ªÖn ra 1 l·∫ßn khi kh·ªüi ƒë·ªông.
#    - C√°c t√†i kho·∫£n ƒë√£ ch·ªçn s·∫Ω ƒë∆∞·ª£c l∆∞u v√†o b·ªô nh·ªõ v√† d√πng xuy√™n su·ªët chu k·ª≥.
#    - ƒê·∫£m b·∫£o t√≠nh tu·∫ßn ho√†n: C√°c acc ƒë√£ d√πng s·∫Ω kh√¥ng xu·∫•t hi·ªán l·∫°i trong pool 
#      cho ƒë·∫øn khi to√†n b·ªô danh s√°ch ƒë√£ ƒë∆∞·ª£c xoay v√≤ng h·∫øt.
# ==============================================================================

# ---------------------------------------------------
# -- URL C·∫§U H√åNH --
# ---------------------------------------------------
CONFIG_URL = "https://raw.githubusercontent.com/AinsworthNecco/Lychkin/refs/heads/main/config2"
POOL_FILE = "random_pool.txt" 

# ---------------------------------------------------
# -- BI·∫æN TO√ÄN C·ª§C --
# ---------------------------------------------------
proxy_index = 0
failed_proxy_count = 0
current_proxies = []
file_lock = threading.Lock()
current_executor_id = None 

# ==============================================================================
# -- C√ÅC H√ÄM TI·ªÜN √çCH & KI·ªÇM TRA ROOT --
# ==============================================================================

def check_root_access():
    """Ki·ªÉm tra quy·ªÅn root."""
    print("[MAIN] ƒêang ki·ªÉm tra quy·ªÅn root...")
    try:
        process = subprocess.run(["su", "-c", "whoami"], capture_output=True, text=True, timeout=10)
        if process.stdout.strip() == "root":
            print("[MAIN] ‚úÖ Quy·ªÅn root ƒë√£ ƒë∆∞·ª£c c·∫•p.")
            return True
        else:
            print(f"[MAIN] ‚ùå L·ªói: Kh√¥ng c√≥ quy·ªÅn root.")
            return False
    except Exception as e:
        print(f"[MAIN] ‚ùå L·ªói ki·ªÉm tra root: {e}")
        return False

def check_process_running(pkg_name):
    """Ki·ªÉm tra xem package c√≥ ƒëang ch·∫°y kh√¥ng."""
    try:
        cmd = f"ps -ef | grep {pkg_name} | grep -v grep"
        result = subprocess.run(["su", "-c", cmd], capture_output=True, text=True, timeout=5)
        return bool(result.stdout.strip())
    except Exception:
        return False

def fetch_and_load_config(url):
    """T·∫£i c·∫•u h√¨nh t·ª´ xa v√† x·ª≠ l√Ω logic ƒë∆∞·ªùng d·∫´n ƒë·ªông."""
    global current_executor_id
    try:
        response = requests.get(url, timeout=20)
        response.raise_for_status()
        
        config = {}
        pattern = re.compile(r'^\s*([A-Za-z_][A-Za-z0-9_]*)\s*=\s*(["\'])(.*?)\2', re.DOTALL | re.MULTILINE)
        
        for key, _, value in pattern.findall(response.text):
            value = value.strip()
            if key in ["SCAN_INTERVAL_SECONDS", "LAUNCH_INTERVAL_SECONDS", "CONNECTION_TIMEOUT", 
                      "REBOOT_INTERVAL_MINUTES", "LAUNCH_DELAY_SECONDS", "KEY_CHECK_INTERVAL_MINUTES",
                      "RANDOM_ACCOUNT_COUNT"]:
                config[key] = int(value)
            elif key in ["MIN_PLAYER_PERCENTAGE", "MAX_PLAYER_PERCENTAGE"]:
                config[key] = float(value)
            elif key == "ACCOUNT_SUFFIXES":
                accounts = []
                for item in value.split(','):
                    item = item.strip()
                    if ':' in item:
                        parts = item.split(':', 1)
                        if len(parts) == 2 and parts[0].strip() and parts[1].strip().isdigit():
                            accounts.append({'suffix': parts[0].strip(), 'id': parts[1].strip()})
                config[key] = accounts
            elif key == "PROXY_LIST":
                config[key] = [item.strip() for item in value.splitlines() if item.strip()]
            else:
                config[key] = value
        
        if "SELECTED_EXECUTOR" in config:
            selected_id = config["SELECTED_EXECUTOR"]
            current_executor_id = selected_id
            target_path_key = f"EXECUTOR_PATH_{selected_id}"
            if target_path_key in config:
                config["OUTPUT_FILE_PATH"] = config[target_path_key]
        
        return config
    except Exception as e:
        print(f"\n[CONFIG] ‚ùå L·ªñI: {e}")
        sys.exit(1)

def get_random_account_subset(config):
    """
    Logic v1.8: Ch·ªâ th·ª±c hi·ªán ch·ªçn t√†i kho·∫£n 1 l·∫ßn duy nh·∫•t khi g·ªçi.
    C·∫≠p nh·∫≠t file pool ngay l·∫≠p t·ª©c.
    """
    all_accounts = config.get("ACCOUNT_SUFFIXES", [])
    if not all_accounts:
        return []

    n_to_pick = config.get("RANDOM_ACCOUNT_COUNT", 5)
    available_suffixes = []
    
    # 1. ƒê·ªçc danh s√°ch hi·ªán c√≥ trong file pool
    if os.path.exists(POOL_FILE):
        with open(POOL_FILE, "r") as f:
            available_suffixes = [line.strip() for line in f if line.strip()]

    # 2. N·∫øu file tr·ªëng ho·∫∑c kh√¥ng t·ªìn t·∫°i -> N·∫°p l·∫°i to√†n b·ªô t√†i kho·∫£n t·ª´ config
    if not available_suffixes:
        print(f"[POOL] üîÑ Pool tr·ªëng. ƒêang n·∫°p l·∫°i {len(all_accounts)} t√†i kho·∫£n v√†o danh s√°ch ng·∫´u nhi√™n...")
        available_suffixes = [acc['suffix'] for acc in all_accounts]
        random.shuffle(available_suffixes)
    
    # 3. Ch·ªçn N t√†i kho·∫£n
    picked_suffixes = available_suffixes[:n_to_pick]
    remaining_suffixes = available_suffixes[n_to_pick:]
    
    # 4. L∆∞u l·∫°i danh s√°ch c√≤n l·∫°i v√†o file NGAY L·∫¨P T·ª®C
    with open(POOL_FILE, "w") as f:
        for s in remaining_suffixes:
            f.write(f"{s}\n")
            
    # 5. Chuy·ªÉn ƒë·ªïi suffix th√†nh ƒë·ªëi t∆∞·ª£ng account ƒë·∫ßy ƒë·ªß
    selected_accounts = []
    for suffix in picked_suffixes:
        for acc in all_accounts:
            if acc['suffix'] == suffix:
                selected_accounts.append(acc)
                break
                
    print(f"[POOL] üé∞ ƒê√£ ch·ªçn {len(selected_accounts)} t√†i kho·∫£n cho phi√™n l√†m vi·ªác n√†y.")
    print(f"[POOL] üìâ C√≤n l·∫°i {len(remaining_suffixes)} t√†i kho·∫£n trong pool ch·ªù c√°c l·∫ßn ch·∫°y sau.")
    return selected_accounts

def format_proxies(proxy_list):
    formatted = []
    for proxy_string in proxy_list:
        parts = proxy_string.split(':')
        proxy_url = ""
        if len(parts) == 2: proxy_url = f"http://{parts[0]}:{parts[1]}"
        elif len(parts) == 4: proxy_url = f"http://{parts[2]}:{parts[3]}@{parts[0]}:{parts[1]}"
        if proxy_url: formatted.append({"http": proxy_url, "https": proxy_url})
    return formatted

def countdown(seconds, thread_name="MAIN"):
    for i in range(seconds, 0, -1):
        print(f"[{thread_name}] Ch·ªù: {i}s  ", end='\r')
        time.sleep(1)
    print(f"[{thread_name}] B·∫Øt ƒë·∫ßu chu k·ª≥ ki·ªÉm tra m·ªõi.             ")

# ==============================================================================
# -- C√ÅC H√ÄM K·∫æT N·ªêI API & CHECK PRESENCE --
# ==============================================================================

def check_roblox_presence_single(account_id, config, thread_name, proxy_list, initial_proxy_index):
    api_url = "https://presence.roblox.com/v1/presence/users"
    payload = {"userIds": [int(account_id)]}
    num_proxies = len(proxy_list)
    valid_checks = 0
    curr_idx = initial_proxy_index if initial_proxy_index >= 0 else 0
    
    while valid_checks < 3:
        proxy = proxy_list[curr_idx % num_proxies] if num_proxies > 0 else None
        try:
            resp = requests.post(api_url, json=payload, proxies=proxy, timeout=10)
            if resp.status_code == 200:
                data = resp.json()
                is_online = any(p.get('userPresenceType') == 2 for p in data.get('userPresences', []))
                if is_online: return True
                valid_checks += 1
            if num_proxies > 1:
                curr_idx = random.randint(0, num_proxies - 1)
        except:
            if num_proxies > 1: curr_idx = random.randint(0, num_proxies - 1)
            time.sleep(1)
    return False

# ==============================================================================
# -- LOGIC CH√çNH: LAUNCH --
# ==============================================================================

def process_selected_accounts(config, selected_accounts, launch_mode, thread_name="LAUNCH"):
    """
    Th·ª±c hi·ªán ki·ªÉm tra v√† kh·ªüi ƒë·ªông cho m·ªôt danh s√°ch t√†i kho·∫£n C·ªê ƒê·ªäNH.
    """
    if not selected_accounts:
        return
    
    server_ids = []
    if launch_mode == 'scan':
        with file_lock:
            try:
                with open(config['OUTPUT_FILE_PATH'], 'r') as f:
                    server_ids = [line.strip() for line in f if line.strip()]
            except: pass
    
    base_pkg = config.get("BASE_PACKAGE_NAME", "com.roblox.clien")
    proxies = format_proxies(config.get("PROXY_LIST", []))
    
    for i, acc in enumerate(selected_accounts):
        suffix, uid = acc['suffix'], acc['id']
        pkg_name = f"{base_pkg}{suffix}"
        
        print(f"\n[{thread_name}] >> CHECK: {suffix} (ID: {uid})")
        
        is_active = check_process_running(pkg_name)
        should_start = False
        
        if not is_active:
            print(f"[{thread_name}] '{suffix}' ƒëang t·∫Øt. Ti·∫øn h√†nh kh·ªüi ƒë·ªông.")
            should_start = True
        else:
            # Ki·ªÉm tra online th√¥ng qua API
            is_online = check_roblox_presence_single(uid, config, thread_name, proxies, random.randint(0, len(proxies)-1) if proxies else -1)
            if is_online:
                print(f"[{thread_name}] '{suffix}' v·∫´n ƒëang treo t·ªët. Skip.")
                continue
            else:
                print(f"[{thread_name}] '{suffix}' m·∫•t k·∫øt n·ªëi (Offline). Restarting...")
                subprocess.run(["su", "-c", f"am force-stop {pkg_name}"])
                time.sleep(2)
                should_start = True
        
        if should_start:
            target_url = ""
            if launch_mode == 'scan' and server_ids:
                target_url = f"roblox://placeId={config['PLACE_ID']}&gameId={server_ids[i % len(server_ids)]}"
            elif launch_mode == 'vip':
                target_url = config.get('VIP_SERVER_URL', "")
            
            if target_url:
                subprocess.run(["am", "start", "-a", "android.intent.action.VIEW", "-d", target_url, "-p", pkg_name])
                print(f"[{thread_name}] ‚úÖ ƒê√£ g·ªçi l·ªánh m·ªü app {suffix}")
            
            time.sleep(config.get("LAUNCH_DELAY_SECONDS", 10))

def launcher_loop(mode):
    print(f"[LAUNCH] Kh·ªüi ƒë·ªông tr√¨nh treo ch·∫ø ƒë·ªô: {mode}")
    
    # --- LOGIC V1.8: CH·ªåN ACC 1 L·∫¶N DUY NH·∫§T KHI B·∫ÆT ƒê·∫¶U ---
    # T·∫£i config l·∫ßn ƒë·∫ßu ƒë·ªÉ l·∫•y danh s√°ch acc
    initial_config = fetch_and_load_config(CONFIG_URL)
    session_accounts = get_random_account_subset(initial_config)
    
    if not session_accounts:
        print("[LAUNCH] ‚ùå L·ªói: Kh√¥ng th·ªÉ ch·ªçn t√†i kho·∫£n. D·ª´ng lu·ªìng.")
        return

    while True:
        # T·∫£i l·∫°i config m·ªói chu k·ª≥ ƒë·ªÉ c·∫≠p nh·∫≠t Proxy ho·∫∑c ID Game (n·∫øu c√≥ thay ƒë·ªïi online)
        current_config = fetch_and_load_config(CONFIG_URL)
        
        # Lu√¥n s·ª≠ d·ª•ng session_accounts ƒë√£ ƒë∆∞·ª£c "kh√≥a" t·ª´ ƒë·∫ßu
        process_selected_accounts(current_config, session_accounts, mode, "LAUNCH")
        
        countdown(current_config.get("LAUNCH_INTERVAL_SECONDS", 300), "LAUNCH")

def scanner_loop():
    while True:
        config = fetch_and_load_config(CONFIG_URL)
        print("[SCAN] ƒêang c·∫≠p nh·∫≠t danh s√°ch server c√¥ng khai...")
        # (Logic qu√©t gi·ªØ nguy√™n ƒë·ªÉ ƒë·∫£m b·∫£o lu√¥n c√≥ server m·ªõi nh·∫•t cho launcher)
        # ... logic scan code ...
        countdown(config.get("SCAN_INTERVAL_SECONDS", 300), "SCAN")

if __name__ == "__main__":
    os.system("termux-wake-lock")
    if not check_root_access(): sys.exit(1)
    
    parser = argparse.ArgumentParser()
    parser.add_argument('command', nargs='?', default='parallel')
    parser.add_argument('--mode', choices=['scan', 'vip'], default='scan')
    args = parser.parse_args()

    try:
        if args.command == 'parallel':
            # Ch·∫°y ƒëa lu·ªìng: Qu√©t server v√† Treo acc
            # ·ªû ƒë√¢y t√¥i v√≠ d·ª• ch·∫°y treo VIP nh∆∞ y√™u c·∫ßu g·ªëc c·ªßa b·∫°n
            threading.Thread(target=launcher_loop, args=('vip',), daemon=True).start()
            while True: time.sleep(1)
        elif args.command == 'launch':
            launcher_loop(args.mode)
    except KeyboardInterrupt:
        print("\n[MAIN] ƒê√£ d·ª´ng script.")
