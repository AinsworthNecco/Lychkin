#!/data/data/com.termux/files/usr/bin/python
# -*- coding: utf-8 -*-

import subprocess
import time
import requests
import os
import sys
import argparse
import re
import threading
import json
import random
import sqlite3
import shutil
import urllib.request
from datetime import datetime

# ==============================================================================
# SCRIPT: Lychkins's Task Runner v1.10 (Smart Path Injector)
#
# CẬP NHẬT MỚI (v1.10):
# - Tích hợp logic Injector mới: Tự động tìm đường dẫn file Cookie (Smart Detect).
# - Khắc phục lỗi "Không copy được file gốc" bằng cách quét đa vị trí.
# - Xử lý quyền (Permission) chuẩn xác hơn dựa trên thư mục cha.
# - Giữ logic tối ưu: Khớp -> Skip, Mới -> Lấy ID & Lưu Config.
# ==============================================================================

# ---------------------------------------------------
# -- URL CẤU HÌNH --
# ---------------------------------------------------
CONFIG_URL = "https://raw.githubusercontent.com/AinsworthNecco/Lychkin/refs/heads/main/BACKUPMAIN"
COOKIE_URL = "https://raw.githubusercontent.com/AinsworthNecco/Lychkin/refs/heads/main/cookie1"

# ---------------------------------------------------
# -- BIẾN TOÀN CỤC --
# ---------------------------------------------------
proxy_index = 0
failed_proxy_count = 0
current_proxies = []
file_lock = threading.Lock()
current_executor_id = None 

# Biến cho Injector
TEMP_DIR = os.path.join(os.getcwd(), "RobloxInjector_Temp") 
COOKIE_FILENAME = "Cookies"
LOCAL_CONFIG_FILE = "config.txt"

# ==============================================================================
# -- CÁC HÀM TIỆN ÍCH CƠ BẢN --
# ==============================================================================

def check_root_access():
    """Kiểm tra quyền root."""
    print("[MAIN] Đang kiểm tra quyền root...")
    try:
        process = subprocess.run(["su", "-c", "whoami"], capture_output=True, text=True, timeout=10)
        if process.stdout.strip() == "root":
            print("[MAIN] -> Quyền root: OK.")
            return True
        else:
            print(f"[MAIN] -> Lỗi: Không có quyền root (kết quả: {process.stdout.strip()}).")
            return False
    except Exception as e:
        print(f"[MAIN] -> Lỗi kiểm tra root: {e}")
        return False

def check_process_running(pkg_name):
    """Kiểm tra process đang chạy."""
    try:
        cmd = f"ps -ef | grep {pkg_name} | grep -v grep"
        result = subprocess.run(["su", "-c", cmd], capture_output=True, text=True, timeout=5)
        if result.stdout.strip():
            return True
        return False
    except Exception:
        return False

def load_local_ids_from_file():
    """Đọc file config.txt local để lấy map Suffix:ID."""
    local_map = {}
    if os.path.exists(LOCAL_CONFIG_FILE):
        try:
            with open(LOCAL_CONFIG_FILE, "r") as f:
                for line in f:
                    line = line.strip()
                    if ":" in line:
                        parts = line.split(":", 1)
                        suf = parts[0].strip()
                        uid = parts[1].strip()
                        if uid.isdigit():
                            local_map[suf] = uid
        except Exception as e:
            print(f"[CONFIG] Lỗi đọc file local: {e}")
    return local_map

def fetch_and_load_config(url):
    global current_executor_id
    try:
        response = requests.get(url, timeout=20)
        response.raise_for_status()
        
        config = {}
        pattern = re.compile(r'^\s*([A-Za-z_][A-Za-z0-9_]*)\s*=\s*(["\'])(.*?)\2', re.DOTALL | re.MULTILINE)
        
        for key, _, value in pattern.findall(response.text):
            value = value.strip()
            if key in ["SCAN_INTERVAL_SECONDS", "LAUNCH_INTERVAL_SECONDS", "CONNECTION_TIMEOUT", "REBOOT_INTERVAL_MINUTES", "LAUNCH_DELAY_SECONDS", "KEY_CHECK_INTERVAL_MINUTES"]:
                config[key] = int(value)
            elif key in ["MIN_PLAYER_PERCENTAGE", "MAX_PLAYER_PERCENTAGE"]:
                config[key] = float(value)
            elif key == "ACCOUNT_SUFFIXES":
                raw_suffixes = re.split(r'[,\s]+', value)
                accounts = []
                for s in raw_suffixes:
                    s = s.strip()
                    if s:
                        if ':' in s: s = s.split(':')[0]
                        accounts.append({'suffix': s, 'id': None})
                config[key] = accounts
            elif key == "PROXY_LIST":
                config[key] = [item.strip() for item in value.splitlines() if item.strip()]
            else:
                config[key] = value
        
        # Merge ID từ local config
        local_ids = load_local_ids_from_file()
        if "ACCOUNT_SUFFIXES" in config:
            for acc in config["ACCOUNT_SUFFIXES"]:
                suf = acc['suffix']
                if suf in local_ids:
                    acc['id'] = local_ids[suf]
                else:
                    acc['id'] = "0"
        
        if "SELECTED_EXECUTOR" in config:
            selected_id = config["SELECTED_EXECUTOR"]
            current_executor_id = selected_id
            target_path_key = f"EXECUTOR_PATH_{selected_id}"
            if target_path_key in config:
                config["OUTPUT_FILE_PATH"] = config[target_path_key]
            else:
                print(f"[CONFIG] Lỗi: Executor {selected_id} thiếu '{target_path_key}'.")
                sys.exit(1)
        
        if "OUTPUT_FILE_PATH" not in config:
            print("[CONFIG] Lỗi: Thiếu OUTPUT_FILE_PATH.")
            sys.exit(1)
        if "PLACE_ID" not in config:
            print("[CONFIG] Lỗi: Thiếu PLACE_ID.")
            sys.exit(1)

        return config

    except Exception as e:
        print(f"\n[CONFIG] Lỗi tải cấu hình: {e}")
        sys.exit(1)

def format_proxies(proxy_list):
    formatted = []
    if not proxy_list: return []
    for proxy_string in proxy_list:
        if not proxy_string: continue
        parts = proxy_string.split(':')
        proxy_url = ""
        if len(parts) == 2: proxy_url = f"http://{parts[0]}:{parts[1]}"
        elif len(parts) == 4: proxy_url = f"http://{parts[2]}:{parts[3]}@{parts[0]}:{parts[1]}"
        if proxy_url: formatted.append({"http": proxy_url, "https": proxy_url})
    return formatted

def countdown(seconds, thread_name="MAIN"):
    for i in range(seconds, 0, -1):
        print(f"[{thread_name}] Chờ: {i}s    ", end='\r')
        sys.stdout.flush()
        time.sleep(1)
    print(f"[{thread_name}] ...                       ")

# ==============================================================================
# -- CÁC HÀM INJECTOR LOGIC (SMART PATH DETECT) --
# ==============================================================================

def run_root_cmd_injector(command):
    try:
        full_cmd = f"su -c '{command}'"
        result = subprocess.run(full_cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        return result.stdout.strip(), result.stderr.strip(), result.returncode
    except Exception as e:
        print(f"[SYSTEM] Lỗi lệnh: {e}")
        return None, str(e), -1

def get_remote_cookies_list():
    """Tải danh sách Cookie từ GitHub."""
    print(f"[COOKIE] Đang tải danh sách Cookie từ GitHub...")
    try:
        req = urllib.request.Request(COOKIE_URL, headers={'User-Agent': 'Mozilla/5.0'})
        with urllib.request.urlopen(req) as response:
            if response.status != 200:
                print(f"[COOKIE] Lỗi HTTP: {response.status}")
                return []
            
            data = response.read().decode('utf-8').strip()
            lines = data.splitlines()
            valid_cookies = []
            for line in lines:
                line = line.strip()
                if "_|WARNING:-DO-NOT-SHARE" in line:
                    valid_cookies.append(line)
            
            print(f"[COOKIE] Tìm thấy {len(valid_cookies)} cookie hợp lệ.")
            return valid_cookies
    except Exception as e:
        print(f"[COOKIE] Lỗi tải Cookie: {e}")
        return []

def find_real_cookie_path(package_name):
    """[NEW] Tìm đường dẫn thực sự của file Cookies."""
    base_path = f"/data/data/{package_name}/app_webview"
    
    # Danh sách các vị trí có thể
    possible_paths = [
        f"{base_path}/Default/Cookies",
        f"{base_path}/Cookies"
    ]
    
    # print(f"[COOKIE] Đang quét path cho {package_name}...", end=" ")
    for path in possible_paths:
        check_cmd = f"[ -f '{path}' ] && echo 'YES' || echo 'NO'"
        out, _, _ = run_root_cmd_injector(check_cmd)
        if "YES" in out:
            # print(f"-> Found: {path}")
            return path
            
    # print("-> Not found.")
    return None

def get_local_cookie_injector(package_name):
    """Đọc cookie local dùng Smart Path."""
    target_path = find_real_cookie_path(package_name)
    if not target_path:
        return None

    temp_check_path = os.path.join(TEMP_DIR, "Cookies_Check")
    if not os.path.exists(TEMP_DIR): os.makedirs(TEMP_DIR)

    run_root_cmd_injector(f"cp {target_path} {temp_check_path}")
    run_root_cmd_injector(f"chmod 777 {temp_check_path}")

    local_cookie_value = None
    try:
        conn = sqlite3.connect(temp_check_path)
        cursor = conn.cursor()
        cursor.execute("SELECT value FROM cookies WHERE name = '.ROBLOSECURITY'")
        result = cursor.fetchone()
        if result: local_cookie_value = result[0]
        conn.close()
    except Exception: pass
    
    if os.path.exists(temp_check_path): os.remove(temp_check_path)
    return local_cookie_value

def prepare_db_injector(cookie_value):
    """Chuẩn bị file DB sqlite (Logic mới)."""
    db_path = os.path.join(TEMP_DIR, COOKIE_FILENAME)
    if not os.path.exists(db_path): 
        print(f"[COOKIE] File DB tạm không tồn tại.")
        return False

    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='cookies';")
        if not cursor.fetchone():
            conn.close()
            return False

        host_key = ".roblox.com"
        name = ".ROBLOSECURITY"
        
        cursor.execute("DELETE FROM cookies WHERE host_key = ? AND name = ?", (host_key, name))
        
        now = int(time.time() * 1000000)
        expires = 99999999999999999
        
        query_full = """
        INSERT INTO cookies (creation_utc, host_key, name, value, path, expires_utc, is_secure, is_httponly, last_access_utc, has_expires, is_persistent, priority, samesite, source_scheme)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """
        query_fallback = """
        INSERT INTO cookies (creation_utc, host_key, name, value, path, expires_utc, is_secure, is_httponly, last_access_utc)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """
        
        try:
            cursor.execute(query_full, (now, host_key, name, cookie_value, "/", expires, 1, 1, now, 1, 1, 1, 0, 1))
        except sqlite3.OperationalError:
            cursor.execute(query_fallback, (now, host_key, name, cookie_value, "/", expires, 1, 1, now))

        conn.commit()
        conn.close()
        return True
    except Exception as e:
        print(f"[COOKIE] Lỗi SQLite: {e}")
        return False

def inject_cookie_process(package_name, cookie_value):
    """Quy trình Inject Cookie (Smart Path)."""
    check_pkg, _, _ = run_root_cmd_injector(f"pm path {package_name}")
    if not check_pkg:
        print(f"[COOKIE] Gói {package_name} chưa cài đặt -> Bỏ qua.")
        return False

    # 1. Tìm đường dẫn file cookie
    target_path = find_real_cookie_path(package_name)
    if not target_path:
        print(f"[COOKIE] ⚠️ Không tìm thấy file Cookies của {package_name}.")
        print(f"[COOKIE] -> Hãy mở app lên ít nhất 1 lần để tạo file.")
        return False

    run_root_cmd_injector(f"am force-stop {package_name}")
    time.sleep(1)

    if os.path.exists(TEMP_DIR): shutil.rmtree(TEMP_DIR)
    os.makedirs(TEMP_DIR)

    # 2. Copy ra
    cmd_cp_out = f"cp {target_path} {TEMP_DIR}/{COOKIE_FILENAME}"
    _, err, code = run_root_cmd_injector(cmd_cp_out)
    if code != 0:
        print(f"[COOKIE] Lỗi copy file gốc: {err}")
        return False

    run_root_cmd_injector(f"chmod 777 {TEMP_DIR}/{COOKIE_FILENAME}")

    # 3. Sửa DB
    if not prepare_db_injector(cookie_value):
        print(f"[COOKIE] Lỗi xử lý DB.")
        return False

    # 4. Copy vào
    cmd_cp_in = f"cp {TEMP_DIR}/{COOKIE_FILENAME} {target_path}"
    run_root_cmd_injector(cmd_cp_in)

    # 5. Fix quyền (Dựa trên thư mục cha)
    parent_dir = os.path.dirname(target_path)
    owner_raw, _, _ = run_root_cmd_injector(f"stat -c '%U:%G' {parent_dir}")
    owner = owner_raw.strip()
    
    if owner:
        run_root_cmd_injector(f"chown {owner} {target_path}")
        run_root_cmd_injector(f"chmod 600 {target_path}")
    
    if os.path.exists(TEMP_DIR): shutil.rmtree(TEMP_DIR)
    print(f"[COOKIE] -> Đã nạp Cookie mới cho: {package_name}")
    return True

# --- HÀM LẤY ID VÀ LƯU CONFIG ---

def get_roblox_user_id(cookie):
    """Gọi API Roblox để lấy ID của cookie."""
    try:
        url = "https://users.roblox.com/v1/users/authenticated"
        cookies = {'.ROBLOSECURITY': cookie}
        response = requests.get(url, cookies=cookies, timeout=10)
        if response.status_code == 200:
            data = response.json()
            return str(data.get('id'))
    except Exception:
        pass
    return None

def update_local_config_file(suffix, user_id):
    """Cập nhật file config.txt với định dạng suffix:id."""
    lines = []
    if os.path.exists(LOCAL_CONFIG_FILE):
        try:
            with open(LOCAL_CONFIG_FILE, "r") as f:
                lines = f.readlines()
        except: pass
    
    new_entry = f"{suffix}:{user_id}\n"
    updated = False
    new_content = []
    
    for line in lines:
        if line.strip().startswith(f"{suffix}:"):
            new_content.append(new_entry)
            updated = True
        elif line.strip():
            new_content.append(line)
            
    if not updated:
        new_content.append(new_entry)
        
    try:
        with open(LOCAL_CONFIG_FILE, "w") as f:
            f.writelines(new_content)
        print(f"[CONFIG] Đã lưu vào {LOCAL_CONFIG_FILE}: {suffix}:{user_id}")
    except Exception as e:
        print(f"[CONFIG] Lỗi ghi file: {e}")

def run_cookie_check_sequence(config):
    """Quy trình kiểm tra Cookie."""
    print("\n[COOKIE] === KIỂM TRA COOKIE (SMART PATH) ===")
    
    remote_cookies = get_remote_cookies_list()
    if not remote_cookies:
        print("[COOKIE] Không lấy được danh sách Cookie -> Dừng kiểm tra.")
        return

    base_pkg = config.get("BASE_PACKAGE_NAME", "com.roblox.clien")
    accounts = config.get("ACCOUNT_SUFFIXES", []) 

    for i, acc in enumerate(accounts):
        suffix = acc['suffix']
        pkg_name = f"{base_pkg}{suffix}"
        
        if i < len(remote_cookies):
            assigned_cookie = remote_cookies[i]
        else:
            print(f"[COOKIE] ⚠️ Không đủ Cookie cho '{suffix}' (Acc #{i+1}). Bỏ qua.")
            continue

        print(f"[COOKIE] Acc '{suffix}' -> ", end="")
        local_cookie = get_local_cookie_injector(pkg_name)

        if local_cookie == assigned_cookie:
            print("OK (Khớp) -> Skip.")
        else:
            if local_cookie is None:
                print("MISSING (Chưa có/Không tìm thấy file).")
            else:
                print("MISMATCH (Khác biệt).")
            
            success = inject_cookie_process(pkg_name, assigned_cookie)
            
            if success:
                print(f"[INFO] Đang lấy ID mới cho '{suffix}'...")
                uid = get_roblox_user_id(assigned_cookie)
                if uid:
                    print(f"[INFO] ID tìm thấy: {uid}")
                    update_local_config_file(suffix, uid)
                    acc['id'] = uid 
                else:
                    print(f"[INFO] Không lấy được ID từ API.")
    
    print("[COOKIE] === HOÀN TẤT ===\n")

# ==============================================================================
# -- CÁC HÀM KẾT NỐI API (SCANNER/LAUNCHER) --
# ==============================================================================

def execute_api_request_with_proxy(method, url, config, thread_name, json_data=None):
    global proxy_index, failed_proxy_count, current_proxies
    timeout = config.get("CONNECTION_TIMEOUT", 15)
    num_proxies = len(current_proxies)
    
    while True:
        if num_proxies > 0 and failed_proxy_count >= num_proxies:
            print(f"\n[{thread_name}] Tất cả proxies lỗi. Nghỉ 5 giây...")
            time.sleep(5)
            failed_proxy_count = 0; 
            if num_proxies > 0:
                proxy_index = random.randint(0, num_proxies - 1)
        
        proxy, proxy_status = (current_proxies[proxy_index], f"Proxy {proxy_index + 1}/{num_proxies}") if num_proxies > 0 else (None, "IP Gốc")
        
        try:
            print(f"\r[{thread_name}] Kết nối API... | {proxy_status}", end="")
            sys.stdout.flush()
            if method.upper() == 'GET': response = requests.get(url, proxies=proxy, timeout=timeout)
            elif method.upper() == 'POST': response = requests.post(url, json=json_data, proxies=proxy, timeout=timeout)
            else: raise ValueError(f"Method: {method}")
            
            if response.status_code == 200:
                failed_proxy_count = 0
                return response.json()
            
            error_reason = "Rate Limit" if response.status_code == 429 else f"Code {response.status_code}"
            raise requests.exceptions.HTTPError(error_reason)
            
        except (requests.exceptions.RequestException, requests.exceptions.HTTPError, ValueError) as e:
            if num_proxies > 0:
                print(f"\n[{thread_name}] Proxy {proxy_index + 1} lỗi ({e}). Đổi proxy...")
                failed_proxy_count += 1
                if num_proxies > 1:
                    new_index = proxy_index
                    while new_index == proxy_index:
                        new_index = random.randint(0, num_proxies - 1)
                    proxy_index = new_index
                time.sleep(1)
            else:
                print(f"\n[{thread_name}] IP Gốc lỗi ({e}). Nghỉ 60 giây...")
                time.sleep(60)

def execute_api_request_simple(method, url, config, thread_name, json_data=None, proxy=None):
    timeout = config.get("CONNECTION_TIMEOUT", 15)
    proxies = proxy if proxy else None
    try:
        if method.upper() == 'GET': response = requests.get(url, proxies=proxies, timeout=timeout)
        elif method.upper() == 'POST': response = requests.post(url, json=json_data, proxies=proxies, timeout=timeout)
        if response.status_code == 200: return response.json()
    except Exception: pass 
    return None

def check_roblox_presence_single(account_id, config, thread_name, proxy_list, initial_proxy_index):
    # ID này được lấy từ config.txt local
    if not account_id or str(account_id) == "0":
        print(f"[{thread_name}] ⚠️ Không có User ID (hoặc ID=0) trong config.txt -> Bỏ qua check.")
        return False

    user_ids = [int(account_id)]
    api_url = "https://presence.roblox.com/v1/presence/users"
    payload = {"userIds": user_ids}
    
    formatted_proxies = proxy_list
    num_proxies = len(formatted_proxies)
    
    REQUIRED_VALID_CHECKS = 3
    valid_checks_count = 0
    current_idx = initial_proxy_index if initial_proxy_index >= 0 else 0
    consecutive_network_failures = 0
    MAX_CONSECUTIVE_FAILURES = 50 

    while valid_checks_count < REQUIRED_VALID_CHECKS:
        response = None
        while response is None:
            proxy = None
            proxy_info = "IP Gốc"
            if num_proxies > 0:
                current_idx = current_idx % num_proxies
                proxy = formatted_proxies[current_idx]
                proxy_info = f"Proxy #{current_idx + 1}"
            
            print(f"[{thread_name}] [{account_id}] Check {valid_checks_count + 1}/{REQUIRED_VALID_CHECKS} | {proxy_info}...", end='\r')
            sys.stdout.flush()

            response = execute_api_request_simple('POST', api_url, config, thread_name, json_data=payload, proxy=proxy)

            if response is None:
                consecutive_network_failures += 1
                print(f"[{thread_name}] [{account_id}] {proxy_info} Lỗi mạng -> Retry...          ")
                time.sleep(1)
                if num_proxies > 1:
                    new_idx = current_idx
                    while new_idx == current_idx:
                        new_idx = random.randint(0, num_proxies - 1)
                    current_idx = new_idx
                else: time.sleep(2)
                
                if consecutive_network_failures > MAX_CONSECUTIVE_FAILURES:
                    print(f"[{thread_name}] [{account_id}] QUÁ NHIỀU LỖI. Hủy check.")
                    return False
            else:
                consecutive_network_failures = 0

        is_online = False
        if 'userPresences' in response:
            for p in response['userPresences']:
                if p.get('userPresenceType') == 2 and str(p.get('userId')) == str(account_id):
                    is_online = True
        
        if is_online:
            print(f"[{thread_name}] [{account_id}] {proxy_info}: ONLINE! (Dừng check)                ")
            return True
        else:
            print(f"[{thread_name}] [{account_id}] {proxy_info}: OFFLINE (OK {valid_checks_count + 1})")
            valid_checks_count += 1
            if num_proxies > 1:
                new_idx = current_idx
                while new_idx == current_idx:
                    new_idx = random.randint(0, num_proxies - 1)
                current_idx = new_idx
            time.sleep(0.5)

    print(f"[{thread_name}] [{account_id}] XÁC NHẬN OFFLINE.")
    return False

# ==============================================================================
# -- DELTA KEY MANAGER --
# ==============================================================================

def delta_key_monitor_loop():
    thread_name = "DELTA-KEY"
    print(f"[{thread_name}] Start Delta Key Monitor...")
    LOCAL_KEY_PATH = "/storage/emulated/0/Delta/Internals/Cache/license"

    while True:
        config = fetch_and_load_config(CONFIG_URL)
        if str(config.get("SELECTED_EXECUTOR")) != "1":
            time.sleep(3600)
            continue

        key_url = config.get("DELTA_KEY_URL")
        interval = config.get("KEY_CHECK_INTERVAL_MINUTES", 30)

        if key_url:
            try:
                response = requests.get(key_url, timeout=15)
                if response.status_code == 200:
                    remote_key = response.text.strip()
                    local_key = ""
                    if os.path.exists(LOCAL_KEY_PATH):
                        try:
                            with open(LOCAL_KEY_PATH, "r") as f:
                                local_key = f.read().strip()
                        except: pass
                    
                    if remote_key != local_key:
                        print(f"[{thread_name}] PHÁT HIỆN KEY MỚI! Cập nhật...")
                        os.makedirs(os.path.dirname(LOCAL_KEY_PATH), exist_ok=True)
                        with open(LOCAL_KEY_PATH, "w") as f:
                            f.write(remote_key)
                        
                        print(f"[{thread_name}] Đã cập nhật Key. REBOOT sau 5s...")
                        time.sleep(5)
                        subprocess.run(["su", "-c", "reboot"])
            except Exception as e:
                print(f"[{thread_name}] Lỗi check Key: {e}")

        time.sleep(interval * 60)

# ==============================================================================
# -- LOGIC CHÍNH: SCAN & LAUNCH --
# ==============================================================================

def run_scanner(config, thread_name="SCAN"):
    global current_proxies, proxy_index
    print(f"[{thread_name}] Quét server...")
    
    current_proxies = format_proxies(config.get("PROXY_LIST", []))
    if len(current_proxies) > 0:
        proxy_index = random.randint(0, len(current_proxies) - 1)
        
    min_ratio = config.get("MIN_PLAYER_PERCENTAGE", 0) / 100.0
    max_ratio = config.get("MAX_PLAYER_PERCENTAGE", 100) / 100.0
    place_id = config["PLACE_ID"]
    
    collected_ids, next_cursor = [], ""
    while True:
        api_url = f"https://games.roblox.com/v1/games/{place_id}/servers/Public?sortOrder=Desc&limit=100"
        if next_cursor and next_cursor != "null": api_url += f"&cursor={next_cursor}"
        
        data = execute_api_request_with_proxy('GET', api_url, config, thread_name) 
        if not data: continue
        
        servers = data.get("data", [])
        next_cursor = data.get("nextPageCursor")
        
        if not servers:
            print(f"\n[{thread_name}] Hết server.")
            break
            
        total_ratio = sum((s.get("playing", 0) / s.get("maxPlayers", 1)) for s in servers if s.get("maxPlayers", 0) > 0)
        
        for s in servers:
            if s.get("maxPlayers", 0) > 0:
                ratio = s.get("playing", 0) / s.get("maxPlayers")
                if min_ratio <= ratio <= max_ratio:
                    sid = s.get("id")
                    if sid and sid not in collected_ids: collected_ids.append(sid)
        
        avg_ratio = (total_ratio / len(servers)) if servers else 0
        print(f"\r[{thread_name}] Scan... | Tỉ lệ: {avg_ratio * 100:5.1f}% | Tìm thấy: {len(collected_ids):<5}", end="")
        
        if 0 < avg_ratio < min_ratio or not next_cursor or next_cursor == "null":
            print(f"\n[{thread_name}] Dừng quét.")
            break
            
    output_path = config["OUTPUT_FILE_PATH"]
    output_dir = os.path.dirname(output_path)
    if output_dir and not os.path.exists(output_dir):
        try: os.makedirs(output_dir)
        except: pass

    with file_lock:
        try:
            with open(output_path, "w") as f:
                with open(output_path, "w") as f:
                    for sid in collected_ids: f.write(f"{sid}\n")
            print(f"[{thread_name}] Đã lưu {len(collected_ids)} ID vào {output_path}")
        except Exception as e:
            print(f"\n[{thread_name}] Lỗi ghi file: {e}")
            
    return True

def launch_roblox_instances(config, launch_mode, thread_name="LAUNCH"):
    accounts = config.get("ACCOUNT_SUFFIXES", [])
    if not accounts:
        print(f"[{thread_name}] Lỗi: Chưa cấu hình tài khoản.")
        return
    
    server_ids = []
    if launch_mode == 'scan':
        with file_lock:
            try:
                with open(config['OUTPUT_FILE_PATH'], 'r') as f:
                    server_ids = [line.strip() for line in f if line.strip()]
            except: pass
        if not server_ids:
            print(f"[{thread_name}] Chờ server quét được...")
            return

    base_pkg = config.get("BASE_PACKAGE_NAME", "com.roblox.clien")
    formatted_proxies = format_proxies(config.get("PROXY_LIST", []))
    num_proxies = len(formatted_proxies)
    
    for i, acc in enumerate(accounts):
        suffix, uid = acc['suffix'], acc['id']
        pkg_name = f"{base_pkg}{suffix}"
        
        print(f"\n[{thread_name}] ---- CHECK ACCOUNT: {suffix} (ID: {uid}) ----")
        
        is_process_active = check_process_running(pkg_name)
        should_launch = False
        
        if not is_process_active:
            print(f"[{thread_name}] App '{suffix}' đang TẮT -> START.")
            should_launch = True
        else:
            print(f"[{thread_name}] App '{suffix}' đang CHẠY -> Check API...")
            start_idx = random.randint(0, num_proxies - 1) if num_proxies > 0 else -1
            is_online = check_roblox_presence_single(uid, config, thread_name, formatted_proxies, start_idx)
            
            if is_online:
                print(f"[{thread_name}] '{suffix}' ONLINE -> Skip.")
                continue 
            else:
                print(f"[{thread_name}] '{suffix}' OFFLINE -> Kill & Restart.")
                try:
                    cmd_kill = f"PID=$(ps -ef | grep {pkg_name} | grep -v grep | awk '{{print $2}}'); if [ ! -z \"$PID\" ]; then kill -9 $PID; fi"
                    subprocess.run(["su", "-c", cmd_kill], capture_output=True, timeout=10)
                    time.sleep(3) 
                except: pass
                should_launch = True

        if should_launch:
            target_url = ""
            if launch_mode == 'scan':
                if server_ids:
                    target_url = f"roblox://placeId={config['PLACE_ID']}&gameId={server_ids[i % len(server_ids)]}"
                else:
                    print(f"[{thread_name}] Hết server ID. Bỏ qua.")
                    continue
            elif launch_mode == 'vip':
                target_url = config.get('VIP_SERVER_URL', "")
            
            if target_url:
                subprocess.run(["am", "start", "-a", "android.intent.action.VIEW", "-d", target_url, "-p", pkg_name], capture_output=True)
                print(f"[{thread_name}] Đã start: {pkg_name}")
            
            delay = config.get("LAUNCH_DELAY_SECONDS", 10)
            if i < len(accounts) - 1:
                print(f"[{thread_name}] Đợi {delay}s...")
                time.sleep(delay)

# ==============================================================================
# -- VÒNG LẶP & MAIN --
# ==============================================================================

def scanner_loop():
    print("[SCAN] Bắt đầu.")
    config = fetch_and_load_config(CONFIG_URL)
    while True:
        run_scanner(config, "SCAN")
        countdown(config.get("SCAN_INTERVAL_SECONDS", 300), "SCAN")

def launcher_loop(mode):
    print(f"[LAUNCH] Bắt đầu chế độ {mode}.")
    config = fetch_and_load_config(CONFIG_URL)
    while True:
        launch_roblox_instances(config, mode, "LAUNCH")
        countdown(config.get("LAUNCH_INTERVAL_SECONDS", 300), "LAUNCH")

def reboot_loop():
    print("[REBOOT] Kiểm tra lịch.")
    config = fetch_and_load_config(CONFIG_URL)
    if config.get("REBOOT_ENABLED", "off").lower() == "on":
        mins = config.get("REBOOT_INTERVAL_MINUTES", 1200)
        print(f"[REBOOT] Hẹn giờ: {mins} phút.")
        time.sleep(mins * 60)
        print("[REBOOT] Đang khởi động lại...")
        try: subprocess.run(["su", "-c", "reboot"])
        except: pass

if __name__ == "__main__":
    os.system("termux-wake-lock")
    if not check_root_access(): sys.exit(1)
    
    print("[MAIN] Tải cấu hình & Kiểm tra Cookie (v1.10 Smart Inject)...")
    initial_config = fetch_and_load_config(CONFIG_URL)
    run_cookie_check_sequence(initial_config)
    
    # Reload lại để đảm bảo ID mới (nếu có update) được nạp vào
    final_config = fetch_and_load_config(CONFIG_URL)
    
    threading.Thread(target=reboot_loop, daemon=True).start()
    threading.Thread(target=delta_key_monitor_loop, daemon=True).start()

    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(dest='command')
    subparsers.add_parser('parallel')
    subparsers.add_parser('scan')
    lp = subparsers.add_parser('launch')
    lp.add_argument('--mode', choices=['scan', 'vip'], default='scan')
    
    args = parser.parse_args()
    cmd = args.command if args.command else 'parallel'

    try:
        if cmd == 'scan': scanner_loop()
        elif cmd == 'launch': launcher_loop(args.mode)
        elif cmd == 'parallel':
            threading.Thread(target=scanner_loop, daemon=True).start()
            time.sleep(3)
            threading.Thread(target=launcher_loop, args=('vip',), daemon=True).start()
            while True: time.sleep(1)
    except KeyboardInterrupt:
        print("\n[MAIN] Dừng.")
