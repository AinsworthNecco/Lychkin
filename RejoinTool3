#!/data/data/com.termux/files/usr/bin/python
# -*- coding: utf-8 -*-

import subprocess
import time
import requests
import os
import sys
import argparse
import re
import threading
import json
import atexit
import signal

# ==============================================================================
# SCRIPT K·∫æT H·ª¢P: Lychkins's Task Runner v1.3 (HARDWARE DOWNCLOCK)
#
# C·∫¢I TI·∫æN T·ª™ v1.2:
# - Lo·∫°i b·ªè c∆° ch·∫ø "Pause" (ng·ªß) khi CPU cao v√¨ kh√¥ng c·∫ßn thi·∫øt.
# - Thay th·∫ø b·∫±ng c∆° ch·∫ø "Hardware Downclock" (Gi·∫£m xung nh·ªãp ph·∫ßn c·ª©ng).
# - Script s·∫Ω kh√≥a xung nh·ªãp t·ªëi ƒëa c·ªßa CPU ·ªü m·ª©c % c√†i ƒë·∫∑t (VD: 70%).
# - Gi√∫p m√°y m√°t h∆°n li√™n t·ª•c (Always Cool) m√† kh√¥ng bao gi·ªù d·ª´ng script.
# ==============================================================================

# ---------------------------------------------------
# -- C·∫§U H√åNH CH√çNH --
# ---------------------------------------------------
CONFIG_URL = "https://raw.githubusercontent.com/AinsworthNecco/Lychkin/refs/heads/main/config3"

# --- C√ÅC GI√Å TR·ªä M·∫∂C ƒê·ªäNH ---
DEFAULT_CONFIG = {
    "ACCOUNT_SUFFIXES": [],
    "PLACE_ID": "8737602449",
    "SCAN_INTERVAL_SECONDS": 300,
    "LAUNCH_INTERVAL_SECONDS": 300,
    "MIN_PLAYER_PERCENTAGE": 0,
    "MAX_PLAYER_PERCENTAGE": 50,
    "BASE_PACKAGE_NAME": "com.roblox.client",
    "PROXY_LIST": [],
    "CONNECTION_TIMEOUT": 15,
    "OUTPUT_FILE_PATH": "found_servers.txt",
    "VIP_SERVER_URL": "",
    "REBOOT_ENABLED": "off",
    "REBOOT_INTERVAL_MINUTES": 1200,
    # --- C·∫•u h√¨nh Gi·∫£m xung (Downclock) ---
    "CPU_DOWNCLOCK_ENABLED": "on",  # B·∫≠t/T·∫Øt gi·∫£m xung
    "CPU_MAX_FREQ_PERCENT": 70,     # Ch·ªâ ch·∫°y t·ªëi ƒëa 70% c√¥ng su·∫•t th·ª±c c·ªßa ph·∫ßn c·ª©ng
}

# ---------------------------------------------------
# -- BI·∫æN TO√ÄN C·ª§C --
# ---------------------------------------------------
proxy_index = 0
failed_proxy_count = 0
current_proxies = []
file_lock = threading.Lock()
original_freqs = {} # L∆∞u tr·ªØ xung nh·ªãp g·ªëc ƒë·ªÉ kh√¥i ph·ª•c khi t·∫Øt

# ==============================================================================
# -- C√ÅC H√ÄM TI·ªÜN √çCH & KI·ªÇM TRA ROOT --
# ==============================================================================

def check_root_access():
    """Ki·ªÉm tra xem script c√≥ quy·ªÅn root hay kh√¥ng."""
    print("[MAIN] ƒêang ki·ªÉm tra quy·ªÅn root...")
    try:
        process = subprocess.run(["su", "-c", "whoami"], capture_output=True, text=True, timeout=10)
        if process.stdout.strip() == "root":
            print("[MAIN] ‚úÖ Quy·ªÅn root ƒë√£ ƒë∆∞·ª£c c·∫•p.")
            return True
        else:
            print("[MAIN] ‚ùå L·ªói: Kh√¥ng th·ªÉ l·∫•y quy·ªÅn root.")
            return False
    except FileNotFoundError:
        print("[MAIN] ‚ùå L·ªói: L·ªánh 'su' kh√¥ng t·ªìn t·∫°i.")
        return False
    except Exception as e:
        print(f"[MAIN] ‚ùå L·ªói kh√¥ng mong mu·ªën: {e}")
        return False

def fetch_and_load_config(url):
    """T·∫£i v√† ph√¢n t√≠ch t·ªáp c·∫•u h√¨nh t·ª´ xa."""
    try:
        response = requests.get(url, timeout=20)
        response.raise_for_status()
        config = DEFAULT_CONFIG.copy()
        pattern = re.compile(r'^\s*([A-Za-z_][A-Za-z0-9_]*)\s*=\s*(["\'])(.*?)\2', re.DOTALL | re.MULTILINE)
        
        for key, _, value in pattern.findall(response.text):
            if key not in config: continue
            value = value.strip()
            
            if key in ["SCAN_INTERVAL_SECONDS", "LAUNCH_INTERVAL_SECONDS", "CONNECTION_TIMEOUT", "REBOOT_INTERVAL_MINUTES", "CPU_MAX_FREQ_PERCENT"]:
                config[key] = int(value)
            elif key in ["MIN_PLAYER_PERCENTAGE", "MAX_PLAYER_PERCENTAGE"]:
                config[key] = float(value)
            elif key == "ACCOUNT_SUFFIXES":
                accounts = []
                for item in value.split(','):
                    item = item.strip()
                    if ':' in item:
                        parts = item.split(':', 1)
                        if len(parts) == 2 and parts[0].strip() and parts[1].strip().isdigit():
                            accounts.append({'suffix': parts[0].strip(), 'id': parts[1].strip()})
                config[key] = accounts
            elif key == "PROXY_LIST":
                config[key] = [item.strip() for item in value.splitlines() if item.strip()]
            else:
                config[key] = value
                
        return config
    except requests.exceptions.RequestException as e:
        return DEFAULT_CONFIG.copy()

def format_proxies(proxy_list):
    """Chuy·ªÉn ƒë·ªïi danh s√°ch proxy."""
    formatted = []
    if not proxy_list or not proxy_list[0]: return []
    for proxy_string in proxy_list:
        parts = proxy_string.split(':')
        proxy_url = ""
        if len(parts) == 2: proxy_url = f"http://{parts[0]}:{parts[1]}"
        elif len(parts) == 4: proxy_url = f"http://{parts[2]}:{parts[3]}@{parts[0]}:{parts[1]}"
        if proxy_url: formatted.append({"http": proxy_url, "https": proxy_url})
    return formatted

def countdown(seconds, thread_name="MAIN"):
    """Hi·ªÉn th·ªã ƒë·ªìng h·ªì ƒë·∫øm ng∆∞·ª£c."""
    for i in range(seconds, 0, -1):
        print(f"[{thread_name}] Th·ªùi gian ch·ªù c√≤n l·∫°i: {i} gi√¢y    ", end='\r')
        sys.stdout.flush()
        time.sleep(1)
    print(f"[{thread_name}] B·∫Øt ƒë·∫ßu chu k·ª≥ m·ªõi.                                 ")

# ==============================================================================
# -- H·ªÜ TH·ªêNG GI·∫¢M XUNG CPU (HARDWARE DOWNCLOCK) --
# ==============================================================================

def get_cpu_cores():
    """L·∫•y danh s√°ch c√°c core CPU c√≥ s·∫µn (vd: cpu0, cpu1...)."""
    try:
        cmd = ["su", "-c", "ls -d /sys/devices/system/cpu/cpu[0-9]*"]
        result = subprocess.run(cmd, capture_output=True, text=True)
        paths = result.stdout.strip().split('\n')
        cores = [os.path.basename(p) for p in paths if p.strip()]
        return cores
    except Exception:
        return []

def read_system_file(path):
    """ƒê·ªçc file h·ªá th·ªëng b·∫±ng quy·ªÅn root."""
    cmd = ["su", "-c", f"cat {path}"]
    result = subprocess.run(cmd, capture_output=True, text=True)
    return result.stdout.strip()

def write_system_file(path, value):
    """Ghi file h·ªá th·ªëng b·∫±ng quy·ªÅn root."""
    cmd = ["su", "-c", f"echo {value} > {path}"]
    subprocess.run(cmd, capture_output=True, text=True)

def apply_cpu_limit():
    """√Åp d·ª•ng gi·ªõi h·∫°n xung nh·ªãp cho to√†n b·ªô c√°c core."""
    global original_freqs
    
    config = fetch_and_load_config(CONFIG_URL)
    if config.get("CPU_DOWNCLOCK_ENABLED", "on").lower() != "on":
        print("[CPU_TUNER] Ch·ª©c nƒÉng gi·∫£m xung ƒëang T·∫ÆT trong config.")
        return

    percent = config.get("CPU_MAX_FREQ_PERCENT", 70)
    if percent < 30: percent = 30 # An to√†n: kh√¥ng gi·∫£m qu√° th·∫•p tr√°nh lag m√°y
    if percent > 100: percent = 100
    
    print(f"\n[CPU_TUNER] ‚ùÑÔ∏è ƒêang thi·∫øt l·∫≠p gi·ªõi h·∫°n CPU xu·ªëng m·ª©c {percent}%...")
    
    cores = get_cpu_cores()
    for core in cores:
        base_path = f"/sys/devices/system/cpu/{core}/cpufreq"
        
        # 1. ƒê·ªçc c√°c t·∫ßn s·ªë h·ªó tr·ª£
        avail_freqs_str = read_system_file(f"{base_path}/scaling_available_frequencies")
        if not avail_freqs_str:
            continue # Core n√†y kh√¥ng h·ªó tr·ª£ ƒë·ªçc freq (·∫£o h√≥a ho·∫∑c driver l·∫°)
            
        freqs = sorted([int(x) for x in avail_freqs_str.split()], reverse=True) # S·∫Øp x·∫øp gi·∫£m d·∫ßn
        if not freqs: continue
        
        max_hardware_freq = freqs[0] # T·∫ßn s·ªë cao nh·∫•t ph·∫ßn c·ª©ng h·ªó tr·ª£
        
        # 2. L∆∞u t·∫ßn s·ªë max hi·ªán t·∫°i ƒë·ªÉ kh√¥i ph·ª•c sau n√†y (n·∫øu ch∆∞a l∆∞u)
        if core not in original_freqs:
            curr_max = read_system_file(f"{base_path}/scaling_max_freq")
            if curr_max:
                original_freqs[core] = curr_max
        
        # 3. T√≠nh to√°n t·∫ßn s·ªë m·ª•c ti√™u
        target_freq = max_hardware_freq * (percent / 100.0)
        
        # 4. T√¨m t·∫ßn s·ªë trong danh s√°ch g·∫ßn nh·∫•t v·ªõi m·ª•c ti√™u (nh∆∞ng nh·ªè h∆°n ho·∫∑c b·∫±ng)
        selected_freq = freqs[-1] # M·∫∑c ƒë·ªãnh l·∫•y th·∫•p nh·∫•t n·∫øu kh√¥ng t√¨m th·∫•y
        for f in freqs:
            if f <= target_freq:
                selected_freq = f
                break
        
        # 5. √Åp d·ª•ng gi·ªõi h·∫°n
        write_system_file(f"{base_path}/scaling_max_freq", selected_freq)
        
        # Hi·ªÉn th·ªã log (r√∫t g·ªçn ƒë∆°n v·ªã KHz -> MHz)
        print(f"   -> {core}: G·ªëc {max_hardware_freq//1000}MHz => Gi·ªõi h·∫°n {selected_freq//1000}MHz")

    print("[CPU_TUNER] ‚úÖ ƒê√£ √°p d·ª•ng gi·∫£m xung. M√°y s·∫Ω ch·∫°y m√°t h∆°n.\n")

def restore_cpu_limit():
    """Kh√¥i ph·ª•c l·∫°i xung nh·ªãp ban ƒë·∫ßu khi t·∫Øt script."""
    global original_freqs
    if not original_freqs:
        return
        
    print("\n[CPU_TUNER] üîÑ ƒêang kh√¥i ph·ª•c xung nh·ªãp CPU v·ªÅ m·∫∑c ƒë·ªãnh...")
    for core, original_val in original_freqs.items():
        base_path = f"/sys/devices/system/cpu/{core}/cpufreq"
        write_system_file(f"{base_path}/scaling_max_freq", original_val)
    print("[CPU_TUNER] ‚úÖ ƒê√£ kh√¥i ph·ª•c hi·ªáu nƒÉng t·ªëi ƒëa.")

# ƒêƒÉng k√Ω h√†m kh√¥i ph·ª•c khi tho√°t script
atexit.register(restore_cpu_limit)
signal.signal(signal.SIGTERM, lambda n, f: sys.exit(0))
signal.signal(signal.SIGINT, lambda n, f: sys.exit(0))

# ==============================================================================
# -- C√ÅC H√ÄM K·∫æT N·ªêI API --
# ==============================================================================

def execute_api_request_with_proxy(method, url, config, thread_name, json_data=None):
    """H√†m k·∫øt n·ªëi API an to√†n, C√ì S·ª¨ D·ª§NG proxy."""
    global proxy_index, failed_proxy_count, current_proxies
    num_proxies = len(current_proxies)
    
    while True:
        if num_proxies > 0 and failed_proxy_count >= num_proxies:
            print(f"\n[{thread_name}] [!] T·∫•t c·∫£ proxies ƒë·ªÅu th·∫•t b·∫°i. T·∫°m d·ª´ng 5 gi√¢y...")
            time.sleep(5)
            failed_proxy_count = 0; proxy_index = 0
        proxy, proxy_status = (current_proxies[proxy_index], f"Proxy {proxy_index + 1}/{num_proxies}") if num_proxies > 0 else (None, "IP G·ªëc")
        try:
            print(f"\r[{thread_name}] [*] K·∫øt n·ªëi API (Proxy)... | {proxy_status}", end="")
            sys.stdout.flush()
            if method.upper() == 'GET': response = requests.get(url, proxies=proxy, timeout=config["CONNECTION_TIMEOUT"])
            elif method.upper() == 'POST': response = requests.post(url, json=json_data, proxies=proxy, timeout=config["CONNECTION_TIMEOUT"])
            else: raise ValueError(f"Ph∆∞∆°ng th·ª©c HTTP kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£: {method}")
            if response.status_code == 200:
                failed_proxy_count = 0
                return response.json()
            error_reason = f"L·ªói (M√£: {response.status_code})"
            if response.status_code == 429: error_reason = "Rate Limit"
            raise requests.exceptions.HTTPError(error_reason)
        except (requests.exceptions.RequestException, requests.exceptions.HTTPError, ValueError) as e:
            if num_proxies > 0:
                failed_proxy_count += 1
                proxy_index = (proxy_index + 1) % num_proxies
                time.sleep(1)
            else:
                print(f"\n[{thread_name}] [!] IP G·ªëc th·∫•t b·∫°i ({e}). T·∫°m d·ª´ng 60 gi√¢y...")
                time.sleep(60)

def execute_direct_api_request(method, url, config, thread_name, json_data=None):
    """Th·ª±c hi·ªán y√™u c·∫ßu API tr·ª±c ti·∫øp KH√îNG QUA PROXY."""
    retries = 3
    for attempt in range(retries):
        try:
            print(f"\r[{thread_name}] [*] K·∫øt n·ªëi API (IP G·ªëc)...", end="")
            sys.stdout.flush()
            if method.upper() == 'GET': response = requests.get(url, timeout=config["CONNECTION_TIMEOUT"])
            elif method.upper() == 'POST': response = requests.post(url, json=json_data, timeout=config["CONNECTION_TIMEOUT"])
            else: raise ValueError(f"Ph∆∞∆°ng th·ª©c HTTP kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£: {method}")
            if response.status_code == 200: return response.json()
            error_reason = f"L·ªói (M√£: {response.status_code})"
            print(f"\n[{thread_name}] [!] API L·ªói ({error_reason}). Th·ª≠ l·∫°i sau 5 gi√¢y...")
        except (requests.exceptions.RequestException, ValueError) as e:
            print(f"\n[{thread_name}] [!] API L·ªói ({e}). Th·ª≠ l·∫°i sau 5 gi√¢y...")
        if attempt < retries - 1: time.sleep(5)
        else:
            return None

# ==============================================================================
# -- C√ÅC H√ÄM CH·ª®C NƒÇNG CH√çNH --
# ==============================================================================

def check_roblox_presence(accounts, config, thread_name):
    """Ki·ªÉm tra tr·∫°ng th√°i online."""
    user_ids = [int(acc['id']) for acc in accounts]
    if not user_ids: return {}
    api_url = "https://presence.roblox.com/v1/presence/users"
    payload = {"userIds": user_ids}
    response_data = execute_direct_api_request('POST', api_url, config, thread_name, json_data=payload)
    status_map = {str(uid): False for uid in user_ids}
    if response_data and 'userPresences' in response_data:
        for presence in response_data['userPresences']:
            if presence.get('userPresenceType') == 2: status_map[str(presence.get('userId'))] = True
    return status_map

def run_scanner(config, thread_name="SCAN"):
    """Qu√©t API, l·ªçc server v√† l∆∞u k·∫øt qu·∫£."""
    global current_proxies
    
    print(f"[{thread_name}] B·∫Øt ƒë·∫ßu qu√° tr√¨nh qu√©t server...")
    current_proxies = format_proxies(config["PROXY_LIST"])
    min_ratio, max_ratio = config["MIN_PLAYER_PERCENTAGE"] / 100.0, config["MAX_PLAYER_PERCENTAGE"] / 100.0
    collected_ids, next_cursor = [], ""
    
    while True:
        api_url = f"https://games.roblox.com/v1/games/{config['PLACE_ID']}/servers/Public?sortOrder=Desc&limit=100"
        if next_cursor and next_cursor != "null": api_url += f"&cursor={next_cursor}"
        
        response_data = execute_api_request_with_proxy('GET', api_url, config, thread_name)
        if not response_data: continue
        
        servers, next_cursor = response_data.get("data", []), response_data.get("nextPageCursor")
        if not servers:
            print(f"\n[{thread_name}] [i] Kh√¥ng t√¨m th·∫•y server n√†o. D·ª´ng qu√©t.")
            break
            
        total_ratio = sum((s.get("playing", 0) / s.get("maxPlayers", 1)) for s in servers if s.get("maxPlayers", 0) > 0)
        for server in servers:
            if server.get("maxPlayers", 0) > 0:
                ratio = server.get("playing", 0) / server.get("maxPlayers")
                if min_ratio <= ratio <= max_ratio:
                    server_id = server.get("id")
                    if server_id and server_id not in collected_ids: collected_ids.append(server_id)
        
        avg_ratio = (total_ratio / len(servers)) if servers else 0
        print(f"\r[{thread_name}] ƒêang qu√©t... | Page Fill: {avg_ratio * 100:5.1f}% | ƒê√£ thu th·∫≠p: {len(collected_ids):<5}", end="")
        
        if 0 < avg_ratio < min_ratio or not next_cursor or next_cursor == "null":
            print(f"\n[{thread_name}] [i] ƒê√£ ƒë·∫øn trang cu·ªëi ho·∫∑c qua v√πng m·ª•c ti√™u. D·ª´ng qu√©t.")
            break
            
    output_path = config["OUTPUT_FILE_PATH"]
    with file_lock:
        with open(output_path, "w") as f:
            for server_id in collected_ids: f.write(f"{server_id}\n")
    print(f"[{thread_name}] ‚úÖ Qu√©t ho√†n t·∫•t. ƒê√£ l∆∞u {len(collected_ids)} server ID.")
    return True

def launch_roblox_instances(config, launch_mode, thread_name="LAUNCH"):
    """Ki·ªÉm tra tr·∫°ng th√°i v√† kh·ªüi ch·∫°y instance."""
    accounts = config.get("ACCOUNT_SUFFIXES", [])
    if not accounts:
        print(f"[{thread_name}] [-] L·ªói: Kh√¥ng c√≥ t√†i kho·∫£n n√†o ƒë∆∞·ª£c c·∫•u h√¨nh.")
        return
        
    print(f"[{thread_name}] [*] ƒêang ki·ªÉm tra tr·∫°ng th√°i online cho {len(accounts)} t√†i kho·∫£n...")
    online_statuses = check_roblox_presence(accounts, config, thread_name)
    print(f"\n[{thread_name}] [i] Ki·ªÉm tra ho√†n t·∫•t.")
    
    server_ids, target_url_template = [], ""
    if launch_mode == 'scan':
        with file_lock:
            try:
                with open(config['OUTPUT_FILE_PATH'], 'r') as f:
                    server_ids = [line.strip() for line in f if line.strip()]
            except FileNotFoundError:
                print(f"[{thread_name}] [-] Ch∆∞a c√≥ file server.")
                return
        if not server_ids:
            print(f"[{thread_name}] [-] File server r·ªóng.")
            return
    elif launch_mode == 'vip':
        if not config.get('VIP_SERVER_URL'):
            print(f"[{thread_name}] [-] L·ªói: Ch∆∞a c·∫•u h√¨nh VIP URL.")
            return
        target_url_template = config['VIP_SERVER_URL']

    for i, account in enumerate(accounts):
        suffix, user_id, package_name = account['suffix'], account['id'], f"{config['BASE_PACKAGE_NAME']}{account['suffix']}"
        is_ingame = online_statuses.get(user_id, False)

        if not is_ingame:
            print(f"[{thread_name}] [ACTION] '{suffix}' Offline. Bu·ªôc d·ª´ng...")
            try:
                kill_script = f"PID=$(ps -ef | grep {package_name} | grep -v grep | awk '{{print $2}}'); if [ ! -z \"$PID\" ]; then kill -9 $PID; fi"
                stop_command = ["su", "-c", kill_script]
                subprocess.run(stop_command, capture_output=True, text=True, timeout=10)
                time.sleep(3)
            except Exception as e:
                print(f"[{thread_name}] [!] L·ªói stop '{suffix}': {e}")
        else:
            print(f"[{thread_name}] [REFRESH] '{suffix}' Online. L√†m m·ªõi phi√™n...")
        
        target_url, log_msg = "", ""
        if launch_mode == 'scan':
            if not server_ids: continue
            server_id = server_ids[i % len(server_ids)]
            target_url = f"roblox://placeId={config['PLACE_ID']}&gameId={server_id}"
            log_msg = f"Server Public"
        elif launch_mode == 'vip':
            target_url = target_url_template
            log_msg = f"Server VIP"
        
        command = ["am", "start", "-a", "android.intent.action.VIEW", "-d", target_url, "-p", package_name]
        print(f"[{thread_name}] -> Launch '{suffix}' v√†o {log_msg}")
        try:
            subprocess.run(command, check=False, capture_output=True, text=True)
        except Exception as e:
            print(f"[{thread_name}] L·ªói launch '{suffix}': {e}")
        
        time.sleep(config.get("LAUNCH_DELAY_SECONDS", 10))

# ==============================================================================
# -- C√ÅC V√íNG L·∫∂P CHO THREAD --
# ==============================================================================

def scanner_loop():
    print("[SCAN] T·∫£i c·∫•u h√¨nh l·∫ßn ƒë·∫ßu...")
    config = fetch_and_load_config(CONFIG_URL)
    interval = config.get("SCAN_INTERVAL_SECONDS", 300)
    while True:
        run_scanner(config, "SCAN")
        countdown(interval, "SCAN")

def launcher_loop(launch_mode):
    print("[LAUNCH] T·∫£i c·∫•u h√¨nh l·∫ßn ƒë·∫ßu...")
    config = fetch_and_load_config(CONFIG_URL)
    interval = config.get("LAUNCH_INTERVAL_SECONDS", 300)
    while True:
        launch_roblox_instances(config, launch_mode, "LAUNCH")
        countdown(interval, "LAUNCH")

def reboot_scheduler_loop():
    config = fetch_and_load_config(CONFIG_URL)
    if config.get("REBOOT_ENABLED", "off").lower() != "on":
        print("[REBOOT] T·ª± ƒë·ªông reboot ƒëang T·∫ÆT.")
        return

    reboot_minutes_val = config.get("REBOOT_INTERVAL_MINUTES", 1200)
    reboot_seconds = reboot_minutes_val * 60
    print(f"[REBOOT] ‚úÖ Reboot sau {reboot_minutes_val} ph√∫t.")
    
    for i in range(reboot_seconds, 0, -1):
        hours, remainder = divmod(i, 3600)
        minutes, seconds = divmod(remainder, 60)
        time.sleep(1)

    print(f"\n[REBOOT] ƒêANG KH·ªûI ƒê·ªòNG L·∫†I THI·∫æT B·ªä...")
    time.sleep(5)
    try:
        subprocess.run(["su", "-c", "reboot"], check=True, capture_output=True, text=True)
    except Exception as e:
        print(f"[REBOOT] L·ªói: {e}")

# ==============================================================================
# -- ƒêI·ªÇM KH·ªûI ƒê·∫¶U SCRIPT --
# ==============================================================================

if __name__ == "__main__":
    if not check_root_access():
        sys.exit(1)

    # 1. √ÅP D·ª§NG HARDWARE DOWNCLOCK (M·ªöI)
    # H√†m n√†y s·∫Ω ch·∫°y 1 l·∫ßn ngay khi m·ªü script
    apply_cpu_limit()

    # 2. Lu·ªìng Reboot
    reboot_thread = threading.Thread(target=reboot_scheduler_loop, daemon=True)
    reboot_thread.start()

    parser = argparse.ArgumentParser(description="Roblox Task Runner v1.3 - Hardware Downclock")
    subparsers = parser.add_subparsers(dest='command', help='C√°c l·ªánh c√≥ s·∫µn')

    parallel_parser = subparsers.add_parser('parallel', help='Ch·∫°y song song (m·∫∑c ƒë·ªãnh).')
    scan_parser = subparsers.add_parser('scan', help='Ch·ªâ ch·∫°y t√°c v·ª• qu√©t.')
    launch_parser = subparsers.add_parser('launch', help='Ch·ªâ ch·∫°y t√°c v·ª• tham gia game.')
    launch_parser.add_argument('--mode', choices=['scan', 'vip'], default='scan', help="Ch·∫ø ƒë·ªô tham gia.")
    
    args = parser.parse_args()
    command = args.command if args.command else 'parallel'

    try:
        if command == 'scan':
            print("--- CH·∫æ ƒê·ªò: CH·ªà QU√âT SERVER ---")
            scanner_loop()
        elif command == 'launch':
            print(f"--- CH·∫æ ƒê·ªò: CH·ªà THAM GIA GAME (MODE: {args.mode.upper()}) ---")
            launcher_loop(args.mode)
        elif command == 'parallel':
            print("--- CH·∫æ ƒê·ªò: SONG SONG (SCAN & LAUNCH VIP) ---")
            scanner_thread = threading.Thread(target=scanner_loop, daemon=True)
            launcher_thread = threading.Thread(target=launcher_loop, args=('vip',), daemon=True)
            scanner_thread.start()
            print("[MAIN] ƒê√£ kh·ªüi ƒë·ªông lu·ªìng qu√©t (SCAN).")
            time.sleep(3) 
            launcher_thread.start()
            print("[MAIN] ƒê√£ kh·ªüi ƒë·ªông lu·ªìng tham gia VIP (LAUNCH).")
            scanner_thread.join()
            launcher_thread.join()
    except KeyboardInterrupt:
        # Khi nh·∫•n Ctrl+C, h√†m restore_cpu_limit s·∫Ω t·ª± ch·∫°y nh·ªù atexit
        print("\n[MAIN] ƒê√£ nh·∫≠n l·ªánh d·ª´ng. ƒêang kh√¥i ph·ª•c c√†i ƒë·∫∑t g·ªëc...")
    except Exception as e:
        print(f"\n[MAIN] ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën: {e}")
