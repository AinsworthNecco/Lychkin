#!/data/data/com.termux/files/usr/bin/python
# -*- coding: utf-8 -*-

import subprocess
import time
import requests
import os
import sys
import argparse
import re
import threading
import json
from datetime import datetime

# ==============================================================================
# SCRIPT K·∫æT H·ª¢P: Lychkins's Task Runner v1.4 (No Owner Check)
#
# C·∫¢I TI·∫æN:
# - G·ªôp Scan v√† Launch v√†o 1 lu·ªìng duy nh·∫•t.
# - Bot Discord nh·∫π nh·∫•t c√≥ th·ªÉ: Kh√¥ng cache, nh·∫≠n l·ªánh t·ª´ b·∫•t k·ª≥ ai trong server.
# - Logic Reboot: T·ª± ƒë·ªông ƒë·∫øm ng∆∞·ª£c HO·∫∂C Reboot ngay khi nh·∫≠n l·ªánh.
# ==============================================================================

# Ki·ªÉm tra th∆∞ vi·ªán discord
try:
    import discord
    DISCORD_AVAILABLE = True
except ImportError:
    DISCORD_AVAILABLE = False
    print("[SYSTEM] ‚ö†Ô∏è Ch∆∞a c√†i 'discord.py'. Bot s·∫Ω kh√¥ng ch·∫°y.")

# ---------------------------------------------------
# -- C·∫§U H√åNH CH√çNH --
# ---------------------------------------------------
CONFIG_URL = "https://raw.githubusercontent.com/AinsworthNecco/Lychkin/refs/heads/main/config3"

# --- C√ÅC GI√Å TR·ªä M·∫∂C ƒê·ªäNH ---
DEFAULT_CONFIG = {
    "ACCOUNT_SUFFIXES": [],
    "PLACE_ID": "8737602449",
    "SCAN_INTERVAL_SECONDS": 300,
    "MIN_PLAYER_PERCENTAGE": 0,
    "MAX_PLAYER_PERCENTAGE": 50,
    "BASE_PACKAGE_NAME": "com.roblox.clien",
    "PROXY_LIST": [],
    "CONNECTION_TIMEOUT": 15,
    "OUTPUT_FILE_PATH": "found_servers.txt",
    "VIP_SERVER_URL": "",
    "REBOOT_ENABLED": "off",
    "REBOOT_INTERVAL_MINUTES": 1200,
    # --- C·∫§U H√åNH DISCORD ---
    "DISCORD_BOT_TOKEN": "",
    "DISCORD_PREFIX": "!"
}

# ---------------------------------------------------
# -- BI·∫æN TO√ÄN C·ª§C --
# ---------------------------------------------------
proxy_index = 0
failed_proxy_count = 0
current_proxies = []
file_lock = threading.Lock()

# ==============================================================================
# -- C√ÅC H√ÄM TI·ªÜN √çCH & H·ªÜ TH·ªêNG --
# ==============================================================================

def check_root_access():
    """Ki·ªÉm tra quy·ªÅn root."""
    try:
        proc = subprocess.run(["su", "-c", "whoami"], capture_output=True, text=True, timeout=5)
        if proc.stdout.strip() == "root": return True
    except: pass
    print("[SYSTEM] ‚ùå L·ªói: C·∫ßn quy·ªÅn Root ƒë·ªÉ ch·∫°y script n√†y.")
    return False

def perform_reboot(source="SYSTEM"):
    """Th·ª±c hi·ªán reboot ngay l·∫≠p t·ª©c."""
    print(f"\n[{source}] ‚ö†Ô∏è TH·ª∞C HI·ªÜN L·ªÜNH REBOOT NGAY L·∫¨P T·ª®C...")
    try:
        subprocess.run(["su", "-c", "sync"], timeout=5) # ƒê·ªìng b·ªô d·ªØ li·ªáu tr√°nh l·ªói file
        subprocess.run(["su", "-c", "reboot"], check=True)
    except Exception as e:
        print(f"[{source}] ‚ùå L·ªói reboot: {e}")

def fetch_and_load_config(url):
    """T·∫£i c·∫•u h√¨nh t·ª´ GitHub."""
    try:
        response = requests.get(url, timeout=20)
        response.raise_for_status()
        config = DEFAULT_CONFIG.copy()
        # Regex ƒë∆°n gi·∫£n ƒë·ªÉ parse file config d·∫°ng text
        pattern = re.compile(r'^\s*([A-Za-z_][A-Za-z0-9_]*)\s*=\s*(["\'])(.*?)\2', re.DOTALL | re.MULTILINE)
        
        for key, _, value in pattern.findall(response.text):
            if key not in config: continue
            value = value.strip()
            
            if key in ["SCAN_INTERVAL_SECONDS", "CONNECTION_TIMEOUT", "REBOOT_INTERVAL_MINUTES"]:
                config[key] = int(value)
            elif key in ["MIN_PLAYER_PERCENTAGE", "MAX_PLAYER_PERCENTAGE"]:
                config[key] = float(value)
            elif key == "ACCOUNT_SUFFIXES":
                accounts = []
                for item in value.split(','):
                    if ':' in item:
                        p = item.split(':', 1)
                        if len(p) == 2 and p[1].strip().isdigit():
                            accounts.append({'suffix': p[0].strip(), 'id': p[1].strip()})
                config[key] = accounts
            elif key == "PROXY_LIST":
                config[key] = [i.strip() for i in value.splitlines() if i.strip()]
            else:
                config[key] = value
        return config
    except:
        return DEFAULT_CONFIG.copy()

def format_proxies(proxy_list):
    formatted = []
    if not proxy_list or not proxy_list[0]: return []
    for p in proxy_list:
        parts = p.split(':')
        u = ""
        if len(parts) == 2: u = f"http://{parts[0]}:{parts[1]}"
        elif len(parts) == 4: u = f"http://{parts[2]}:{parts[3]}@{parts[0]}:{parts[1]}"
        if u: formatted.append({"http": u, "https": u})
    return formatted

def countdown(seconds):
    """ƒê·∫øm ng∆∞·ª£c ƒë∆°n gi·∫£n."""
    for i in range(seconds, 0, -1):
        if i % 60 == 0 or i <= 5:
            print(f"[WAIT] Ch·ªù chu k·ª≥ ti·∫øp theo: {i}s...", end='\r')
            sys.stdout.flush()
        time.sleep(1)
    print("[WAIT] B·∫Øt ƒë·∫ßu chu k·ª≥ m·ªõi!                    ")

# ==============================================================================
# -- DISCORD BOT (SI√äU NH·∫∏ - NO OWNER CHECK) --
# ==============================================================================

if DISCORD_AVAILABLE:
    class LightBot(discord.Client):
        def __init__(self, prefix="!"):
            # T·ªëi ∆∞u h√≥a Intents: T·∫Øt h·∫øt nh·ªØng th·ª© kh√¥ng c·∫ßn thi·∫øt
            intents = discord.Intents.default()
            intents.message_content = True  # C·∫ßn c√°i n√†y ƒë·ªÉ ƒë·ªçc n·ªôi dung l·ªánh
            intents.members = False         
            intents.presences = False       
            intents.typing = False          
            
            # max_messages=None: T·∫ÆT ho√†n to√†n cache tin nh·∫Øn -> Ti·∫øt ki·ªám RAM
            super().__init__(intents=intents, max_messages=None)
            self.prefix = prefix

        async def on_ready(self):
            print(f"[DISCORD] ‚úÖ Bot Online (ID: {self.user.id}). Nh·∫≠n l·ªánh t·ª´ m·ªçi ng∆∞·ªùi.")

        async def on_message(self, message):
            # Logic: B·ªè qua tin nh·∫Øn c·ªßa ch√≠nh bot
            if message.author == self.user:
                return

            # Logic: ƒê√∫ng l·ªánh -> Reboot ngay l·∫≠p t·ª©c (Kh√¥ng check Owner ID)
            if message.content == f"{self.prefix}reboot":
                print(f"[DISCORD] ‚ö†Ô∏è Nh·∫≠n l·ªánh REBOOT t·ª´ {message.author.name}")
                await message.channel.send("ü´° ƒêang Reboot ngay l·∫≠p t·ª©c...")
                perform_reboot("DISCORD_CMD")

def run_discord_thread():
    """Ch·∫°y bot trong lu·ªìng ng·∫ßm."""
    while True:
        cfg = fetch_and_load_config(CONFIG_URL)
        token = cfg.get("DISCORD_BOT_TOKEN", "")
        
        if token:
            try:
                print("[DISCORD] ƒêang kh·ªüi ƒë·ªông Bot...")
                bot = LightBot(prefix=cfg.get("DISCORD_PREFIX", "!"))
                bot.run(token)
            except Exception as e:
                print(f"[DISCORD] ‚ùå Bot l·ªói: {e}. Th·ª≠ l·∫°i sau 60s.")
        else:
            print("[DISCORD] ‚ö†Ô∏è Thi·∫øu Token. Bot t·∫°m d·ª´ng.")
        
        time.sleep(60) # Ch·ªù tr∆∞·ªõc khi th·ª≠ l·∫°i n·∫øu crash

# ==============================================================================
# -- LOGIC FARM (G·ªòP SCAN & LAUNCH) --
# ==============================================================================

def api_request(method, url, config, json_data=None, use_proxy=False):
    """H√†m g·ªçi API chung cho c·∫£ Scan v√† Check Status."""
    global proxy_index, failed_proxy_count, current_proxies
    
    # 1. Direct Request (Kh√¥ng Proxy) - D√πng cho check status
    if not use_proxy:
        try:
            if method == 'GET': r = requests.get(url, timeout=config["CONNECTION_TIMEOUT"])
            else: r = requests.post(url, json=json_data, timeout=config["CONNECTION_TIMEOUT"])
            return r.json() if r.status_code == 200 else None
        except: return None

    # 2. Proxy Request - D√πng cho Scan server
    proxies = current_proxies
    if not proxies: return None 
    
    retry = 0
    while retry < 3: 
        p = proxies[proxy_index]
        try:
            if method == 'GET': r = requests.get(url, proxies=p, timeout=config["CONNECTION_TIMEOUT"])
            else: r = requests.post(url, json=json_data, proxies=p, timeout=config["CONNECTION_TIMEOUT"])
            
            if r.status_code == 200:
                failed_proxy_count = 0
                return r.json()
            elif r.status_code == 429:
                pass 
        except:
            failed_proxy_count += 1
        
        proxy_index = (proxy_index + 1) % len(proxies)
        retry += 1
        
    return None

def task_logic_scan(config):
    """Ph·∫ßn 1: Qu√©t Server."""
    print("[TASK] ƒêang qu√©t server m·ªõi...")
    global current_proxies
    current_proxies = format_proxies(config["PROXY_LIST"])
    
    collected = []
    cursor = ""
    min_r, max_r = config["MIN_PLAYER_PERCENTAGE"]/100, config["MAX_PLAYER_PERCENTAGE"]/100
    
    # Qu√©t t·ªëi ƒëa 5 trang
    for _ in range(5):
        url = f"https://games.roblox.com/v1/games/{config['PLACE_ID']}/servers/Public?sortOrder=Desc&limit=100"
        if cursor: url += f"&cursor={cursor}"
        
        data = api_request('GET', url, config, use_proxy=True)
        if not data: break
        
        servers = data.get("data", [])
        cursor = data.get("nextPageCursor")
        
        for s in servers:
            mp = s.get("maxPlayers", 0)
            if mp > 0:
                ratio = s.get("playing", 0) / mp
                if min_r <= ratio <= max_r:
                    collected.append(s.get("id"))
        
        if not cursor: break
    
    if collected:
        with open(config["OUTPUT_FILE_PATH"], "w") as f:
            for sid in collected: f.write(f"{sid}\n")
        print(f"[TASK] ‚úÖ T√¨m th·∫•y {len(collected)} servers.")
    else:
        print("[TASK] ‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y server m·ªõi.")

def task_logic_launch(config, mode):
    """Ph·∫ßn 2: V√†o Game."""
    print("[TASK] Ki·ªÉm tra t√†i kho·∫£n v√† v√†o game...")
    accounts = config.get("ACCOUNT_SUFFIXES", [])
    if not accounts: return

    # Check status online
    uids = [int(a['id']) for a in accounts]
    status_map = {}
    if uids:
        res = api_request('POST', "https://presence.roblox.com/v1/presence/users", config, {"userIds": uids}, use_proxy=False)
        if res and 'userPresences' in res:
            for p in res['userPresences']:
                if p.get('userPresenceType') == 2: status_map[str(p.get('userId'))] = True

    server_ids = []
    if mode == 'scan':
        try:
            with open(config['OUTPUT_FILE_PATH'], 'r') as f:
                server_ids = [l.strip() for l in f if l.strip()]
        except: pass
    
    vip_url = config.get('VIP_SERVER_URL', "")

    for i, acc in enumerate(accounts):
        suffix, uid = acc['suffix'], acc['id']
        pkg = f"{config['BASE_PACKAGE_NAME']}{suffix}"
        
        if not status_map.get(uid, False):
            # Kill
            cmd = f"PID=$(ps -ef | grep {pkg} | grep -v grep | awk '{{print $2}}'); if [ ! -z \"$PID\" ]; then kill -9 $PID; fi"
            subprocess.run(["su", "-c", cmd], capture_output=True)
            time.sleep(1)
        
        # T·∫°o link
        url = ""
        if mode == 'scan' and server_ids:
            url = f"roblox://placeId={config['PLACE_ID']}&gameId={server_ids[i % len(server_ids)]}"
        elif mode == 'vip' and vip_url:
            url = vip_url
            
        # Launch
        if url:
            print(f"[TASK] Launching {suffix}...")
            subprocess.run(["am", "start", "-a", "android.intent.action.VIEW", "-d", url, "-p", pkg], capture_output=True)
            time.sleep(8) 

def combined_loop(mode):
    """V√≤ng l·∫∑p ch√≠nh: T·∫£i config -> Scan -> Launch -> Wait."""
    while True:
        config = fetch_and_load_config(CONFIG_URL)
        
        if mode in ['scan', 'parallel']:
            task_logic_scan(config)
        
        if mode in ['launch', 'parallel', 'vip']: 
            launch_submode = 'vip' if mode == 'vip' else 'scan'
            task_logic_launch(config, launch_submode)
        
        wait_time = config.get("SCAN_INTERVAL_SECONDS", 300)
        countdown(wait_time)

def reboot_timer_thread():
    """Lu·ªìng ƒë·∫øm ng∆∞·ª£c Reboot t·ª± ƒë·ªông."""
    config = fetch_and_load_config(CONFIG_URL)
    if config.get("REBOOT_ENABLED", "off").lower() != "on": return
    
    minutes = config.get("REBOOT_INTERVAL_MINUTES", 1200)
    print(f"[REBOOT] ‚è≥ ƒê√£ l√™n l·ªãch t·ª± ƒë·ªông reboot sau {minutes} ph√∫t.")
    
    time.sleep(minutes * 60)
    perform_reboot("AUTO_TIMER")

# ==============================================================================
# -- MAIN --
# ==============================================================================

if __name__ == "__main__":
    if not check_root_access(): sys.exit(1)

    threading.Thread(target=reboot_timer_thread, daemon=True).start()

    if DISCORD_AVAILABLE:
        threading.Thread(target=run_discord_thread, daemon=True).start()

    parser = argparse.ArgumentParser()
    parser.add_argument('mode', nargs='?', default='parallel', choices=['parallel', 'scan', 'vip'])
    args = parser.parse_args()

    print(f"[MAIN] B·∫Øt ƒë·∫ßu ch·∫ø ƒë·ªô: {args.mode.upper()}")
    try:
        combined_loop(args.mode)
    except KeyboardInterrupt:
        print("\n[MAIN] D·ª´ng script.")
